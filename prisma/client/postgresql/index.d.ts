
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model RolePermissions
 * 
 */
export type RolePermissions = $Result.DefaultSelection<Prisma.$RolePermissionsPayload>
/**
 * Model Policy
 * 
 */
export type Policy = $Result.DefaultSelection<Prisma.$PolicyPayload>
/**
 * Model RolePolicy
 * 
 */
export type RolePolicy = $Result.DefaultSelection<Prisma.$RolePolicyPayload>
/**
 * Model PermissionPolicy
 * 
 */
export type PermissionPolicy = $Result.DefaultSelection<Prisma.$PermissionPolicyPayload>
/**
 * Model Menu
 * 
 */
export type Menu = $Result.DefaultSelection<Prisma.$MenuPayload>
/**
 * Model MenuMeta
 * 
 */
export type MenuMeta = $Result.DefaultSelection<Prisma.$MenuMetaPayload>
/**
 * Model RoleMenu
 * 
 */
export type RoleMenu = $Result.DefaultSelection<Prisma.$RoleMenuPayload>
/**
 * Model DictAttachmentAttribute
 * 
 */
export type DictAttachmentAttribute = $Result.DefaultSelection<Prisma.$DictAttachmentAttributePayload>
/**
 * Model AttachmentAttribute
 * 
 */
export type AttachmentAttribute = $Result.DefaultSelection<Prisma.$AttachmentAttributePayload>
/**
 * Model Attachment
 * 
 */
export type Attachment = $Result.DefaultSelection<Prisma.$AttachmentPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model CourseContent
 * 
 */
export type CourseContent = $Result.DefaultSelection<Prisma.$CourseContentPayload>
/**
 * Model ContentAttachment
 * 
 */
export type ContentAttachment = $Result.DefaultSelection<Prisma.$ContentAttachmentPayload>
/**
 * Model DictCourseTag
 * 
 */
export type DictCourseTag = $Result.DefaultSelection<Prisma.$DictCourseTagPayload>
/**
 * Model DictCourseType
 * 
 */
export type DictCourseType = $Result.DefaultSelection<Prisma.$DictCourseTypePayload>
/**
 * Model CourseTag
 * 
 */
export type CourseTag = $Result.DefaultSelection<Prisma.$CourseTagPayload>
/**
 * Model ContentTag
 * 
 */
export type ContentTag = $Result.DefaultSelection<Prisma.$ContentTagPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model CourseComment
 * 
 */
export type CourseComment = $Result.DefaultSelection<Prisma.$CourseCommentPayload>
/**
 * Model ContentComment
 * 
 */
export type ContentComment = $Result.DefaultSelection<Prisma.$ContentCommentPayload>
/**
 * Model Note
 * 
 */
export type Note = $Result.DefaultSelection<Prisma.$NotePayload>
/**
 * Model DictPlatform
 * 
 */
export type DictPlatform = $Result.DefaultSelection<Prisma.$DictPlatformPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model GroupTransaction
 * 
 */
export type GroupTransaction = $Result.DefaultSelection<Prisma.$GroupTransactionPayload>
/**
 * Model AuditFlow
 * 
 */
export type AuditFlow = $Result.DefaultSelection<Prisma.$AuditFlowPayload>
/**
 * Model AuditStage
 * 
 */
export type AuditStage = $Result.DefaultSelection<Prisma.$AuditStagePayload>
/**
 * Model AuditRecord
 * 
 */
export type AuditRecord = $Result.DefaultSelection<Prisma.$AuditRecordPayload>
/**
 * Model DictCouponType
 * 
 */
export type DictCouponType = $Result.DefaultSelection<Prisma.$DictCouponTypePayload>
/**
 * Model Coupon
 * 
 */
export type Coupon = $Result.DefaultSelection<Prisma.$CouponPayload>
/**
 * Model BalanceRecord
 * 
 */
export type BalanceRecord = $Result.DefaultSelection<Prisma.$BalanceRecordPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs>;

  /**
   * `prisma.rolePermissions`: Exposes CRUD operations for the **RolePermissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermissions.findMany()
    * ```
    */
  get rolePermissions(): Prisma.RolePermissionsDelegate<ExtArgs>;

  /**
   * `prisma.policy`: Exposes CRUD operations for the **Policy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Policies
    * const policies = await prisma.policy.findMany()
    * ```
    */
  get policy(): Prisma.PolicyDelegate<ExtArgs>;

  /**
   * `prisma.rolePolicy`: Exposes CRUD operations for the **RolePolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePolicies
    * const rolePolicies = await prisma.rolePolicy.findMany()
    * ```
    */
  get rolePolicy(): Prisma.RolePolicyDelegate<ExtArgs>;

  /**
   * `prisma.permissionPolicy`: Exposes CRUD operations for the **PermissionPolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PermissionPolicies
    * const permissionPolicies = await prisma.permissionPolicy.findMany()
    * ```
    */
  get permissionPolicy(): Prisma.PermissionPolicyDelegate<ExtArgs>;

  /**
   * `prisma.menu`: Exposes CRUD operations for the **Menu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Menus
    * const menus = await prisma.menu.findMany()
    * ```
    */
  get menu(): Prisma.MenuDelegate<ExtArgs>;

  /**
   * `prisma.menuMeta`: Exposes CRUD operations for the **MenuMeta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenuMetas
    * const menuMetas = await prisma.menuMeta.findMany()
    * ```
    */
  get menuMeta(): Prisma.MenuMetaDelegate<ExtArgs>;

  /**
   * `prisma.roleMenu`: Exposes CRUD operations for the **RoleMenu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoleMenus
    * const roleMenus = await prisma.roleMenu.findMany()
    * ```
    */
  get roleMenu(): Prisma.RoleMenuDelegate<ExtArgs>;

  /**
   * `prisma.dictAttachmentAttribute`: Exposes CRUD operations for the **DictAttachmentAttribute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DictAttachmentAttributes
    * const dictAttachmentAttributes = await prisma.dictAttachmentAttribute.findMany()
    * ```
    */
  get dictAttachmentAttribute(): Prisma.DictAttachmentAttributeDelegate<ExtArgs>;

  /**
   * `prisma.attachmentAttribute`: Exposes CRUD operations for the **AttachmentAttribute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttachmentAttributes
    * const attachmentAttributes = await prisma.attachmentAttribute.findMany()
    * ```
    */
  get attachmentAttribute(): Prisma.AttachmentAttributeDelegate<ExtArgs>;

  /**
   * `prisma.attachment`: Exposes CRUD operations for the **Attachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attachments
    * const attachments = await prisma.attachment.findMany()
    * ```
    */
  get attachment(): Prisma.AttachmentDelegate<ExtArgs>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs>;

  /**
   * `prisma.courseContent`: Exposes CRUD operations for the **CourseContent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseContents
    * const courseContents = await prisma.courseContent.findMany()
    * ```
    */
  get courseContent(): Prisma.CourseContentDelegate<ExtArgs>;

  /**
   * `prisma.contentAttachment`: Exposes CRUD operations for the **ContentAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentAttachments
    * const contentAttachments = await prisma.contentAttachment.findMany()
    * ```
    */
  get contentAttachment(): Prisma.ContentAttachmentDelegate<ExtArgs>;

  /**
   * `prisma.dictCourseTag`: Exposes CRUD operations for the **DictCourseTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DictCourseTags
    * const dictCourseTags = await prisma.dictCourseTag.findMany()
    * ```
    */
  get dictCourseTag(): Prisma.DictCourseTagDelegate<ExtArgs>;

  /**
   * `prisma.dictCourseType`: Exposes CRUD operations for the **DictCourseType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DictCourseTypes
    * const dictCourseTypes = await prisma.dictCourseType.findMany()
    * ```
    */
  get dictCourseType(): Prisma.DictCourseTypeDelegate<ExtArgs>;

  /**
   * `prisma.courseTag`: Exposes CRUD operations for the **CourseTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseTags
    * const courseTags = await prisma.courseTag.findMany()
    * ```
    */
  get courseTag(): Prisma.CourseTagDelegate<ExtArgs>;

  /**
   * `prisma.contentTag`: Exposes CRUD operations for the **ContentTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentTags
    * const contentTags = await prisma.contentTag.findMany()
    * ```
    */
  get contentTag(): Prisma.ContentTagDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.courseComment`: Exposes CRUD operations for the **CourseComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseComments
    * const courseComments = await prisma.courseComment.findMany()
    * ```
    */
  get courseComment(): Prisma.CourseCommentDelegate<ExtArgs>;

  /**
   * `prisma.contentComment`: Exposes CRUD operations for the **ContentComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentComments
    * const contentComments = await prisma.contentComment.findMany()
    * ```
    */
  get contentComment(): Prisma.ContentCommentDelegate<ExtArgs>;

  /**
   * `prisma.note`: Exposes CRUD operations for the **Note** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notes
    * const notes = await prisma.note.findMany()
    * ```
    */
  get note(): Prisma.NoteDelegate<ExtArgs>;

  /**
   * `prisma.dictPlatform`: Exposes CRUD operations for the **DictPlatform** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DictPlatforms
    * const dictPlatforms = await prisma.dictPlatform.findMany()
    * ```
    */
  get dictPlatform(): Prisma.DictPlatformDelegate<ExtArgs>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs>;

  /**
   * `prisma.groupTransaction`: Exposes CRUD operations for the **GroupTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupTransactions
    * const groupTransactions = await prisma.groupTransaction.findMany()
    * ```
    */
  get groupTransaction(): Prisma.GroupTransactionDelegate<ExtArgs>;

  /**
   * `prisma.auditFlow`: Exposes CRUD operations for the **AuditFlow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditFlows
    * const auditFlows = await prisma.auditFlow.findMany()
    * ```
    */
  get auditFlow(): Prisma.AuditFlowDelegate<ExtArgs>;

  /**
   * `prisma.auditStage`: Exposes CRUD operations for the **AuditStage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditStages
    * const auditStages = await prisma.auditStage.findMany()
    * ```
    */
  get auditStage(): Prisma.AuditStageDelegate<ExtArgs>;

  /**
   * `prisma.auditRecord`: Exposes CRUD operations for the **AuditRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditRecords
    * const auditRecords = await prisma.auditRecord.findMany()
    * ```
    */
  get auditRecord(): Prisma.AuditRecordDelegate<ExtArgs>;

  /**
   * `prisma.dictCouponType`: Exposes CRUD operations for the **DictCouponType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DictCouponTypes
    * const dictCouponTypes = await prisma.dictCouponType.findMany()
    * ```
    */
  get dictCouponType(): Prisma.DictCouponTypeDelegate<ExtArgs>;

  /**
   * `prisma.coupon`: Exposes CRUD operations for the **Coupon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coupons
    * const coupons = await prisma.coupon.findMany()
    * ```
    */
  get coupon(): Prisma.CouponDelegate<ExtArgs>;

  /**
   * `prisma.balanceRecord`: Exposes CRUD operations for the **BalanceRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BalanceRecords
    * const balanceRecords = await prisma.balanceRecord.findMany()
    * ```
    */
  get balanceRecord(): Prisma.BalanceRecordDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Role: 'Role',
    UserRole: 'UserRole',
    Permission: 'Permission',
    RolePermissions: 'RolePermissions',
    Policy: 'Policy',
    RolePolicy: 'RolePolicy',
    PermissionPolicy: 'PermissionPolicy',
    Menu: 'Menu',
    MenuMeta: 'MenuMeta',
    RoleMenu: 'RoleMenu',
    DictAttachmentAttribute: 'DictAttachmentAttribute',
    AttachmentAttribute: 'AttachmentAttribute',
    Attachment: 'Attachment',
    Course: 'Course',
    CourseContent: 'CourseContent',
    ContentAttachment: 'ContentAttachment',
    DictCourseTag: 'DictCourseTag',
    DictCourseType: 'DictCourseType',
    CourseTag: 'CourseTag',
    ContentTag: 'ContentTag',
    Comment: 'Comment',
    CourseComment: 'CourseComment',
    ContentComment: 'ContentComment',
    Note: 'Note',
    DictPlatform: 'DictPlatform',
    Transaction: 'Transaction',
    GroupTransaction: 'GroupTransaction',
    AuditFlow: 'AuditFlow',
    AuditStage: 'AuditStage',
    AuditRecord: 'AuditRecord',
    DictCouponType: 'DictCouponType',
    Coupon: 'Coupon',
    BalanceRecord: 'BalanceRecord'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "role" | "userRole" | "permission" | "rolePermissions" | "policy" | "rolePolicy" | "permissionPolicy" | "menu" | "menuMeta" | "roleMenu" | "dictAttachmentAttribute" | "attachmentAttribute" | "attachment" | "course" | "courseContent" | "contentAttachment" | "dictCourseTag" | "dictCourseType" | "courseTag" | "contentTag" | "comment" | "courseComment" | "contentComment" | "note" | "dictPlatform" | "transaction" | "groupTransaction" | "auditFlow" | "auditStage" | "auditRecord" | "dictCouponType" | "coupon" | "balanceRecord"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      RolePermissions: {
        payload: Prisma.$RolePermissionsPayload<ExtArgs>
        fields: Prisma.RolePermissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload>
          }
          findMany: {
            args: Prisma.RolePermissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload>[]
          }
          create: {
            args: Prisma.RolePermissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload>
          }
          createMany: {
            args: Prisma.RolePermissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolePermissionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload>[]
          }
          delete: {
            args: Prisma.RolePermissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload>
          }
          update: {
            args: Prisma.RolePermissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolePermissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermissions>
          }
          groupBy: {
            args: Prisma.RolePermissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionsCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionsCountAggregateOutputType> | number
          }
        }
      }
      Policy: {
        payload: Prisma.$PolicyPayload<ExtArgs>
        fields: Prisma.PolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          findFirst: {
            args: Prisma.PolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          findMany: {
            args: Prisma.PolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>[]
          }
          create: {
            args: Prisma.PolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          createMany: {
            args: Prisma.PolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>[]
          }
          delete: {
            args: Prisma.PolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          update: {
            args: Prisma.PolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          deleteMany: {
            args: Prisma.PolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          aggregate: {
            args: Prisma.PolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePolicy>
          }
          groupBy: {
            args: Prisma.PolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PolicyCountArgs<ExtArgs>
            result: $Utils.Optional<PolicyCountAggregateOutputType> | number
          }
        }
      }
      RolePolicy: {
        payload: Prisma.$RolePolicyPayload<ExtArgs>
        fields: Prisma.RolePolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePolicyPayload>
          }
          findFirst: {
            args: Prisma.RolePolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePolicyPayload>
          }
          findMany: {
            args: Prisma.RolePolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePolicyPayload>[]
          }
          create: {
            args: Prisma.RolePolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePolicyPayload>
          }
          createMany: {
            args: Prisma.RolePolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolePolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePolicyPayload>[]
          }
          delete: {
            args: Prisma.RolePolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePolicyPayload>
          }
          update: {
            args: Prisma.RolePolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePolicyPayload>
          }
          deleteMany: {
            args: Prisma.RolePolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolePolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePolicyPayload>
          }
          aggregate: {
            args: Prisma.RolePolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePolicy>
          }
          groupBy: {
            args: Prisma.RolePolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePolicyCountArgs<ExtArgs>
            result: $Utils.Optional<RolePolicyCountAggregateOutputType> | number
          }
        }
      }
      PermissionPolicy: {
        payload: Prisma.$PermissionPolicyPayload<ExtArgs>
        fields: Prisma.PermissionPolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionPolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionPolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPolicyPayload>
          }
          findFirst: {
            args: Prisma.PermissionPolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionPolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPolicyPayload>
          }
          findMany: {
            args: Prisma.PermissionPolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPolicyPayload>[]
          }
          create: {
            args: Prisma.PermissionPolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPolicyPayload>
          }
          createMany: {
            args: Prisma.PermissionPolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionPolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPolicyPayload>[]
          }
          delete: {
            args: Prisma.PermissionPolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPolicyPayload>
          }
          update: {
            args: Prisma.PermissionPolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPolicyPayload>
          }
          deleteMany: {
            args: Prisma.PermissionPolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionPolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermissionPolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPolicyPayload>
          }
          aggregate: {
            args: Prisma.PermissionPolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermissionPolicy>
          }
          groupBy: {
            args: Prisma.PermissionPolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionPolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionPolicyCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionPolicyCountAggregateOutputType> | number
          }
        }
      }
      Menu: {
        payload: Prisma.$MenuPayload<ExtArgs>
        fields: Prisma.MenuFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenuFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenuFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          findFirst: {
            args: Prisma.MenuFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenuFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          findMany: {
            args: Prisma.MenuFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>[]
          }
          create: {
            args: Prisma.MenuCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          createMany: {
            args: Prisma.MenuCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenuCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>[]
          }
          delete: {
            args: Prisma.MenuDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          update: {
            args: Prisma.MenuUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          deleteMany: {
            args: Prisma.MenuDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenuUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MenuUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          aggregate: {
            args: Prisma.MenuAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenu>
          }
          groupBy: {
            args: Prisma.MenuGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenuGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenuCountArgs<ExtArgs>
            result: $Utils.Optional<MenuCountAggregateOutputType> | number
          }
        }
      }
      MenuMeta: {
        payload: Prisma.$MenuMetaPayload<ExtArgs>
        fields: Prisma.MenuMetaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenuMetaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuMetaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenuMetaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuMetaPayload>
          }
          findFirst: {
            args: Prisma.MenuMetaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuMetaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenuMetaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuMetaPayload>
          }
          findMany: {
            args: Prisma.MenuMetaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuMetaPayload>[]
          }
          create: {
            args: Prisma.MenuMetaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuMetaPayload>
          }
          createMany: {
            args: Prisma.MenuMetaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenuMetaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuMetaPayload>[]
          }
          delete: {
            args: Prisma.MenuMetaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuMetaPayload>
          }
          update: {
            args: Prisma.MenuMetaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuMetaPayload>
          }
          deleteMany: {
            args: Prisma.MenuMetaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenuMetaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MenuMetaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuMetaPayload>
          }
          aggregate: {
            args: Prisma.MenuMetaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenuMeta>
          }
          groupBy: {
            args: Prisma.MenuMetaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenuMetaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenuMetaCountArgs<ExtArgs>
            result: $Utils.Optional<MenuMetaCountAggregateOutputType> | number
          }
        }
      }
      RoleMenu: {
        payload: Prisma.$RoleMenuPayload<ExtArgs>
        fields: Prisma.RoleMenuFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleMenuFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleMenuPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleMenuFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleMenuPayload>
          }
          findFirst: {
            args: Prisma.RoleMenuFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleMenuPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleMenuFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleMenuPayload>
          }
          findMany: {
            args: Prisma.RoleMenuFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleMenuPayload>[]
          }
          create: {
            args: Prisma.RoleMenuCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleMenuPayload>
          }
          createMany: {
            args: Prisma.RoleMenuCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleMenuCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleMenuPayload>[]
          }
          delete: {
            args: Prisma.RoleMenuDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleMenuPayload>
          }
          update: {
            args: Prisma.RoleMenuUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleMenuPayload>
          }
          deleteMany: {
            args: Prisma.RoleMenuDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleMenuUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleMenuUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleMenuPayload>
          }
          aggregate: {
            args: Prisma.RoleMenuAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoleMenu>
          }
          groupBy: {
            args: Prisma.RoleMenuGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleMenuGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleMenuCountArgs<ExtArgs>
            result: $Utils.Optional<RoleMenuCountAggregateOutputType> | number
          }
        }
      }
      DictAttachmentAttribute: {
        payload: Prisma.$DictAttachmentAttributePayload<ExtArgs>
        fields: Prisma.DictAttachmentAttributeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DictAttachmentAttributeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictAttachmentAttributePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DictAttachmentAttributeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictAttachmentAttributePayload>
          }
          findFirst: {
            args: Prisma.DictAttachmentAttributeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictAttachmentAttributePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DictAttachmentAttributeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictAttachmentAttributePayload>
          }
          findMany: {
            args: Prisma.DictAttachmentAttributeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictAttachmentAttributePayload>[]
          }
          create: {
            args: Prisma.DictAttachmentAttributeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictAttachmentAttributePayload>
          }
          createMany: {
            args: Prisma.DictAttachmentAttributeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DictAttachmentAttributeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictAttachmentAttributePayload>[]
          }
          delete: {
            args: Prisma.DictAttachmentAttributeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictAttachmentAttributePayload>
          }
          update: {
            args: Prisma.DictAttachmentAttributeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictAttachmentAttributePayload>
          }
          deleteMany: {
            args: Prisma.DictAttachmentAttributeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DictAttachmentAttributeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DictAttachmentAttributeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictAttachmentAttributePayload>
          }
          aggregate: {
            args: Prisma.DictAttachmentAttributeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDictAttachmentAttribute>
          }
          groupBy: {
            args: Prisma.DictAttachmentAttributeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DictAttachmentAttributeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DictAttachmentAttributeCountArgs<ExtArgs>
            result: $Utils.Optional<DictAttachmentAttributeCountAggregateOutputType> | number
          }
        }
      }
      AttachmentAttribute: {
        payload: Prisma.$AttachmentAttributePayload<ExtArgs>
        fields: Prisma.AttachmentAttributeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttachmentAttributeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentAttributePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttachmentAttributeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentAttributePayload>
          }
          findFirst: {
            args: Prisma.AttachmentAttributeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentAttributePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttachmentAttributeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentAttributePayload>
          }
          findMany: {
            args: Prisma.AttachmentAttributeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentAttributePayload>[]
          }
          create: {
            args: Prisma.AttachmentAttributeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentAttributePayload>
          }
          createMany: {
            args: Prisma.AttachmentAttributeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttachmentAttributeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentAttributePayload>[]
          }
          delete: {
            args: Prisma.AttachmentAttributeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentAttributePayload>
          }
          update: {
            args: Prisma.AttachmentAttributeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentAttributePayload>
          }
          deleteMany: {
            args: Prisma.AttachmentAttributeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttachmentAttributeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttachmentAttributeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentAttributePayload>
          }
          aggregate: {
            args: Prisma.AttachmentAttributeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttachmentAttribute>
          }
          groupBy: {
            args: Prisma.AttachmentAttributeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttachmentAttributeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttachmentAttributeCountArgs<ExtArgs>
            result: $Utils.Optional<AttachmentAttributeCountAggregateOutputType> | number
          }
        }
      }
      Attachment: {
        payload: Prisma.$AttachmentPayload<ExtArgs>
        fields: Prisma.AttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findFirst: {
            args: Prisma.AttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findMany: {
            args: Prisma.AttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          create: {
            args: Prisma.AttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          createMany: {
            args: Prisma.AttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          delete: {
            args: Prisma.AttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          update: {
            args: Prisma.AttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          deleteMany: {
            args: Prisma.AttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          aggregate: {
            args: Prisma.AttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttachment>
          }
          groupBy: {
            args: Prisma.AttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<AttachmentCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      CourseContent: {
        payload: Prisma.$CourseContentPayload<ExtArgs>
        fields: Prisma.CourseContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseContentPayload>
          }
          findFirst: {
            args: Prisma.CourseContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseContentPayload>
          }
          findMany: {
            args: Prisma.CourseContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseContentPayload>[]
          }
          create: {
            args: Prisma.CourseContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseContentPayload>
          }
          createMany: {
            args: Prisma.CourseContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseContentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseContentPayload>[]
          }
          delete: {
            args: Prisma.CourseContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseContentPayload>
          }
          update: {
            args: Prisma.CourseContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseContentPayload>
          }
          deleteMany: {
            args: Prisma.CourseContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseContentPayload>
          }
          aggregate: {
            args: Prisma.CourseContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseContent>
          }
          groupBy: {
            args: Prisma.CourseContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseContentCountArgs<ExtArgs>
            result: $Utils.Optional<CourseContentCountAggregateOutputType> | number
          }
        }
      }
      ContentAttachment: {
        payload: Prisma.$ContentAttachmentPayload<ExtArgs>
        fields: Prisma.ContentAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentAttachmentPayload>
          }
          findFirst: {
            args: Prisma.ContentAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentAttachmentPayload>
          }
          findMany: {
            args: Prisma.ContentAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentAttachmentPayload>[]
          }
          create: {
            args: Prisma.ContentAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentAttachmentPayload>
          }
          createMany: {
            args: Prisma.ContentAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentAttachmentPayload>[]
          }
          delete: {
            args: Prisma.ContentAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentAttachmentPayload>
          }
          update: {
            args: Prisma.ContentAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.ContentAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContentAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentAttachmentPayload>
          }
          aggregate: {
            args: Prisma.ContentAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentAttachment>
          }
          groupBy: {
            args: Prisma.ContentAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<ContentAttachmentCountAggregateOutputType> | number
          }
        }
      }
      DictCourseTag: {
        payload: Prisma.$DictCourseTagPayload<ExtArgs>
        fields: Prisma.DictCourseTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DictCourseTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCourseTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DictCourseTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCourseTagPayload>
          }
          findFirst: {
            args: Prisma.DictCourseTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCourseTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DictCourseTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCourseTagPayload>
          }
          findMany: {
            args: Prisma.DictCourseTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCourseTagPayload>[]
          }
          create: {
            args: Prisma.DictCourseTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCourseTagPayload>
          }
          createMany: {
            args: Prisma.DictCourseTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DictCourseTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCourseTagPayload>[]
          }
          delete: {
            args: Prisma.DictCourseTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCourseTagPayload>
          }
          update: {
            args: Prisma.DictCourseTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCourseTagPayload>
          }
          deleteMany: {
            args: Prisma.DictCourseTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DictCourseTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DictCourseTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCourseTagPayload>
          }
          aggregate: {
            args: Prisma.DictCourseTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDictCourseTag>
          }
          groupBy: {
            args: Prisma.DictCourseTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<DictCourseTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.DictCourseTagCountArgs<ExtArgs>
            result: $Utils.Optional<DictCourseTagCountAggregateOutputType> | number
          }
        }
      }
      DictCourseType: {
        payload: Prisma.$DictCourseTypePayload<ExtArgs>
        fields: Prisma.DictCourseTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DictCourseTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCourseTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DictCourseTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCourseTypePayload>
          }
          findFirst: {
            args: Prisma.DictCourseTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCourseTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DictCourseTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCourseTypePayload>
          }
          findMany: {
            args: Prisma.DictCourseTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCourseTypePayload>[]
          }
          create: {
            args: Prisma.DictCourseTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCourseTypePayload>
          }
          createMany: {
            args: Prisma.DictCourseTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DictCourseTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCourseTypePayload>[]
          }
          delete: {
            args: Prisma.DictCourseTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCourseTypePayload>
          }
          update: {
            args: Prisma.DictCourseTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCourseTypePayload>
          }
          deleteMany: {
            args: Prisma.DictCourseTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DictCourseTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DictCourseTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCourseTypePayload>
          }
          aggregate: {
            args: Prisma.DictCourseTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDictCourseType>
          }
          groupBy: {
            args: Prisma.DictCourseTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DictCourseTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DictCourseTypeCountArgs<ExtArgs>
            result: $Utils.Optional<DictCourseTypeCountAggregateOutputType> | number
          }
        }
      }
      CourseTag: {
        payload: Prisma.$CourseTagPayload<ExtArgs>
        fields: Prisma.CourseTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload>
          }
          findFirst: {
            args: Prisma.CourseTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload>
          }
          findMany: {
            args: Prisma.CourseTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload>[]
          }
          create: {
            args: Prisma.CourseTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload>
          }
          createMany: {
            args: Prisma.CourseTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload>[]
          }
          delete: {
            args: Prisma.CourseTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload>
          }
          update: {
            args: Prisma.CourseTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload>
          }
          deleteMany: {
            args: Prisma.CourseTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTagPayload>
          }
          aggregate: {
            args: Prisma.CourseTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseTag>
          }
          groupBy: {
            args: Prisma.CourseTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseTagCountArgs<ExtArgs>
            result: $Utils.Optional<CourseTagCountAggregateOutputType> | number
          }
        }
      }
      ContentTag: {
        payload: Prisma.$ContentTagPayload<ExtArgs>
        fields: Prisma.ContentTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTagPayload>
          }
          findFirst: {
            args: Prisma.ContentTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTagPayload>
          }
          findMany: {
            args: Prisma.ContentTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTagPayload>[]
          }
          create: {
            args: Prisma.ContentTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTagPayload>
          }
          createMany: {
            args: Prisma.ContentTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTagPayload>[]
          }
          delete: {
            args: Prisma.ContentTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTagPayload>
          }
          update: {
            args: Prisma.ContentTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTagPayload>
          }
          deleteMany: {
            args: Prisma.ContentTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContentTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTagPayload>
          }
          aggregate: {
            args: Prisma.ContentTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentTag>
          }
          groupBy: {
            args: Prisma.ContentTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentTagCountArgs<ExtArgs>
            result: $Utils.Optional<ContentTagCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      CourseComment: {
        payload: Prisma.$CourseCommentPayload<ExtArgs>
        fields: Prisma.CourseCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCommentPayload>
          }
          findFirst: {
            args: Prisma.CourseCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCommentPayload>
          }
          findMany: {
            args: Prisma.CourseCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCommentPayload>[]
          }
          create: {
            args: Prisma.CourseCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCommentPayload>
          }
          createMany: {
            args: Prisma.CourseCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCommentPayload>[]
          }
          delete: {
            args: Prisma.CourseCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCommentPayload>
          }
          update: {
            args: Prisma.CourseCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCommentPayload>
          }
          deleteMany: {
            args: Prisma.CourseCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCommentPayload>
          }
          aggregate: {
            args: Prisma.CourseCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseComment>
          }
          groupBy: {
            args: Prisma.CourseCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCommentCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCommentCountAggregateOutputType> | number
          }
        }
      }
      ContentComment: {
        payload: Prisma.$ContentCommentPayload<ExtArgs>
        fields: Prisma.ContentCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCommentPayload>
          }
          findFirst: {
            args: Prisma.ContentCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCommentPayload>
          }
          findMany: {
            args: Prisma.ContentCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCommentPayload>[]
          }
          create: {
            args: Prisma.ContentCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCommentPayload>
          }
          createMany: {
            args: Prisma.ContentCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCommentPayload>[]
          }
          delete: {
            args: Prisma.ContentCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCommentPayload>
          }
          update: {
            args: Prisma.ContentCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCommentPayload>
          }
          deleteMany: {
            args: Prisma.ContentCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContentCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentCommentPayload>
          }
          aggregate: {
            args: Prisma.ContentCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentComment>
          }
          groupBy: {
            args: Prisma.ContentCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentCommentCountArgs<ExtArgs>
            result: $Utils.Optional<ContentCommentCountAggregateOutputType> | number
          }
        }
      }
      Note: {
        payload: Prisma.$NotePayload<ExtArgs>
        fields: Prisma.NoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          findFirst: {
            args: Prisma.NoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          findMany: {
            args: Prisma.NoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>[]
          }
          create: {
            args: Prisma.NoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          createMany: {
            args: Prisma.NoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>[]
          }
          delete: {
            args: Prisma.NoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          update: {
            args: Prisma.NoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          deleteMany: {
            args: Prisma.NoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          aggregate: {
            args: Prisma.NoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNote>
          }
          groupBy: {
            args: Prisma.NoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoteCountArgs<ExtArgs>
            result: $Utils.Optional<NoteCountAggregateOutputType> | number
          }
        }
      }
      DictPlatform: {
        payload: Prisma.$DictPlatformPayload<ExtArgs>
        fields: Prisma.DictPlatformFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DictPlatformFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictPlatformPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DictPlatformFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictPlatformPayload>
          }
          findFirst: {
            args: Prisma.DictPlatformFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictPlatformPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DictPlatformFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictPlatformPayload>
          }
          findMany: {
            args: Prisma.DictPlatformFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictPlatformPayload>[]
          }
          create: {
            args: Prisma.DictPlatformCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictPlatformPayload>
          }
          createMany: {
            args: Prisma.DictPlatformCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DictPlatformCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictPlatformPayload>[]
          }
          delete: {
            args: Prisma.DictPlatformDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictPlatformPayload>
          }
          update: {
            args: Prisma.DictPlatformUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictPlatformPayload>
          }
          deleteMany: {
            args: Prisma.DictPlatformDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DictPlatformUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DictPlatformUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictPlatformPayload>
          }
          aggregate: {
            args: Prisma.DictPlatformAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDictPlatform>
          }
          groupBy: {
            args: Prisma.DictPlatformGroupByArgs<ExtArgs>
            result: $Utils.Optional<DictPlatformGroupByOutputType>[]
          }
          count: {
            args: Prisma.DictPlatformCountArgs<ExtArgs>
            result: $Utils.Optional<DictPlatformCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      GroupTransaction: {
        payload: Prisma.$GroupTransactionPayload<ExtArgs>
        fields: Prisma.GroupTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupTransactionPayload>
          }
          findFirst: {
            args: Prisma.GroupTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupTransactionPayload>
          }
          findMany: {
            args: Prisma.GroupTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupTransactionPayload>[]
          }
          create: {
            args: Prisma.GroupTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupTransactionPayload>
          }
          createMany: {
            args: Prisma.GroupTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupTransactionPayload>[]
          }
          delete: {
            args: Prisma.GroupTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupTransactionPayload>
          }
          update: {
            args: Prisma.GroupTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupTransactionPayload>
          }
          deleteMany: {
            args: Prisma.GroupTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GroupTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupTransactionPayload>
          }
          aggregate: {
            args: Prisma.GroupTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupTransaction>
          }
          groupBy: {
            args: Prisma.GroupTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<GroupTransactionCountAggregateOutputType> | number
          }
        }
      }
      AuditFlow: {
        payload: Prisma.$AuditFlowPayload<ExtArgs>
        fields: Prisma.AuditFlowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditFlowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditFlowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditFlowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditFlowPayload>
          }
          findFirst: {
            args: Prisma.AuditFlowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditFlowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditFlowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditFlowPayload>
          }
          findMany: {
            args: Prisma.AuditFlowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditFlowPayload>[]
          }
          create: {
            args: Prisma.AuditFlowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditFlowPayload>
          }
          createMany: {
            args: Prisma.AuditFlowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditFlowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditFlowPayload>[]
          }
          delete: {
            args: Prisma.AuditFlowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditFlowPayload>
          }
          update: {
            args: Prisma.AuditFlowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditFlowPayload>
          }
          deleteMany: {
            args: Prisma.AuditFlowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditFlowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditFlowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditFlowPayload>
          }
          aggregate: {
            args: Prisma.AuditFlowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditFlow>
          }
          groupBy: {
            args: Prisma.AuditFlowGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditFlowGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditFlowCountArgs<ExtArgs>
            result: $Utils.Optional<AuditFlowCountAggregateOutputType> | number
          }
        }
      }
      AuditStage: {
        payload: Prisma.$AuditStagePayload<ExtArgs>
        fields: Prisma.AuditStageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditStageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditStagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditStageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditStagePayload>
          }
          findFirst: {
            args: Prisma.AuditStageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditStagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditStageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditStagePayload>
          }
          findMany: {
            args: Prisma.AuditStageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditStagePayload>[]
          }
          create: {
            args: Prisma.AuditStageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditStagePayload>
          }
          createMany: {
            args: Prisma.AuditStageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditStageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditStagePayload>[]
          }
          delete: {
            args: Prisma.AuditStageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditStagePayload>
          }
          update: {
            args: Prisma.AuditStageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditStagePayload>
          }
          deleteMany: {
            args: Prisma.AuditStageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditStageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditStageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditStagePayload>
          }
          aggregate: {
            args: Prisma.AuditStageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditStage>
          }
          groupBy: {
            args: Prisma.AuditStageGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditStageGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditStageCountArgs<ExtArgs>
            result: $Utils.Optional<AuditStageCountAggregateOutputType> | number
          }
        }
      }
      AuditRecord: {
        payload: Prisma.$AuditRecordPayload<ExtArgs>
        fields: Prisma.AuditRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload>
          }
          findFirst: {
            args: Prisma.AuditRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload>
          }
          findMany: {
            args: Prisma.AuditRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload>[]
          }
          create: {
            args: Prisma.AuditRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload>
          }
          createMany: {
            args: Prisma.AuditRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload>[]
          }
          delete: {
            args: Prisma.AuditRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload>
          }
          update: {
            args: Prisma.AuditRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload>
          }
          deleteMany: {
            args: Prisma.AuditRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditRecordPayload>
          }
          aggregate: {
            args: Prisma.AuditRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditRecord>
          }
          groupBy: {
            args: Prisma.AuditRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditRecordCountArgs<ExtArgs>
            result: $Utils.Optional<AuditRecordCountAggregateOutputType> | number
          }
        }
      }
      DictCouponType: {
        payload: Prisma.$DictCouponTypePayload<ExtArgs>
        fields: Prisma.DictCouponTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DictCouponTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCouponTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DictCouponTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCouponTypePayload>
          }
          findFirst: {
            args: Prisma.DictCouponTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCouponTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DictCouponTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCouponTypePayload>
          }
          findMany: {
            args: Prisma.DictCouponTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCouponTypePayload>[]
          }
          create: {
            args: Prisma.DictCouponTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCouponTypePayload>
          }
          createMany: {
            args: Prisma.DictCouponTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DictCouponTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCouponTypePayload>[]
          }
          delete: {
            args: Prisma.DictCouponTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCouponTypePayload>
          }
          update: {
            args: Prisma.DictCouponTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCouponTypePayload>
          }
          deleteMany: {
            args: Prisma.DictCouponTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DictCouponTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DictCouponTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DictCouponTypePayload>
          }
          aggregate: {
            args: Prisma.DictCouponTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDictCouponType>
          }
          groupBy: {
            args: Prisma.DictCouponTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DictCouponTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DictCouponTypeCountArgs<ExtArgs>
            result: $Utils.Optional<DictCouponTypeCountAggregateOutputType> | number
          }
        }
      }
      Coupon: {
        payload: Prisma.$CouponPayload<ExtArgs>
        fields: Prisma.CouponFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CouponFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CouponFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          findFirst: {
            args: Prisma.CouponFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CouponFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          findMany: {
            args: Prisma.CouponFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          create: {
            args: Prisma.CouponCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          createMany: {
            args: Prisma.CouponCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CouponCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          delete: {
            args: Prisma.CouponDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          update: {
            args: Prisma.CouponUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          deleteMany: {
            args: Prisma.CouponDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CouponUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CouponUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          aggregate: {
            args: Prisma.CouponAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoupon>
          }
          groupBy: {
            args: Prisma.CouponGroupByArgs<ExtArgs>
            result: $Utils.Optional<CouponGroupByOutputType>[]
          }
          count: {
            args: Prisma.CouponCountArgs<ExtArgs>
            result: $Utils.Optional<CouponCountAggregateOutputType> | number
          }
        }
      }
      BalanceRecord: {
        payload: Prisma.$BalanceRecordPayload<ExtArgs>
        fields: Prisma.BalanceRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BalanceRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BalanceRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceRecordPayload>
          }
          findFirst: {
            args: Prisma.BalanceRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BalanceRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceRecordPayload>
          }
          findMany: {
            args: Prisma.BalanceRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceRecordPayload>[]
          }
          create: {
            args: Prisma.BalanceRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceRecordPayload>
          }
          createMany: {
            args: Prisma.BalanceRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BalanceRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceRecordPayload>[]
          }
          delete: {
            args: Prisma.BalanceRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceRecordPayload>
          }
          update: {
            args: Prisma.BalanceRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceRecordPayload>
          }
          deleteMany: {
            args: Prisma.BalanceRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BalanceRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BalanceRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceRecordPayload>
          }
          aggregate: {
            args: Prisma.BalanceRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBalanceRecord>
          }
          groupBy: {
            args: Prisma.BalanceRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<BalanceRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.BalanceRecordCountArgs<ExtArgs>
            result: $Utils.Optional<BalanceRecordCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    UserRole: number
    Attachment: number
    Course: number
    CourseContent: number
    Comment: number
    Transaction: number
    AuditRecord: number
    BalanceRecord: number
    Note: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserRole?: boolean | UserCountOutputTypeCountUserRoleArgs
    Attachment?: boolean | UserCountOutputTypeCountAttachmentArgs
    Course?: boolean | UserCountOutputTypeCountCourseArgs
    CourseContent?: boolean | UserCountOutputTypeCountCourseContentArgs
    Comment?: boolean | UserCountOutputTypeCountCommentArgs
    Transaction?: boolean | UserCountOutputTypeCountTransactionArgs
    AuditRecord?: boolean | UserCountOutputTypeCountAuditRecordArgs
    BalanceRecord?: boolean | UserCountOutputTypeCountBalanceRecordArgs
    Note?: boolean | UserCountOutputTypeCountNoteArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCourseContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseContentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditRecordWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBalanceRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalanceRecordWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
    RolePermissions: number
    RolePolicy: number
    RoleMenu: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
    RolePermissions?: boolean | RoleCountOutputTypeCountRolePermissionsArgs
    RolePolicy?: boolean | RoleCountOutputTypeCountRolePolicyArgs
    RoleMenu?: boolean | RoleCountOutputTypeCountRoleMenuArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountRolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionsWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountRolePolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePolicyWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountRoleMenuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleMenuWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    RolePermissions: number
    PermissionPolicy: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RolePermissions?: boolean | PermissionCountOutputTypeCountRolePermissionsArgs
    PermissionPolicy?: boolean | PermissionCountOutputTypeCountPermissionPolicyArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionsWhereInput
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountPermissionPolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionPolicyWhereInput
  }


  /**
   * Count Type PolicyCountOutputType
   */

  export type PolicyCountOutputType = {
    RolePolicy: number
    PermissionPolicy: number
  }

  export type PolicyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RolePolicy?: boolean | PolicyCountOutputTypeCountRolePolicyArgs
    PermissionPolicy?: boolean | PolicyCountOutputTypeCountPermissionPolicyArgs
  }

  // Custom InputTypes
  /**
   * PolicyCountOutputType without action
   */
  export type PolicyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyCountOutputType
     */
    select?: PolicyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PolicyCountOutputType without action
   */
  export type PolicyCountOutputTypeCountRolePolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePolicyWhereInput
  }

  /**
   * PolicyCountOutputType without action
   */
  export type PolicyCountOutputTypeCountPermissionPolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionPolicyWhereInput
  }


  /**
   * Count Type MenuCountOutputType
   */

  export type MenuCountOutputType = {
    children: number
    roleMenus: number
  }

  export type MenuCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | MenuCountOutputTypeCountChildrenArgs
    roleMenus?: boolean | MenuCountOutputTypeCountRoleMenusArgs
  }

  // Custom InputTypes
  /**
   * MenuCountOutputType without action
   */
  export type MenuCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuCountOutputType
     */
    select?: MenuCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MenuCountOutputType without action
   */
  export type MenuCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuWhereInput
  }

  /**
   * MenuCountOutputType without action
   */
  export type MenuCountOutputTypeCountRoleMenusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleMenuWhereInput
  }


  /**
   * Count Type DictAttachmentAttributeCountOutputType
   */

  export type DictAttachmentAttributeCountOutputType = {
    AttachmentAttribute: number
  }

  export type DictAttachmentAttributeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AttachmentAttribute?: boolean | DictAttachmentAttributeCountOutputTypeCountAttachmentAttributeArgs
  }

  // Custom InputTypes
  /**
   * DictAttachmentAttributeCountOutputType without action
   */
  export type DictAttachmentAttributeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictAttachmentAttributeCountOutputType
     */
    select?: DictAttachmentAttributeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DictAttachmentAttributeCountOutputType without action
   */
  export type DictAttachmentAttributeCountOutputTypeCountAttachmentAttributeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentAttributeWhereInput
  }


  /**
   * Count Type AttachmentCountOutputType
   */

  export type AttachmentCountOutputType = {
    AttachmentAttribute: number
    Course: number
    ContentAttachment: number
  }

  export type AttachmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AttachmentAttribute?: boolean | AttachmentCountOutputTypeCountAttachmentAttributeArgs
    Course?: boolean | AttachmentCountOutputTypeCountCourseArgs
    ContentAttachment?: boolean | AttachmentCountOutputTypeCountContentAttachmentArgs
  }

  // Custom InputTypes
  /**
   * AttachmentCountOutputType without action
   */
  export type AttachmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttachmentCountOutputType
     */
    select?: AttachmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AttachmentCountOutputType without action
   */
  export type AttachmentCountOutputTypeCountAttachmentAttributeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentAttributeWhereInput
  }

  /**
   * AttachmentCountOutputType without action
   */
  export type AttachmentCountOutputTypeCountCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * AttachmentCountOutputType without action
   */
  export type AttachmentCountOutputTypeCountContentAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentAttachmentWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    Contents: number
    Tags: number
    CourseComment: number
    Transaction: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Contents?: boolean | CourseCountOutputTypeCountContentsArgs
    Tags?: boolean | CourseCountOutputTypeCountTagsArgs
    CourseComment?: boolean | CourseCountOutputTypeCountCourseCommentArgs
    Transaction?: boolean | CourseCountOutputTypeCountTransactionArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountContentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseContentWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseTagWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCourseCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseCommentWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type CourseContentCountOutputType
   */

  export type CourseContentCountOutputType = {
    Attachments: number
    Tags: number
    ContentComment: number
  }

  export type CourseContentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Attachments?: boolean | CourseContentCountOutputTypeCountAttachmentsArgs
    Tags?: boolean | CourseContentCountOutputTypeCountTagsArgs
    ContentComment?: boolean | CourseContentCountOutputTypeCountContentCommentArgs
  }

  // Custom InputTypes
  /**
   * CourseContentCountOutputType without action
   */
  export type CourseContentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContentCountOutputType
     */
    select?: CourseContentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseContentCountOutputType without action
   */
  export type CourseContentCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentAttachmentWhereInput
  }

  /**
   * CourseContentCountOutputType without action
   */
  export type CourseContentCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentTagWhereInput
  }

  /**
   * CourseContentCountOutputType without action
   */
  export type CourseContentCountOutputTypeCountContentCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentCommentWhereInput
  }


  /**
   * Count Type DictCourseTagCountOutputType
   */

  export type DictCourseTagCountOutputType = {
    CourseTag: number
    ContentTag: number
  }

  export type DictCourseTagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CourseTag?: boolean | DictCourseTagCountOutputTypeCountCourseTagArgs
    ContentTag?: boolean | DictCourseTagCountOutputTypeCountContentTagArgs
  }

  // Custom InputTypes
  /**
   * DictCourseTagCountOutputType without action
   */
  export type DictCourseTagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCourseTagCountOutputType
     */
    select?: DictCourseTagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DictCourseTagCountOutputType without action
   */
  export type DictCourseTagCountOutputTypeCountCourseTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseTagWhereInput
  }

  /**
   * DictCourseTagCountOutputType without action
   */
  export type DictCourseTagCountOutputTypeCountContentTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentTagWhereInput
  }


  /**
   * Count Type DictCourseTypeCountOutputType
   */

  export type DictCourseTypeCountOutputType = {
    CourseTags: number
  }

  export type DictCourseTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CourseTags?: boolean | DictCourseTypeCountOutputTypeCountCourseTagsArgs
  }

  // Custom InputTypes
  /**
   * DictCourseTypeCountOutputType without action
   */
  export type DictCourseTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCourseTypeCountOutputType
     */
    select?: DictCourseTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DictCourseTypeCountOutputType without action
   */
  export type DictCourseTypeCountOutputTypeCountCourseTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DictCourseTagWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    children: number
    CourseComment: number
    ContentComment: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | CommentCountOutputTypeCountChildrenArgs
    CourseComment?: boolean | CommentCountOutputTypeCountCourseCommentArgs
    ContentComment?: boolean | CommentCountOutputTypeCountContentCommentArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountCourseCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseCommentWhereInput
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountContentCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentCommentWhereInput
  }


  /**
   * Count Type DictPlatformCountOutputType
   */

  export type DictPlatformCountOutputType = {
    Transaction: number
  }

  export type DictPlatformCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Transaction?: boolean | DictPlatformCountOutputTypeCountTransactionArgs
  }

  // Custom InputTypes
  /**
   * DictPlatformCountOutputType without action
   */
  export type DictPlatformCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictPlatformCountOutputType
     */
    select?: DictPlatformCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DictPlatformCountOutputType without action
   */
  export type DictPlatformCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type TransactionCountOutputType
   */

  export type TransactionCountOutputType = {
    GroupTransaction: number
    BalanceRecord: number
  }

  export type TransactionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    GroupTransaction?: boolean | TransactionCountOutputTypeCountGroupTransactionArgs
    BalanceRecord?: boolean | TransactionCountOutputTypeCountBalanceRecordArgs
  }

  // Custom InputTypes
  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCountOutputType
     */
    select?: TransactionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountGroupTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupTransactionWhereInput
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountBalanceRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalanceRecordWhereInput
  }


  /**
   * Count Type AuditFlowCountOutputType
   */

  export type AuditFlowCountOutputType = {
    AuditStage: number
  }

  export type AuditFlowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AuditStage?: boolean | AuditFlowCountOutputTypeCountAuditStageArgs
  }

  // Custom InputTypes
  /**
   * AuditFlowCountOutputType without action
   */
  export type AuditFlowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditFlowCountOutputType
     */
    select?: AuditFlowCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuditFlowCountOutputType without action
   */
  export type AuditFlowCountOutputTypeCountAuditStageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditStageWhereInput
  }


  /**
   * Count Type AuditStageCountOutputType
   */

  export type AuditStageCountOutputType = {
    children: number
    AuditRecord: number
  }

  export type AuditStageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | AuditStageCountOutputTypeCountChildrenArgs
    AuditRecord?: boolean | AuditStageCountOutputTypeCountAuditRecordArgs
  }

  // Custom InputTypes
  /**
   * AuditStageCountOutputType without action
   */
  export type AuditStageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStageCountOutputType
     */
    select?: AuditStageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuditStageCountOutputType without action
   */
  export type AuditStageCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditStageWhereInput
  }

  /**
   * AuditStageCountOutputType without action
   */
  export type AuditStageCountOutputTypeCountAuditRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditRecordWhereInput
  }


  /**
   * Count Type DictCouponTypeCountOutputType
   */

  export type DictCouponTypeCountOutputType = {
    Coupon: number
  }

  export type DictCouponTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Coupon?: boolean | DictCouponTypeCountOutputTypeCountCouponArgs
  }

  // Custom InputTypes
  /**
   * DictCouponTypeCountOutputType without action
   */
  export type DictCouponTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCouponTypeCountOutputType
     */
    select?: DictCouponTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DictCouponTypeCountOutputType without action
   */
  export type DictCouponTypeCountOutputTypeCountCouponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    password: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    UserRole?: boolean | User$UserRoleArgs<ExtArgs>
    Attachment?: boolean | User$AttachmentArgs<ExtArgs>
    Course?: boolean | User$CourseArgs<ExtArgs>
    CourseContent?: boolean | User$CourseContentArgs<ExtArgs>
    Comment?: boolean | User$CommentArgs<ExtArgs>
    Transaction?: boolean | User$TransactionArgs<ExtArgs>
    AuditRecord?: boolean | User$AuditRecordArgs<ExtArgs>
    BalanceRecord?: boolean | User$BalanceRecordArgs<ExtArgs>
    Note?: boolean | User$NoteArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserRole?: boolean | User$UserRoleArgs<ExtArgs>
    Attachment?: boolean | User$AttachmentArgs<ExtArgs>
    Course?: boolean | User$CourseArgs<ExtArgs>
    CourseContent?: boolean | User$CourseContentArgs<ExtArgs>
    Comment?: boolean | User$CommentArgs<ExtArgs>
    Transaction?: boolean | User$TransactionArgs<ExtArgs>
    AuditRecord?: boolean | User$AuditRecordArgs<ExtArgs>
    BalanceRecord?: boolean | User$BalanceRecordArgs<ExtArgs>
    Note?: boolean | User$NoteArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      UserRole: Prisma.$UserRolePayload<ExtArgs>[]
      Attachment: Prisma.$AttachmentPayload<ExtArgs>[]
      Course: Prisma.$CoursePayload<ExtArgs>[]
      CourseContent: Prisma.$CourseContentPayload<ExtArgs>[]
      Comment: Prisma.$CommentPayload<ExtArgs>[]
      Transaction: Prisma.$TransactionPayload<ExtArgs>[]
      AuditRecord: Prisma.$AuditRecordPayload<ExtArgs>[]
      BalanceRecord: Prisma.$BalanceRecordPayload<ExtArgs>[]
      Note: Prisma.$NotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      password: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    UserRole<T extends User$UserRoleArgs<ExtArgs> = {}>(args?: Subset<T, User$UserRoleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    Attachment<T extends User$AttachmentArgs<ExtArgs> = {}>(args?: Subset<T, User$AttachmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    Course<T extends User$CourseArgs<ExtArgs> = {}>(args?: Subset<T, User$CourseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany"> | Null>
    CourseContent<T extends User$CourseContentArgs<ExtArgs> = {}>(args?: Subset<T, User$CourseContentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, "findMany"> | Null>
    Comment<T extends User$CommentArgs<ExtArgs> = {}>(args?: Subset<T, User$CommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    Transaction<T extends User$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, User$TransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    AuditRecord<T extends User$AuditRecordArgs<ExtArgs> = {}>(args?: Subset<T, User$AuditRecordArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "findMany"> | Null>
    BalanceRecord<T extends User$BalanceRecordArgs<ExtArgs> = {}>(args?: Subset<T, User$BalanceRecordArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalanceRecordPayload<ExtArgs>, T, "findMany"> | Null>
    Note<T extends User$NoteArgs<ExtArgs> = {}>(args?: Subset<T, User$NoteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.UserRole
   */
  export type User$UserRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.Attachment
   */
  export type User$AttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * User.Course
   */
  export type User$CourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * User.CourseContent
   */
  export type User$CourseContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContent
     */
    select?: CourseContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseContentInclude<ExtArgs> | null
    where?: CourseContentWhereInput
    orderBy?: CourseContentOrderByWithRelationInput | CourseContentOrderByWithRelationInput[]
    cursor?: CourseContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseContentScalarFieldEnum | CourseContentScalarFieldEnum[]
  }

  /**
   * User.Comment
   */
  export type User$CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.Transaction
   */
  export type User$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.AuditRecord
   */
  export type User$AuditRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    where?: AuditRecordWhereInput
    orderBy?: AuditRecordOrderByWithRelationInput | AuditRecordOrderByWithRelationInput[]
    cursor?: AuditRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditRecordScalarFieldEnum | AuditRecordScalarFieldEnum[]
  }

  /**
   * User.BalanceRecord
   */
  export type User$BalanceRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceRecord
     */
    select?: BalanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceRecordInclude<ExtArgs> | null
    where?: BalanceRecordWhereInput
    orderBy?: BalanceRecordOrderByWithRelationInput | BalanceRecordOrderByWithRelationInput[]
    cursor?: BalanceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BalanceRecordScalarFieldEnum | BalanceRecordScalarFieldEnum[]
  }

  /**
   * User.Note
   */
  export type User$NoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    name: string
    description: string | null
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    RolePermissions?: boolean | Role$RolePermissionsArgs<ExtArgs>
    RolePolicy?: boolean | Role$RolePolicyArgs<ExtArgs>
    RoleMenu?: boolean | Role$RoleMenuArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    RolePermissions?: boolean | Role$RolePermissionsArgs<ExtArgs>
    RolePolicy?: boolean | Role$RolePolicyArgs<ExtArgs>
    RoleMenu?: boolean | Role$RoleMenuArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      users: Prisma.$UserRolePayload<ExtArgs>[]
      RolePermissions: Prisma.$RolePermissionsPayload<ExtArgs>[]
      RolePolicy: Prisma.$RolePolicyPayload<ExtArgs>[]
      RoleMenu: Prisma.$RoleMenuPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    RolePermissions<T extends Role$RolePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Role$RolePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "findMany"> | Null>
    RolePolicy<T extends Role$RolePolicyArgs<ExtArgs> = {}>(args?: Subset<T, Role$RolePolicyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePolicyPayload<ExtArgs>, T, "findMany"> | Null>
    RoleMenu<T extends Role$RoleMenuArgs<ExtArgs> = {}>(args?: Subset<T, Role$RoleMenuArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleMenuPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'Int'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role.RolePermissions
   */
  export type Role$RolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsInclude<ExtArgs> | null
    where?: RolePermissionsWhereInput
    orderBy?: RolePermissionsOrderByWithRelationInput | RolePermissionsOrderByWithRelationInput[]
    cursor?: RolePermissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionsScalarFieldEnum | RolePermissionsScalarFieldEnum[]
  }

  /**
   * Role.RolePolicy
   */
  export type Role$RolePolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyInclude<ExtArgs> | null
    where?: RolePolicyWhereInput
    orderBy?: RolePolicyOrderByWithRelationInput | RolePolicyOrderByWithRelationInput[]
    cursor?: RolePolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePolicyScalarFieldEnum | RolePolicyScalarFieldEnum[]
  }

  /**
   * Role.RoleMenu
   */
  export type Role$RoleMenuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleMenu
     */
    select?: RoleMenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleMenuInclude<ExtArgs> | null
    where?: RoleMenuWhereInput
    orderBy?: RoleMenuOrderByWithRelationInput | RoleMenuOrderByWithRelationInput[]
    cursor?: RoleMenuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleMenuScalarFieldEnum | RoleMenuScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleAvgAggregateOutputType = {
    userId: number | null
    roleId: number | null
  }

  export type UserRoleSumAggregateOutputType = {
    userId: number | null
    roleId: number | null
  }

  export type UserRoleMinAggregateOutputType = {
    userId: number | null
    roleId: number | null
  }

  export type UserRoleMaxAggregateOutputType = {
    userId: number | null
    roleId: number | null
  }

  export type UserRoleCountAggregateOutputType = {
    userId: number
    roleId: number
    _all: number
  }


  export type UserRoleAvgAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserRoleSumAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserRoleMinAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserRoleMaxAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserRoleCountAggregateInputType = {
    userId?: true
    roleId?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _avg?: UserRoleAvgAggregateInputType
    _sum?: UserRoleSumAggregateInputType
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    userId: number
    roleId: number
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    userId?: boolean
    roleId?: boolean
  }

  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      roleId: number
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */ 
  interface UserRoleFieldRefs {
    readonly userId: FieldRef<"UserRole", 'Int'>
    readonly roleId: FieldRef<"UserRole", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionAvgAggregateOutputType = {
    id: number | null
  }

  export type PermissionSumAggregateOutputType = {
    id: number | null
  }

  export type PermissionMinAggregateOutputType = {
    id: number | null
    name: string | null
    action: string | null
    description: string | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    action: string | null
    description: string | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    name: number
    action: number
    description: number
    _all: number
  }


  export type PermissionAvgAggregateInputType = {
    id?: true
  }

  export type PermissionSumAggregateInputType = {
    id?: true
  }

  export type PermissionMinAggregateInputType = {
    id?: true
    name?: true
    action?: true
    description?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    name?: true
    action?: true
    description?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    name?: true
    action?: true
    description?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _avg?: PermissionAvgAggregateInputType
    _sum?: PermissionSumAggregateInputType
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: number
    name: string
    action: string
    description: string | null
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    action?: boolean
    description?: boolean
    RolePermissions?: boolean | Permission$RolePermissionsArgs<ExtArgs>
    PermissionPolicy?: boolean | Permission$PermissionPolicyArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    action?: boolean
    description?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    name?: boolean
    action?: boolean
    description?: boolean
  }

  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RolePermissions?: boolean | Permission$RolePermissionsArgs<ExtArgs>
    PermissionPolicy?: boolean | Permission$PermissionPolicyArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      RolePermissions: Prisma.$RolePermissionsPayload<ExtArgs>[]
      PermissionPolicy: Prisma.$PermissionPolicyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      action: string
      description: string | null
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RolePermissions<T extends Permission$RolePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Permission$RolePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "findMany"> | Null>
    PermissionPolicy<T extends Permission$PermissionPolicyArgs<ExtArgs> = {}>(args?: Subset<T, Permission$PermissionPolicyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPolicyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */ 
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'Int'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly action: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission.RolePermissions
   */
  export type Permission$RolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsInclude<ExtArgs> | null
    where?: RolePermissionsWhereInput
    orderBy?: RolePermissionsOrderByWithRelationInput | RolePermissionsOrderByWithRelationInput[]
    cursor?: RolePermissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionsScalarFieldEnum | RolePermissionsScalarFieldEnum[]
  }

  /**
   * Permission.PermissionPolicy
   */
  export type Permission$PermissionPolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionPolicy
     */
    select?: PermissionPolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionPolicyInclude<ExtArgs> | null
    where?: PermissionPolicyWhereInput
    orderBy?: PermissionPolicyOrderByWithRelationInput | PermissionPolicyOrderByWithRelationInput[]
    cursor?: PermissionPolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionPolicyScalarFieldEnum | PermissionPolicyScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model RolePermissions
   */

  export type AggregateRolePermissions = {
    _count: RolePermissionsCountAggregateOutputType | null
    _avg: RolePermissionsAvgAggregateOutputType | null
    _sum: RolePermissionsSumAggregateOutputType | null
    _min: RolePermissionsMinAggregateOutputType | null
    _max: RolePermissionsMaxAggregateOutputType | null
  }

  export type RolePermissionsAvgAggregateOutputType = {
    roleId: number | null
    permissionId: number | null
  }

  export type RolePermissionsSumAggregateOutputType = {
    roleId: number | null
    permissionId: number | null
  }

  export type RolePermissionsMinAggregateOutputType = {
    roleId: number | null
    permissionId: number | null
  }

  export type RolePermissionsMaxAggregateOutputType = {
    roleId: number | null
    permissionId: number | null
  }

  export type RolePermissionsCountAggregateOutputType = {
    roleId: number
    permissionId: number
    _all: number
  }


  export type RolePermissionsAvgAggregateInputType = {
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionsSumAggregateInputType = {
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionsMinAggregateInputType = {
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionsMaxAggregateInputType = {
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionsCountAggregateInputType = {
    roleId?: true
    permissionId?: true
    _all?: true
  }

  export type RolePermissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to aggregate.
     */
    where?: RolePermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionsOrderByWithRelationInput | RolePermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolePermissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolePermissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionsMaxAggregateInputType
  }

  export type GetRolePermissionsAggregateType<T extends RolePermissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermissions[P]>
      : GetScalarType<T[P], AggregateRolePermissions[P]>
  }




  export type RolePermissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionsWhereInput
    orderBy?: RolePermissionsOrderByWithAggregationInput | RolePermissionsOrderByWithAggregationInput[]
    by: RolePermissionsScalarFieldEnum[] | RolePermissionsScalarFieldEnum
    having?: RolePermissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionsCountAggregateInputType | true
    _avg?: RolePermissionsAvgAggregateInputType
    _sum?: RolePermissionsSumAggregateInputType
    _min?: RolePermissionsMinAggregateInputType
    _max?: RolePermissionsMaxAggregateInputType
  }

  export type RolePermissionsGroupByOutputType = {
    roleId: number
    permissionId: number
    _count: RolePermissionsCountAggregateOutputType | null
    _avg: RolePermissionsAvgAggregateOutputType | null
    _sum: RolePermissionsSumAggregateOutputType | null
    _min: RolePermissionsMinAggregateOutputType | null
    _max: RolePermissionsMaxAggregateOutputType | null
  }

  type GetRolePermissionsGroupByPayload<T extends RolePermissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionsGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionsGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    permissionId?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermissions"]>

  export type RolePermissionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    permissionId?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermissions"]>

  export type RolePermissionsSelectScalar = {
    roleId?: boolean
    permissionId?: boolean
  }

  export type RolePermissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type RolePermissionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }

  export type $RolePermissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermissions"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      permission: Prisma.$PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      roleId: number
      permissionId: number
    }, ExtArgs["result"]["rolePermissions"]>
    composites: {}
  }

  type RolePermissionsGetPayload<S extends boolean | null | undefined | RolePermissionsDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionsPayload, S>

  type RolePermissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RolePermissionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolePermissionsCountAggregateInputType | true
    }

  export interface RolePermissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermissions'], meta: { name: 'RolePermissions' } }
    /**
     * Find zero or one RolePermissions that matches the filter.
     * @param {RolePermissionsFindUniqueArgs} args - Arguments to find a RolePermissions
     * @example
     * // Get one RolePermissions
     * const rolePermissions = await prisma.rolePermissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionsFindUniqueArgs>(args: SelectSubset<T, RolePermissionsFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionsClient<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RolePermissions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RolePermissionsFindUniqueOrThrowArgs} args - Arguments to find a RolePermissions
     * @example
     * // Get one RolePermissions
     * const rolePermissions = await prisma.rolePermissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionsClient<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsFindFirstArgs} args - Arguments to find a RolePermissions
     * @example
     * // Get one RolePermissions
     * const rolePermissions = await prisma.rolePermissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionsFindFirstArgs>(args?: SelectSubset<T, RolePermissionsFindFirstArgs<ExtArgs>>): Prisma__RolePermissionsClient<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RolePermissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsFindFirstOrThrowArgs} args - Arguments to find a RolePermissions
     * @example
     * // Get one RolePermissions
     * const rolePermissions = await prisma.rolePermissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionsClient<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermissions.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermissions.findMany({ take: 10 })
     * 
     * // Only select the `roleId`
     * const rolePermissionsWithRoleIdOnly = await prisma.rolePermissions.findMany({ select: { roleId: true } })
     * 
     */
    findMany<T extends RolePermissionsFindManyArgs>(args?: SelectSubset<T, RolePermissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RolePermissions.
     * @param {RolePermissionsCreateArgs} args - Arguments to create a RolePermissions.
     * @example
     * // Create one RolePermissions
     * const RolePermissions = await prisma.rolePermissions.create({
     *   data: {
     *     // ... data to create a RolePermissions
     *   }
     * })
     * 
     */
    create<T extends RolePermissionsCreateArgs>(args: SelectSubset<T, RolePermissionsCreateArgs<ExtArgs>>): Prisma__RolePermissionsClient<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionsCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermissions = await prisma.rolePermissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionsCreateManyArgs>(args?: SelectSubset<T, RolePermissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolePermissions and returns the data saved in the database.
     * @param {RolePermissionsCreateManyAndReturnArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermissions = await prisma.rolePermissions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolePermissions and only return the `roleId`
     * const rolePermissionsWithRoleIdOnly = await prisma.rolePermissions.createManyAndReturn({ 
     *   select: { roleId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolePermissionsCreateManyAndReturnArgs>(args?: SelectSubset<T, RolePermissionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RolePermissions.
     * @param {RolePermissionsDeleteArgs} args - Arguments to delete one RolePermissions.
     * @example
     * // Delete one RolePermissions
     * const RolePermissions = await prisma.rolePermissions.delete({
     *   where: {
     *     // ... filter to delete one RolePermissions
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionsDeleteArgs>(args: SelectSubset<T, RolePermissionsDeleteArgs<ExtArgs>>): Prisma__RolePermissionsClient<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RolePermissions.
     * @param {RolePermissionsUpdateArgs} args - Arguments to update one RolePermissions.
     * @example
     * // Update one RolePermissions
     * const rolePermissions = await prisma.rolePermissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionsUpdateArgs>(args: SelectSubset<T, RolePermissionsUpdateArgs<ExtArgs>>): Prisma__RolePermissionsClient<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionsDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionsDeleteManyArgs>(args?: SelectSubset<T, RolePermissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermissions = await prisma.rolePermissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionsUpdateManyArgs>(args: SelectSubset<T, RolePermissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolePermissions.
     * @param {RolePermissionsUpsertArgs} args - Arguments to update or create a RolePermissions.
     * @example
     * // Update or create a RolePermissions
     * const rolePermissions = await prisma.rolePermissions.upsert({
     *   create: {
     *     // ... data to create a RolePermissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermissions we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionsUpsertArgs>(args: SelectSubset<T, RolePermissionsUpsertArgs<ExtArgs>>): Prisma__RolePermissionsClient<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermissions.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionsCountArgs>(
      args?: Subset<T, RolePermissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionsAggregateArgs>(args: Subset<T, RolePermissionsAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionsAggregateType<T>>

    /**
     * Group by RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionsGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermissions model
   */
  readonly fields: RolePermissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermissions model
   */ 
  interface RolePermissionsFieldRefs {
    readonly roleId: FieldRef<"RolePermissions", 'Int'>
    readonly permissionId: FieldRef<"RolePermissions", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RolePermissions findUnique
   */
  export type RolePermissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where: RolePermissionsWhereUniqueInput
  }

  /**
   * RolePermissions findUniqueOrThrow
   */
  export type RolePermissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where: RolePermissionsWhereUniqueInput
  }

  /**
   * RolePermissions findFirst
   */
  export type RolePermissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionsOrderByWithRelationInput | RolePermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionsScalarFieldEnum | RolePermissionsScalarFieldEnum[]
  }

  /**
   * RolePermissions findFirstOrThrow
   */
  export type RolePermissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionsOrderByWithRelationInput | RolePermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionsScalarFieldEnum | RolePermissionsScalarFieldEnum[]
  }

  /**
   * RolePermissions findMany
   */
  export type RolePermissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionsOrderByWithRelationInput | RolePermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionsScalarFieldEnum | RolePermissionsScalarFieldEnum[]
  }

  /**
   * RolePermissions create
   */
  export type RolePermissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermissions.
     */
    data: XOR<RolePermissionsCreateInput, RolePermissionsUncheckedCreateInput>
  }

  /**
   * RolePermissions createMany
   */
  export type RolePermissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionsCreateManyInput | RolePermissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermissions createManyAndReturn
   */
  export type RolePermissionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionsCreateManyInput | RolePermissionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermissions update
   */
  export type RolePermissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermissions.
     */
    data: XOR<RolePermissionsUpdateInput, RolePermissionsUncheckedUpdateInput>
    /**
     * Choose, which RolePermissions to update.
     */
    where: RolePermissionsWhereUniqueInput
  }

  /**
   * RolePermissions updateMany
   */
  export type RolePermissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionsUpdateManyMutationInput, RolePermissionsUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionsWhereInput
  }

  /**
   * RolePermissions upsert
   */
  export type RolePermissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermissions to update in case it exists.
     */
    where: RolePermissionsWhereUniqueInput
    /**
     * In case the RolePermissions found by the `where` argument doesn't exist, create a new RolePermissions with this data.
     */
    create: XOR<RolePermissionsCreateInput, RolePermissionsUncheckedCreateInput>
    /**
     * In case the RolePermissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionsUpdateInput, RolePermissionsUncheckedUpdateInput>
  }

  /**
   * RolePermissions delete
   */
  export type RolePermissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsInclude<ExtArgs> | null
    /**
     * Filter which RolePermissions to delete.
     */
    where: RolePermissionsWhereUniqueInput
  }

  /**
   * RolePermissions deleteMany
   */
  export type RolePermissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionsWhereInput
  }

  /**
   * RolePermissions without action
   */
  export type RolePermissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionsInclude<ExtArgs> | null
  }


  /**
   * Model Policy
   */

  export type AggregatePolicy = {
    _count: PolicyCountAggregateOutputType | null
    _avg: PolicyAvgAggregateOutputType | null
    _sum: PolicySumAggregateOutputType | null
    _min: PolicyMinAggregateOutputType | null
    _max: PolicyMaxAggregateOutputType | null
  }

  export type PolicyAvgAggregateOutputType = {
    id: number | null
    type: number | null
  }

  export type PolicySumAggregateOutputType = {
    id: number | null
    type: number | null
  }

  export type PolicyMinAggregateOutputType = {
    id: number | null
    type: number | null
    effect: string | null
    action: string | null
    subject: string | null
    encode: string | null
  }

  export type PolicyMaxAggregateOutputType = {
    id: number | null
    type: number | null
    effect: string | null
    action: string | null
    subject: string | null
    encode: string | null
  }

  export type PolicyCountAggregateOutputType = {
    id: number
    type: number
    effect: number
    action: number
    subject: number
    fields: number
    conditions: number
    args: number
    encode: number
    _all: number
  }


  export type PolicyAvgAggregateInputType = {
    id?: true
    type?: true
  }

  export type PolicySumAggregateInputType = {
    id?: true
    type?: true
  }

  export type PolicyMinAggregateInputType = {
    id?: true
    type?: true
    effect?: true
    action?: true
    subject?: true
    encode?: true
  }

  export type PolicyMaxAggregateInputType = {
    id?: true
    type?: true
    effect?: true
    action?: true
    subject?: true
    encode?: true
  }

  export type PolicyCountAggregateInputType = {
    id?: true
    type?: true
    effect?: true
    action?: true
    subject?: true
    fields?: true
    conditions?: true
    args?: true
    encode?: true
    _all?: true
  }

  export type PolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Policy to aggregate.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Policies
    **/
    _count?: true | PolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PolicyMaxAggregateInputType
  }

  export type GetPolicyAggregateType<T extends PolicyAggregateArgs> = {
        [P in keyof T & keyof AggregatePolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePolicy[P]>
      : GetScalarType<T[P], AggregatePolicy[P]>
  }




  export type PolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyWhereInput
    orderBy?: PolicyOrderByWithAggregationInput | PolicyOrderByWithAggregationInput[]
    by: PolicyScalarFieldEnum[] | PolicyScalarFieldEnum
    having?: PolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PolicyCountAggregateInputType | true
    _avg?: PolicyAvgAggregateInputType
    _sum?: PolicySumAggregateInputType
    _min?: PolicyMinAggregateInputType
    _max?: PolicyMaxAggregateInputType
  }

  export type PolicyGroupByOutputType = {
    id: number
    type: number
    effect: string
    action: string
    subject: string
    fields: JsonValue | null
    conditions: JsonValue | null
    args: JsonValue | null
    encode: string
    _count: PolicyCountAggregateOutputType | null
    _avg: PolicyAvgAggregateOutputType | null
    _sum: PolicySumAggregateOutputType | null
    _min: PolicyMinAggregateOutputType | null
    _max: PolicyMaxAggregateOutputType | null
  }

  type GetPolicyGroupByPayload<T extends PolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PolicyGroupByOutputType[P]>
            : GetScalarType<T[P], PolicyGroupByOutputType[P]>
        }
      >
    >


  export type PolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    effect?: boolean
    action?: boolean
    subject?: boolean
    fields?: boolean
    conditions?: boolean
    args?: boolean
    encode?: boolean
    RolePolicy?: boolean | Policy$RolePolicyArgs<ExtArgs>
    PermissionPolicy?: boolean | Policy$PermissionPolicyArgs<ExtArgs>
    _count?: boolean | PolicyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["policy"]>

  export type PolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    effect?: boolean
    action?: boolean
    subject?: boolean
    fields?: boolean
    conditions?: boolean
    args?: boolean
    encode?: boolean
  }, ExtArgs["result"]["policy"]>

  export type PolicySelectScalar = {
    id?: boolean
    type?: boolean
    effect?: boolean
    action?: boolean
    subject?: boolean
    fields?: boolean
    conditions?: boolean
    args?: boolean
    encode?: boolean
  }

  export type PolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RolePolicy?: boolean | Policy$RolePolicyArgs<ExtArgs>
    PermissionPolicy?: boolean | Policy$PermissionPolicyArgs<ExtArgs>
    _count?: boolean | PolicyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PolicyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Policy"
    objects: {
      RolePolicy: Prisma.$RolePolicyPayload<ExtArgs>[]
      PermissionPolicy: Prisma.$PermissionPolicyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: number
      effect: string
      action: string
      subject: string
      fields: Prisma.JsonValue | null
      conditions: Prisma.JsonValue | null
      args: Prisma.JsonValue | null
      encode: string
    }, ExtArgs["result"]["policy"]>
    composites: {}
  }

  type PolicyGetPayload<S extends boolean | null | undefined | PolicyDefaultArgs> = $Result.GetResult<Prisma.$PolicyPayload, S>

  type PolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PolicyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PolicyCountAggregateInputType | true
    }

  export interface PolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Policy'], meta: { name: 'Policy' } }
    /**
     * Find zero or one Policy that matches the filter.
     * @param {PolicyFindUniqueArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PolicyFindUniqueArgs>(args: SelectSubset<T, PolicyFindUniqueArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Policy that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PolicyFindUniqueOrThrowArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, PolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Policy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindFirstArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PolicyFindFirstArgs>(args?: SelectSubset<T, PolicyFindFirstArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Policy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindFirstOrThrowArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, PolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Policies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Policies
     * const policies = await prisma.policy.findMany()
     * 
     * // Get first 10 Policies
     * const policies = await prisma.policy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const policyWithIdOnly = await prisma.policy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PolicyFindManyArgs>(args?: SelectSubset<T, PolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Policy.
     * @param {PolicyCreateArgs} args - Arguments to create a Policy.
     * @example
     * // Create one Policy
     * const Policy = await prisma.policy.create({
     *   data: {
     *     // ... data to create a Policy
     *   }
     * })
     * 
     */
    create<T extends PolicyCreateArgs>(args: SelectSubset<T, PolicyCreateArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Policies.
     * @param {PolicyCreateManyArgs} args - Arguments to create many Policies.
     * @example
     * // Create many Policies
     * const policy = await prisma.policy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PolicyCreateManyArgs>(args?: SelectSubset<T, PolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Policies and returns the data saved in the database.
     * @param {PolicyCreateManyAndReturnArgs} args - Arguments to create many Policies.
     * @example
     * // Create many Policies
     * const policy = await prisma.policy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Policies and only return the `id`
     * const policyWithIdOnly = await prisma.policy.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, PolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Policy.
     * @param {PolicyDeleteArgs} args - Arguments to delete one Policy.
     * @example
     * // Delete one Policy
     * const Policy = await prisma.policy.delete({
     *   where: {
     *     // ... filter to delete one Policy
     *   }
     * })
     * 
     */
    delete<T extends PolicyDeleteArgs>(args: SelectSubset<T, PolicyDeleteArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Policy.
     * @param {PolicyUpdateArgs} args - Arguments to update one Policy.
     * @example
     * // Update one Policy
     * const policy = await prisma.policy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PolicyUpdateArgs>(args: SelectSubset<T, PolicyUpdateArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Policies.
     * @param {PolicyDeleteManyArgs} args - Arguments to filter Policies to delete.
     * @example
     * // Delete a few Policies
     * const { count } = await prisma.policy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PolicyDeleteManyArgs>(args?: SelectSubset<T, PolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Policies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Policies
     * const policy = await prisma.policy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PolicyUpdateManyArgs>(args: SelectSubset<T, PolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Policy.
     * @param {PolicyUpsertArgs} args - Arguments to update or create a Policy.
     * @example
     * // Update or create a Policy
     * const policy = await prisma.policy.upsert({
     *   create: {
     *     // ... data to create a Policy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Policy we want to update
     *   }
     * })
     */
    upsert<T extends PolicyUpsertArgs>(args: SelectSubset<T, PolicyUpsertArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Policies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyCountArgs} args - Arguments to filter Policies to count.
     * @example
     * // Count the number of Policies
     * const count = await prisma.policy.count({
     *   where: {
     *     // ... the filter for the Policies we want to count
     *   }
     * })
    **/
    count<T extends PolicyCountArgs>(
      args?: Subset<T, PolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Policy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PolicyAggregateArgs>(args: Subset<T, PolicyAggregateArgs>): Prisma.PrismaPromise<GetPolicyAggregateType<T>>

    /**
     * Group by Policy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PolicyGroupByArgs['orderBy'] }
        : { orderBy?: PolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Policy model
   */
  readonly fields: PolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Policy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RolePolicy<T extends Policy$RolePolicyArgs<ExtArgs> = {}>(args?: Subset<T, Policy$RolePolicyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePolicyPayload<ExtArgs>, T, "findMany"> | Null>
    PermissionPolicy<T extends Policy$PermissionPolicyArgs<ExtArgs> = {}>(args?: Subset<T, Policy$PermissionPolicyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPolicyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Policy model
   */ 
  interface PolicyFieldRefs {
    readonly id: FieldRef<"Policy", 'Int'>
    readonly type: FieldRef<"Policy", 'Int'>
    readonly effect: FieldRef<"Policy", 'String'>
    readonly action: FieldRef<"Policy", 'String'>
    readonly subject: FieldRef<"Policy", 'String'>
    readonly fields: FieldRef<"Policy", 'Json'>
    readonly conditions: FieldRef<"Policy", 'Json'>
    readonly args: FieldRef<"Policy", 'Json'>
    readonly encode: FieldRef<"Policy", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Policy findUnique
   */
  export type PolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy findUniqueOrThrow
   */
  export type PolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy findFirst
   */
  export type PolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Policies.
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Policies.
     */
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Policy findFirstOrThrow
   */
  export type PolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Policies.
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Policies.
     */
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Policy findMany
   */
  export type PolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter, which Policies to fetch.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Policies.
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Policy create
   */
  export type PolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a Policy.
     */
    data: XOR<PolicyCreateInput, PolicyUncheckedCreateInput>
  }

  /**
   * Policy createMany
   */
  export type PolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Policies.
     */
    data: PolicyCreateManyInput | PolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Policy createManyAndReturn
   */
  export type PolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Policies.
     */
    data: PolicyCreateManyInput | PolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Policy update
   */
  export type PolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a Policy.
     */
    data: XOR<PolicyUpdateInput, PolicyUncheckedUpdateInput>
    /**
     * Choose, which Policy to update.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy updateMany
   */
  export type PolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Policies.
     */
    data: XOR<PolicyUpdateManyMutationInput, PolicyUncheckedUpdateManyInput>
    /**
     * Filter which Policies to update
     */
    where?: PolicyWhereInput
  }

  /**
   * Policy upsert
   */
  export type PolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the Policy to update in case it exists.
     */
    where: PolicyWhereUniqueInput
    /**
     * In case the Policy found by the `where` argument doesn't exist, create a new Policy with this data.
     */
    create: XOR<PolicyCreateInput, PolicyUncheckedCreateInput>
    /**
     * In case the Policy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PolicyUpdateInput, PolicyUncheckedUpdateInput>
  }

  /**
   * Policy delete
   */
  export type PolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
    /**
     * Filter which Policy to delete.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy deleteMany
   */
  export type PolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Policies to delete
     */
    where?: PolicyWhereInput
  }

  /**
   * Policy.RolePolicy
   */
  export type Policy$RolePolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyInclude<ExtArgs> | null
    where?: RolePolicyWhereInput
    orderBy?: RolePolicyOrderByWithRelationInput | RolePolicyOrderByWithRelationInput[]
    cursor?: RolePolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePolicyScalarFieldEnum | RolePolicyScalarFieldEnum[]
  }

  /**
   * Policy.PermissionPolicy
   */
  export type Policy$PermissionPolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionPolicy
     */
    select?: PermissionPolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionPolicyInclude<ExtArgs> | null
    where?: PermissionPolicyWhereInput
    orderBy?: PermissionPolicyOrderByWithRelationInput | PermissionPolicyOrderByWithRelationInput[]
    cursor?: PermissionPolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionPolicyScalarFieldEnum | PermissionPolicyScalarFieldEnum[]
  }

  /**
   * Policy without action
   */
  export type PolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyInclude<ExtArgs> | null
  }


  /**
   * Model RolePolicy
   */

  export type AggregateRolePolicy = {
    _count: RolePolicyCountAggregateOutputType | null
    _avg: RolePolicyAvgAggregateOutputType | null
    _sum: RolePolicySumAggregateOutputType | null
    _min: RolePolicyMinAggregateOutputType | null
    _max: RolePolicyMaxAggregateOutputType | null
  }

  export type RolePolicyAvgAggregateOutputType = {
    roleId: number | null
    policyId: number | null
  }

  export type RolePolicySumAggregateOutputType = {
    roleId: number | null
    policyId: number | null
  }

  export type RolePolicyMinAggregateOutputType = {
    roleId: number | null
    policyId: number | null
  }

  export type RolePolicyMaxAggregateOutputType = {
    roleId: number | null
    policyId: number | null
  }

  export type RolePolicyCountAggregateOutputType = {
    roleId: number
    policyId: number
    _all: number
  }


  export type RolePolicyAvgAggregateInputType = {
    roleId?: true
    policyId?: true
  }

  export type RolePolicySumAggregateInputType = {
    roleId?: true
    policyId?: true
  }

  export type RolePolicyMinAggregateInputType = {
    roleId?: true
    policyId?: true
  }

  export type RolePolicyMaxAggregateInputType = {
    roleId?: true
    policyId?: true
  }

  export type RolePolicyCountAggregateInputType = {
    roleId?: true
    policyId?: true
    _all?: true
  }

  export type RolePolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePolicy to aggregate.
     */
    where?: RolePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePolicies to fetch.
     */
    orderBy?: RolePolicyOrderByWithRelationInput | RolePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePolicies
    **/
    _count?: true | RolePolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolePolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolePolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePolicyMaxAggregateInputType
  }

  export type GetRolePolicyAggregateType<T extends RolePolicyAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePolicy[P]>
      : GetScalarType<T[P], AggregateRolePolicy[P]>
  }




  export type RolePolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePolicyWhereInput
    orderBy?: RolePolicyOrderByWithAggregationInput | RolePolicyOrderByWithAggregationInput[]
    by: RolePolicyScalarFieldEnum[] | RolePolicyScalarFieldEnum
    having?: RolePolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePolicyCountAggregateInputType | true
    _avg?: RolePolicyAvgAggregateInputType
    _sum?: RolePolicySumAggregateInputType
    _min?: RolePolicyMinAggregateInputType
    _max?: RolePolicyMaxAggregateInputType
  }

  export type RolePolicyGroupByOutputType = {
    roleId: number
    policyId: number
    _count: RolePolicyCountAggregateOutputType | null
    _avg: RolePolicyAvgAggregateOutputType | null
    _sum: RolePolicySumAggregateOutputType | null
    _min: RolePolicyMinAggregateOutputType | null
    _max: RolePolicyMaxAggregateOutputType | null
  }

  type GetRolePolicyGroupByPayload<T extends RolePolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePolicyGroupByOutputType[P]>
            : GetScalarType<T[P], RolePolicyGroupByOutputType[P]>
        }
      >
    >


  export type RolePolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    policyId?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    policy?: boolean | PolicyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePolicy"]>

  export type RolePolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    policyId?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    policy?: boolean | PolicyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePolicy"]>

  export type RolePolicySelectScalar = {
    roleId?: boolean
    policyId?: boolean
  }

  export type RolePolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    policy?: boolean | PolicyDefaultArgs<ExtArgs>
  }
  export type RolePolicyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    policy?: boolean | PolicyDefaultArgs<ExtArgs>
  }

  export type $RolePolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePolicy"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      policy: Prisma.$PolicyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      roleId: number
      policyId: number
    }, ExtArgs["result"]["rolePolicy"]>
    composites: {}
  }

  type RolePolicyGetPayload<S extends boolean | null | undefined | RolePolicyDefaultArgs> = $Result.GetResult<Prisma.$RolePolicyPayload, S>

  type RolePolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RolePolicyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolePolicyCountAggregateInputType | true
    }

  export interface RolePolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePolicy'], meta: { name: 'RolePolicy' } }
    /**
     * Find zero or one RolePolicy that matches the filter.
     * @param {RolePolicyFindUniqueArgs} args - Arguments to find a RolePolicy
     * @example
     * // Get one RolePolicy
     * const rolePolicy = await prisma.rolePolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePolicyFindUniqueArgs>(args: SelectSubset<T, RolePolicyFindUniqueArgs<ExtArgs>>): Prisma__RolePolicyClient<$Result.GetResult<Prisma.$RolePolicyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RolePolicy that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RolePolicyFindUniqueOrThrowArgs} args - Arguments to find a RolePolicy
     * @example
     * // Get one RolePolicy
     * const rolePolicy = await prisma.rolePolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePolicyClient<$Result.GetResult<Prisma.$RolePolicyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RolePolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePolicyFindFirstArgs} args - Arguments to find a RolePolicy
     * @example
     * // Get one RolePolicy
     * const rolePolicy = await prisma.rolePolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePolicyFindFirstArgs>(args?: SelectSubset<T, RolePolicyFindFirstArgs<ExtArgs>>): Prisma__RolePolicyClient<$Result.GetResult<Prisma.$RolePolicyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RolePolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePolicyFindFirstOrThrowArgs} args - Arguments to find a RolePolicy
     * @example
     * // Get one RolePolicy
     * const rolePolicy = await prisma.rolePolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePolicyClient<$Result.GetResult<Prisma.$RolePolicyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RolePolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePolicies
     * const rolePolicies = await prisma.rolePolicy.findMany()
     * 
     * // Get first 10 RolePolicies
     * const rolePolicies = await prisma.rolePolicy.findMany({ take: 10 })
     * 
     * // Only select the `roleId`
     * const rolePolicyWithRoleIdOnly = await prisma.rolePolicy.findMany({ select: { roleId: true } })
     * 
     */
    findMany<T extends RolePolicyFindManyArgs>(args?: SelectSubset<T, RolePolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePolicyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RolePolicy.
     * @param {RolePolicyCreateArgs} args - Arguments to create a RolePolicy.
     * @example
     * // Create one RolePolicy
     * const RolePolicy = await prisma.rolePolicy.create({
     *   data: {
     *     // ... data to create a RolePolicy
     *   }
     * })
     * 
     */
    create<T extends RolePolicyCreateArgs>(args: SelectSubset<T, RolePolicyCreateArgs<ExtArgs>>): Prisma__RolePolicyClient<$Result.GetResult<Prisma.$RolePolicyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RolePolicies.
     * @param {RolePolicyCreateManyArgs} args - Arguments to create many RolePolicies.
     * @example
     * // Create many RolePolicies
     * const rolePolicy = await prisma.rolePolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePolicyCreateManyArgs>(args?: SelectSubset<T, RolePolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolePolicies and returns the data saved in the database.
     * @param {RolePolicyCreateManyAndReturnArgs} args - Arguments to create many RolePolicies.
     * @example
     * // Create many RolePolicies
     * const rolePolicy = await prisma.rolePolicy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolePolicies and only return the `roleId`
     * const rolePolicyWithRoleIdOnly = await prisma.rolePolicy.createManyAndReturn({ 
     *   select: { roleId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolePolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, RolePolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePolicyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RolePolicy.
     * @param {RolePolicyDeleteArgs} args - Arguments to delete one RolePolicy.
     * @example
     * // Delete one RolePolicy
     * const RolePolicy = await prisma.rolePolicy.delete({
     *   where: {
     *     // ... filter to delete one RolePolicy
     *   }
     * })
     * 
     */
    delete<T extends RolePolicyDeleteArgs>(args: SelectSubset<T, RolePolicyDeleteArgs<ExtArgs>>): Prisma__RolePolicyClient<$Result.GetResult<Prisma.$RolePolicyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RolePolicy.
     * @param {RolePolicyUpdateArgs} args - Arguments to update one RolePolicy.
     * @example
     * // Update one RolePolicy
     * const rolePolicy = await prisma.rolePolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePolicyUpdateArgs>(args: SelectSubset<T, RolePolicyUpdateArgs<ExtArgs>>): Prisma__RolePolicyClient<$Result.GetResult<Prisma.$RolePolicyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RolePolicies.
     * @param {RolePolicyDeleteManyArgs} args - Arguments to filter RolePolicies to delete.
     * @example
     * // Delete a few RolePolicies
     * const { count } = await prisma.rolePolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePolicyDeleteManyArgs>(args?: SelectSubset<T, RolePolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePolicies
     * const rolePolicy = await prisma.rolePolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePolicyUpdateManyArgs>(args: SelectSubset<T, RolePolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolePolicy.
     * @param {RolePolicyUpsertArgs} args - Arguments to update or create a RolePolicy.
     * @example
     * // Update or create a RolePolicy
     * const rolePolicy = await prisma.rolePolicy.upsert({
     *   create: {
     *     // ... data to create a RolePolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePolicy we want to update
     *   }
     * })
     */
    upsert<T extends RolePolicyUpsertArgs>(args: SelectSubset<T, RolePolicyUpsertArgs<ExtArgs>>): Prisma__RolePolicyClient<$Result.GetResult<Prisma.$RolePolicyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RolePolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePolicyCountArgs} args - Arguments to filter RolePolicies to count.
     * @example
     * // Count the number of RolePolicies
     * const count = await prisma.rolePolicy.count({
     *   where: {
     *     // ... the filter for the RolePolicies we want to count
     *   }
     * })
    **/
    count<T extends RolePolicyCountArgs>(
      args?: Subset<T, RolePolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePolicyAggregateArgs>(args: Subset<T, RolePolicyAggregateArgs>): Prisma.PrismaPromise<GetRolePolicyAggregateType<T>>

    /**
     * Group by RolePolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePolicyGroupByArgs['orderBy'] }
        : { orderBy?: RolePolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePolicy model
   */
  readonly fields: RolePolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    policy<T extends PolicyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PolicyDefaultArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePolicy model
   */ 
  interface RolePolicyFieldRefs {
    readonly roleId: FieldRef<"RolePolicy", 'Int'>
    readonly policyId: FieldRef<"RolePolicy", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RolePolicy findUnique
   */
  export type RolePolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyInclude<ExtArgs> | null
    /**
     * Filter, which RolePolicy to fetch.
     */
    where: RolePolicyWhereUniqueInput
  }

  /**
   * RolePolicy findUniqueOrThrow
   */
  export type RolePolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyInclude<ExtArgs> | null
    /**
     * Filter, which RolePolicy to fetch.
     */
    where: RolePolicyWhereUniqueInput
  }

  /**
   * RolePolicy findFirst
   */
  export type RolePolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyInclude<ExtArgs> | null
    /**
     * Filter, which RolePolicy to fetch.
     */
    where?: RolePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePolicies to fetch.
     */
    orderBy?: RolePolicyOrderByWithRelationInput | RolePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePolicies.
     */
    cursor?: RolePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePolicies.
     */
    distinct?: RolePolicyScalarFieldEnum | RolePolicyScalarFieldEnum[]
  }

  /**
   * RolePolicy findFirstOrThrow
   */
  export type RolePolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyInclude<ExtArgs> | null
    /**
     * Filter, which RolePolicy to fetch.
     */
    where?: RolePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePolicies to fetch.
     */
    orderBy?: RolePolicyOrderByWithRelationInput | RolePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePolicies.
     */
    cursor?: RolePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePolicies.
     */
    distinct?: RolePolicyScalarFieldEnum | RolePolicyScalarFieldEnum[]
  }

  /**
   * RolePolicy findMany
   */
  export type RolePolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyInclude<ExtArgs> | null
    /**
     * Filter, which RolePolicies to fetch.
     */
    where?: RolePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePolicies to fetch.
     */
    orderBy?: RolePolicyOrderByWithRelationInput | RolePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePolicies.
     */
    cursor?: RolePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePolicies.
     */
    skip?: number
    distinct?: RolePolicyScalarFieldEnum | RolePolicyScalarFieldEnum[]
  }

  /**
   * RolePolicy create
   */
  export type RolePolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePolicy.
     */
    data: XOR<RolePolicyCreateInput, RolePolicyUncheckedCreateInput>
  }

  /**
   * RolePolicy createMany
   */
  export type RolePolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePolicies.
     */
    data: RolePolicyCreateManyInput | RolePolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePolicy createManyAndReturn
   */
  export type RolePolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RolePolicies.
     */
    data: RolePolicyCreateManyInput | RolePolicyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePolicy update
   */
  export type RolePolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePolicy.
     */
    data: XOR<RolePolicyUpdateInput, RolePolicyUncheckedUpdateInput>
    /**
     * Choose, which RolePolicy to update.
     */
    where: RolePolicyWhereUniqueInput
  }

  /**
   * RolePolicy updateMany
   */
  export type RolePolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePolicies.
     */
    data: XOR<RolePolicyUpdateManyMutationInput, RolePolicyUncheckedUpdateManyInput>
    /**
     * Filter which RolePolicies to update
     */
    where?: RolePolicyWhereInput
  }

  /**
   * RolePolicy upsert
   */
  export type RolePolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePolicy to update in case it exists.
     */
    where: RolePolicyWhereUniqueInput
    /**
     * In case the RolePolicy found by the `where` argument doesn't exist, create a new RolePolicy with this data.
     */
    create: XOR<RolePolicyCreateInput, RolePolicyUncheckedCreateInput>
    /**
     * In case the RolePolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePolicyUpdateInput, RolePolicyUncheckedUpdateInput>
  }

  /**
   * RolePolicy delete
   */
  export type RolePolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyInclude<ExtArgs> | null
    /**
     * Filter which RolePolicy to delete.
     */
    where: RolePolicyWhereUniqueInput
  }

  /**
   * RolePolicy deleteMany
   */
  export type RolePolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePolicies to delete
     */
    where?: RolePolicyWhereInput
  }

  /**
   * RolePolicy without action
   */
  export type RolePolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePolicy
     */
    select?: RolePolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePolicyInclude<ExtArgs> | null
  }


  /**
   * Model PermissionPolicy
   */

  export type AggregatePermissionPolicy = {
    _count: PermissionPolicyCountAggregateOutputType | null
    _avg: PermissionPolicyAvgAggregateOutputType | null
    _sum: PermissionPolicySumAggregateOutputType | null
    _min: PermissionPolicyMinAggregateOutputType | null
    _max: PermissionPolicyMaxAggregateOutputType | null
  }

  export type PermissionPolicyAvgAggregateOutputType = {
    permissionId: number | null
    policyId: number | null
  }

  export type PermissionPolicySumAggregateOutputType = {
    permissionId: number | null
    policyId: number | null
  }

  export type PermissionPolicyMinAggregateOutputType = {
    permissionId: number | null
    policyId: number | null
  }

  export type PermissionPolicyMaxAggregateOutputType = {
    permissionId: number | null
    policyId: number | null
  }

  export type PermissionPolicyCountAggregateOutputType = {
    permissionId: number
    policyId: number
    _all: number
  }


  export type PermissionPolicyAvgAggregateInputType = {
    permissionId?: true
    policyId?: true
  }

  export type PermissionPolicySumAggregateInputType = {
    permissionId?: true
    policyId?: true
  }

  export type PermissionPolicyMinAggregateInputType = {
    permissionId?: true
    policyId?: true
  }

  export type PermissionPolicyMaxAggregateInputType = {
    permissionId?: true
    policyId?: true
  }

  export type PermissionPolicyCountAggregateInputType = {
    permissionId?: true
    policyId?: true
    _all?: true
  }

  export type PermissionPolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PermissionPolicy to aggregate.
     */
    where?: PermissionPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PermissionPolicies to fetch.
     */
    orderBy?: PermissionPolicyOrderByWithRelationInput | PermissionPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PermissionPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PermissionPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PermissionPolicies
    **/
    _count?: true | PermissionPolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionPolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionPolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionPolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionPolicyMaxAggregateInputType
  }

  export type GetPermissionPolicyAggregateType<T extends PermissionPolicyAggregateArgs> = {
        [P in keyof T & keyof AggregatePermissionPolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermissionPolicy[P]>
      : GetScalarType<T[P], AggregatePermissionPolicy[P]>
  }




  export type PermissionPolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionPolicyWhereInput
    orderBy?: PermissionPolicyOrderByWithAggregationInput | PermissionPolicyOrderByWithAggregationInput[]
    by: PermissionPolicyScalarFieldEnum[] | PermissionPolicyScalarFieldEnum
    having?: PermissionPolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionPolicyCountAggregateInputType | true
    _avg?: PermissionPolicyAvgAggregateInputType
    _sum?: PermissionPolicySumAggregateInputType
    _min?: PermissionPolicyMinAggregateInputType
    _max?: PermissionPolicyMaxAggregateInputType
  }

  export type PermissionPolicyGroupByOutputType = {
    permissionId: number
    policyId: number
    _count: PermissionPolicyCountAggregateOutputType | null
    _avg: PermissionPolicyAvgAggregateOutputType | null
    _sum: PermissionPolicySumAggregateOutputType | null
    _min: PermissionPolicyMinAggregateOutputType | null
    _max: PermissionPolicyMaxAggregateOutputType | null
  }

  type GetPermissionPolicyGroupByPayload<T extends PermissionPolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionPolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionPolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionPolicyGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionPolicyGroupByOutputType[P]>
        }
      >
    >


  export type PermissionPolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    permissionId?: boolean
    policyId?: boolean
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
    policy?: boolean | PolicyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissionPolicy"]>

  export type PermissionPolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    permissionId?: boolean
    policyId?: boolean
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
    policy?: boolean | PolicyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissionPolicy"]>

  export type PermissionPolicySelectScalar = {
    permissionId?: boolean
    policyId?: boolean
  }

  export type PermissionPolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
    policy?: boolean | PolicyDefaultArgs<ExtArgs>
  }
  export type PermissionPolicyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
    policy?: boolean | PolicyDefaultArgs<ExtArgs>
  }

  export type $PermissionPolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PermissionPolicy"
    objects: {
      permission: Prisma.$PermissionPayload<ExtArgs>
      policy: Prisma.$PolicyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      permissionId: number
      policyId: number
    }, ExtArgs["result"]["permissionPolicy"]>
    composites: {}
  }

  type PermissionPolicyGetPayload<S extends boolean | null | undefined | PermissionPolicyDefaultArgs> = $Result.GetResult<Prisma.$PermissionPolicyPayload, S>

  type PermissionPolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PermissionPolicyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PermissionPolicyCountAggregateInputType | true
    }

  export interface PermissionPolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PermissionPolicy'], meta: { name: 'PermissionPolicy' } }
    /**
     * Find zero or one PermissionPolicy that matches the filter.
     * @param {PermissionPolicyFindUniqueArgs} args - Arguments to find a PermissionPolicy
     * @example
     * // Get one PermissionPolicy
     * const permissionPolicy = await prisma.permissionPolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionPolicyFindUniqueArgs>(args: SelectSubset<T, PermissionPolicyFindUniqueArgs<ExtArgs>>): Prisma__PermissionPolicyClient<$Result.GetResult<Prisma.$PermissionPolicyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PermissionPolicy that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PermissionPolicyFindUniqueOrThrowArgs} args - Arguments to find a PermissionPolicy
     * @example
     * // Get one PermissionPolicy
     * const permissionPolicy = await prisma.permissionPolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionPolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionPolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionPolicyClient<$Result.GetResult<Prisma.$PermissionPolicyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PermissionPolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionPolicyFindFirstArgs} args - Arguments to find a PermissionPolicy
     * @example
     * // Get one PermissionPolicy
     * const permissionPolicy = await prisma.permissionPolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionPolicyFindFirstArgs>(args?: SelectSubset<T, PermissionPolicyFindFirstArgs<ExtArgs>>): Prisma__PermissionPolicyClient<$Result.GetResult<Prisma.$PermissionPolicyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PermissionPolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionPolicyFindFirstOrThrowArgs} args - Arguments to find a PermissionPolicy
     * @example
     * // Get one PermissionPolicy
     * const permissionPolicy = await prisma.permissionPolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionPolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionPolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionPolicyClient<$Result.GetResult<Prisma.$PermissionPolicyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PermissionPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionPolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PermissionPolicies
     * const permissionPolicies = await prisma.permissionPolicy.findMany()
     * 
     * // Get first 10 PermissionPolicies
     * const permissionPolicies = await prisma.permissionPolicy.findMany({ take: 10 })
     * 
     * // Only select the `permissionId`
     * const permissionPolicyWithPermissionIdOnly = await prisma.permissionPolicy.findMany({ select: { permissionId: true } })
     * 
     */
    findMany<T extends PermissionPolicyFindManyArgs>(args?: SelectSubset<T, PermissionPolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPolicyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PermissionPolicy.
     * @param {PermissionPolicyCreateArgs} args - Arguments to create a PermissionPolicy.
     * @example
     * // Create one PermissionPolicy
     * const PermissionPolicy = await prisma.permissionPolicy.create({
     *   data: {
     *     // ... data to create a PermissionPolicy
     *   }
     * })
     * 
     */
    create<T extends PermissionPolicyCreateArgs>(args: SelectSubset<T, PermissionPolicyCreateArgs<ExtArgs>>): Prisma__PermissionPolicyClient<$Result.GetResult<Prisma.$PermissionPolicyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PermissionPolicies.
     * @param {PermissionPolicyCreateManyArgs} args - Arguments to create many PermissionPolicies.
     * @example
     * // Create many PermissionPolicies
     * const permissionPolicy = await prisma.permissionPolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionPolicyCreateManyArgs>(args?: SelectSubset<T, PermissionPolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PermissionPolicies and returns the data saved in the database.
     * @param {PermissionPolicyCreateManyAndReturnArgs} args - Arguments to create many PermissionPolicies.
     * @example
     * // Create many PermissionPolicies
     * const permissionPolicy = await prisma.permissionPolicy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PermissionPolicies and only return the `permissionId`
     * const permissionPolicyWithPermissionIdOnly = await prisma.permissionPolicy.createManyAndReturn({ 
     *   select: { permissionId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionPolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionPolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPolicyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PermissionPolicy.
     * @param {PermissionPolicyDeleteArgs} args - Arguments to delete one PermissionPolicy.
     * @example
     * // Delete one PermissionPolicy
     * const PermissionPolicy = await prisma.permissionPolicy.delete({
     *   where: {
     *     // ... filter to delete one PermissionPolicy
     *   }
     * })
     * 
     */
    delete<T extends PermissionPolicyDeleteArgs>(args: SelectSubset<T, PermissionPolicyDeleteArgs<ExtArgs>>): Prisma__PermissionPolicyClient<$Result.GetResult<Prisma.$PermissionPolicyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PermissionPolicy.
     * @param {PermissionPolicyUpdateArgs} args - Arguments to update one PermissionPolicy.
     * @example
     * // Update one PermissionPolicy
     * const permissionPolicy = await prisma.permissionPolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionPolicyUpdateArgs>(args: SelectSubset<T, PermissionPolicyUpdateArgs<ExtArgs>>): Prisma__PermissionPolicyClient<$Result.GetResult<Prisma.$PermissionPolicyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PermissionPolicies.
     * @param {PermissionPolicyDeleteManyArgs} args - Arguments to filter PermissionPolicies to delete.
     * @example
     * // Delete a few PermissionPolicies
     * const { count } = await prisma.permissionPolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionPolicyDeleteManyArgs>(args?: SelectSubset<T, PermissionPolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PermissionPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionPolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PermissionPolicies
     * const permissionPolicy = await prisma.permissionPolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionPolicyUpdateManyArgs>(args: SelectSubset<T, PermissionPolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PermissionPolicy.
     * @param {PermissionPolicyUpsertArgs} args - Arguments to update or create a PermissionPolicy.
     * @example
     * // Update or create a PermissionPolicy
     * const permissionPolicy = await prisma.permissionPolicy.upsert({
     *   create: {
     *     // ... data to create a PermissionPolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PermissionPolicy we want to update
     *   }
     * })
     */
    upsert<T extends PermissionPolicyUpsertArgs>(args: SelectSubset<T, PermissionPolicyUpsertArgs<ExtArgs>>): Prisma__PermissionPolicyClient<$Result.GetResult<Prisma.$PermissionPolicyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PermissionPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionPolicyCountArgs} args - Arguments to filter PermissionPolicies to count.
     * @example
     * // Count the number of PermissionPolicies
     * const count = await prisma.permissionPolicy.count({
     *   where: {
     *     // ... the filter for the PermissionPolicies we want to count
     *   }
     * })
    **/
    count<T extends PermissionPolicyCountArgs>(
      args?: Subset<T, PermissionPolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionPolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PermissionPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionPolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionPolicyAggregateArgs>(args: Subset<T, PermissionPolicyAggregateArgs>): Prisma.PrismaPromise<GetPermissionPolicyAggregateType<T>>

    /**
     * Group by PermissionPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionPolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionPolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionPolicyGroupByArgs['orderBy'] }
        : { orderBy?: PermissionPolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionPolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PermissionPolicy model
   */
  readonly fields: PermissionPolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PermissionPolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionPolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    policy<T extends PolicyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PolicyDefaultArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PermissionPolicy model
   */ 
  interface PermissionPolicyFieldRefs {
    readonly permissionId: FieldRef<"PermissionPolicy", 'Int'>
    readonly policyId: FieldRef<"PermissionPolicy", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PermissionPolicy findUnique
   */
  export type PermissionPolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionPolicy
     */
    select?: PermissionPolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionPolicyInclude<ExtArgs> | null
    /**
     * Filter, which PermissionPolicy to fetch.
     */
    where: PermissionPolicyWhereUniqueInput
  }

  /**
   * PermissionPolicy findUniqueOrThrow
   */
  export type PermissionPolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionPolicy
     */
    select?: PermissionPolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionPolicyInclude<ExtArgs> | null
    /**
     * Filter, which PermissionPolicy to fetch.
     */
    where: PermissionPolicyWhereUniqueInput
  }

  /**
   * PermissionPolicy findFirst
   */
  export type PermissionPolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionPolicy
     */
    select?: PermissionPolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionPolicyInclude<ExtArgs> | null
    /**
     * Filter, which PermissionPolicy to fetch.
     */
    where?: PermissionPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PermissionPolicies to fetch.
     */
    orderBy?: PermissionPolicyOrderByWithRelationInput | PermissionPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PermissionPolicies.
     */
    cursor?: PermissionPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PermissionPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PermissionPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PermissionPolicies.
     */
    distinct?: PermissionPolicyScalarFieldEnum | PermissionPolicyScalarFieldEnum[]
  }

  /**
   * PermissionPolicy findFirstOrThrow
   */
  export type PermissionPolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionPolicy
     */
    select?: PermissionPolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionPolicyInclude<ExtArgs> | null
    /**
     * Filter, which PermissionPolicy to fetch.
     */
    where?: PermissionPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PermissionPolicies to fetch.
     */
    orderBy?: PermissionPolicyOrderByWithRelationInput | PermissionPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PermissionPolicies.
     */
    cursor?: PermissionPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PermissionPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PermissionPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PermissionPolicies.
     */
    distinct?: PermissionPolicyScalarFieldEnum | PermissionPolicyScalarFieldEnum[]
  }

  /**
   * PermissionPolicy findMany
   */
  export type PermissionPolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionPolicy
     */
    select?: PermissionPolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionPolicyInclude<ExtArgs> | null
    /**
     * Filter, which PermissionPolicies to fetch.
     */
    where?: PermissionPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PermissionPolicies to fetch.
     */
    orderBy?: PermissionPolicyOrderByWithRelationInput | PermissionPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PermissionPolicies.
     */
    cursor?: PermissionPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PermissionPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PermissionPolicies.
     */
    skip?: number
    distinct?: PermissionPolicyScalarFieldEnum | PermissionPolicyScalarFieldEnum[]
  }

  /**
   * PermissionPolicy create
   */
  export type PermissionPolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionPolicy
     */
    select?: PermissionPolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionPolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a PermissionPolicy.
     */
    data: XOR<PermissionPolicyCreateInput, PermissionPolicyUncheckedCreateInput>
  }

  /**
   * PermissionPolicy createMany
   */
  export type PermissionPolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PermissionPolicies.
     */
    data: PermissionPolicyCreateManyInput | PermissionPolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PermissionPolicy createManyAndReturn
   */
  export type PermissionPolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionPolicy
     */
    select?: PermissionPolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PermissionPolicies.
     */
    data: PermissionPolicyCreateManyInput | PermissionPolicyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionPolicyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PermissionPolicy update
   */
  export type PermissionPolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionPolicy
     */
    select?: PermissionPolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionPolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a PermissionPolicy.
     */
    data: XOR<PermissionPolicyUpdateInput, PermissionPolicyUncheckedUpdateInput>
    /**
     * Choose, which PermissionPolicy to update.
     */
    where: PermissionPolicyWhereUniqueInput
  }

  /**
   * PermissionPolicy updateMany
   */
  export type PermissionPolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PermissionPolicies.
     */
    data: XOR<PermissionPolicyUpdateManyMutationInput, PermissionPolicyUncheckedUpdateManyInput>
    /**
     * Filter which PermissionPolicies to update
     */
    where?: PermissionPolicyWhereInput
  }

  /**
   * PermissionPolicy upsert
   */
  export type PermissionPolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionPolicy
     */
    select?: PermissionPolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionPolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the PermissionPolicy to update in case it exists.
     */
    where: PermissionPolicyWhereUniqueInput
    /**
     * In case the PermissionPolicy found by the `where` argument doesn't exist, create a new PermissionPolicy with this data.
     */
    create: XOR<PermissionPolicyCreateInput, PermissionPolicyUncheckedCreateInput>
    /**
     * In case the PermissionPolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionPolicyUpdateInput, PermissionPolicyUncheckedUpdateInput>
  }

  /**
   * PermissionPolicy delete
   */
  export type PermissionPolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionPolicy
     */
    select?: PermissionPolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionPolicyInclude<ExtArgs> | null
    /**
     * Filter which PermissionPolicy to delete.
     */
    where: PermissionPolicyWhereUniqueInput
  }

  /**
   * PermissionPolicy deleteMany
   */
  export type PermissionPolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PermissionPolicies to delete
     */
    where?: PermissionPolicyWhereInput
  }

  /**
   * PermissionPolicy without action
   */
  export type PermissionPolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionPolicy
     */
    select?: PermissionPolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionPolicyInclude<ExtArgs> | null
  }


  /**
   * Model Menu
   */

  export type AggregateMenu = {
    _count: MenuCountAggregateOutputType | null
    _avg: MenuAvgAggregateOutputType | null
    _sum: MenuSumAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  export type MenuAvgAggregateOutputType = {
    id: number | null
    status: number | null
    parentId: number | null
    metaId: number | null
  }

  export type MenuSumAggregateOutputType = {
    id: number | null
    status: number | null
    parentId: number | null
    metaId: number | null
  }

  export type MenuMinAggregateOutputType = {
    id: number | null
    name: string | null
    path: string | null
    label: string | null
    component: string | null
    redirect: string | null
    fullPath: string | null
    alias: string | null
    status: number | null
    parentId: number | null
    metaId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuMaxAggregateOutputType = {
    id: number | null
    name: string | null
    path: string | null
    label: string | null
    component: string | null
    redirect: string | null
    fullPath: string | null
    alias: string | null
    status: number | null
    parentId: number | null
    metaId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuCountAggregateOutputType = {
    id: number
    name: number
    path: number
    label: number
    component: number
    redirect: number
    fullPath: number
    alias: number
    status: number
    parentId: number
    metaId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MenuAvgAggregateInputType = {
    id?: true
    status?: true
    parentId?: true
    metaId?: true
  }

  export type MenuSumAggregateInputType = {
    id?: true
    status?: true
    parentId?: true
    metaId?: true
  }

  export type MenuMinAggregateInputType = {
    id?: true
    name?: true
    path?: true
    label?: true
    component?: true
    redirect?: true
    fullPath?: true
    alias?: true
    status?: true
    parentId?: true
    metaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuMaxAggregateInputType = {
    id?: true
    name?: true
    path?: true
    label?: true
    component?: true
    redirect?: true
    fullPath?: true
    alias?: true
    status?: true
    parentId?: true
    metaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuCountAggregateInputType = {
    id?: true
    name?: true
    path?: true
    label?: true
    component?: true
    redirect?: true
    fullPath?: true
    alias?: true
    status?: true
    parentId?: true
    metaId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MenuAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Menu to aggregate.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Menus
    **/
    _count?: true | MenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuMaxAggregateInputType
  }

  export type GetMenuAggregateType<T extends MenuAggregateArgs> = {
        [P in keyof T & keyof AggregateMenu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenu[P]>
      : GetScalarType<T[P], AggregateMenu[P]>
  }




  export type MenuGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuWhereInput
    orderBy?: MenuOrderByWithAggregationInput | MenuOrderByWithAggregationInput[]
    by: MenuScalarFieldEnum[] | MenuScalarFieldEnum
    having?: MenuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuCountAggregateInputType | true
    _avg?: MenuAvgAggregateInputType
    _sum?: MenuSumAggregateInputType
    _min?: MenuMinAggregateInputType
    _max?: MenuMaxAggregateInputType
  }

  export type MenuGroupByOutputType = {
    id: number
    name: string
    path: string
    label: string
    component: string | null
    redirect: string | null
    fullPath: string | null
    alias: string | null
    status: number
    parentId: number | null
    metaId: number | null
    createdAt: Date
    updatedAt: Date
    _count: MenuCountAggregateOutputType | null
    _avg: MenuAvgAggregateOutputType | null
    _sum: MenuSumAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  type GetMenuGroupByPayload<T extends MenuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuGroupByOutputType[P]>
            : GetScalarType<T[P], MenuGroupByOutputType[P]>
        }
      >
    >


  export type MenuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    path?: boolean
    label?: boolean
    component?: boolean
    redirect?: boolean
    fullPath?: boolean
    alias?: boolean
    status?: boolean
    parentId?: boolean
    metaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meta?: boolean | Menu$metaArgs<ExtArgs>
    parent?: boolean | Menu$parentArgs<ExtArgs>
    children?: boolean | Menu$childrenArgs<ExtArgs>
    roleMenus?: boolean | Menu$roleMenusArgs<ExtArgs>
    _count?: boolean | MenuCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menu"]>

  export type MenuSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    path?: boolean
    label?: boolean
    component?: boolean
    redirect?: boolean
    fullPath?: boolean
    alias?: boolean
    status?: boolean
    parentId?: boolean
    metaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Menu$parentArgs<ExtArgs>
  }, ExtArgs["result"]["menu"]>

  export type MenuSelectScalar = {
    id?: boolean
    name?: boolean
    path?: boolean
    label?: boolean
    component?: boolean
    redirect?: boolean
    fullPath?: boolean
    alias?: boolean
    status?: boolean
    parentId?: boolean
    metaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MenuInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta?: boolean | Menu$metaArgs<ExtArgs>
    parent?: boolean | Menu$parentArgs<ExtArgs>
    children?: boolean | Menu$childrenArgs<ExtArgs>
    roleMenus?: boolean | Menu$roleMenusArgs<ExtArgs>
    _count?: boolean | MenuCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MenuIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Menu$parentArgs<ExtArgs>
  }

  export type $MenuPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Menu"
    objects: {
      meta: Prisma.$MenuMetaPayload<ExtArgs> | null
      parent: Prisma.$MenuPayload<ExtArgs> | null
      children: Prisma.$MenuPayload<ExtArgs>[]
      roleMenus: Prisma.$RoleMenuPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      path: string
      label: string
      component: string | null
      redirect: string | null
      fullPath: string | null
      alias: string | null
      status: number
      parentId: number | null
      metaId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["menu"]>
    composites: {}
  }

  type MenuGetPayload<S extends boolean | null | undefined | MenuDefaultArgs> = $Result.GetResult<Prisma.$MenuPayload, S>

  type MenuCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MenuFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MenuCountAggregateInputType | true
    }

  export interface MenuDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Menu'], meta: { name: 'Menu' } }
    /**
     * Find zero or one Menu that matches the filter.
     * @param {MenuFindUniqueArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenuFindUniqueArgs>(args: SelectSubset<T, MenuFindUniqueArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Menu that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MenuFindUniqueOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenuFindUniqueOrThrowArgs>(args: SelectSubset<T, MenuFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Menu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindFirstArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenuFindFirstArgs>(args?: SelectSubset<T, MenuFindFirstArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Menu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindFirstOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenuFindFirstOrThrowArgs>(args?: SelectSubset<T, MenuFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Menus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Menus
     * const menus = await prisma.menu.findMany()
     * 
     * // Get first 10 Menus
     * const menus = await prisma.menu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menuWithIdOnly = await prisma.menu.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MenuFindManyArgs>(args?: SelectSubset<T, MenuFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Menu.
     * @param {MenuCreateArgs} args - Arguments to create a Menu.
     * @example
     * // Create one Menu
     * const Menu = await prisma.menu.create({
     *   data: {
     *     // ... data to create a Menu
     *   }
     * })
     * 
     */
    create<T extends MenuCreateArgs>(args: SelectSubset<T, MenuCreateArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Menus.
     * @param {MenuCreateManyArgs} args - Arguments to create many Menus.
     * @example
     * // Create many Menus
     * const menu = await prisma.menu.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenuCreateManyArgs>(args?: SelectSubset<T, MenuCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Menus and returns the data saved in the database.
     * @param {MenuCreateManyAndReturnArgs} args - Arguments to create many Menus.
     * @example
     * // Create many Menus
     * const menu = await prisma.menu.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Menus and only return the `id`
     * const menuWithIdOnly = await prisma.menu.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenuCreateManyAndReturnArgs>(args?: SelectSubset<T, MenuCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Menu.
     * @param {MenuDeleteArgs} args - Arguments to delete one Menu.
     * @example
     * // Delete one Menu
     * const Menu = await prisma.menu.delete({
     *   where: {
     *     // ... filter to delete one Menu
     *   }
     * })
     * 
     */
    delete<T extends MenuDeleteArgs>(args: SelectSubset<T, MenuDeleteArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Menu.
     * @param {MenuUpdateArgs} args - Arguments to update one Menu.
     * @example
     * // Update one Menu
     * const menu = await prisma.menu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenuUpdateArgs>(args: SelectSubset<T, MenuUpdateArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Menus.
     * @param {MenuDeleteManyArgs} args - Arguments to filter Menus to delete.
     * @example
     * // Delete a few Menus
     * const { count } = await prisma.menu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenuDeleteManyArgs>(args?: SelectSubset<T, MenuDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Menus
     * const menu = await prisma.menu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenuUpdateManyArgs>(args: SelectSubset<T, MenuUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Menu.
     * @param {MenuUpsertArgs} args - Arguments to update or create a Menu.
     * @example
     * // Update or create a Menu
     * const menu = await prisma.menu.upsert({
     *   create: {
     *     // ... data to create a Menu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Menu we want to update
     *   }
     * })
     */
    upsert<T extends MenuUpsertArgs>(args: SelectSubset<T, MenuUpsertArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuCountArgs} args - Arguments to filter Menus to count.
     * @example
     * // Count the number of Menus
     * const count = await prisma.menu.count({
     *   where: {
     *     // ... the filter for the Menus we want to count
     *   }
     * })
    **/
    count<T extends MenuCountArgs>(
      args?: Subset<T, MenuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuAggregateArgs>(args: Subset<T, MenuAggregateArgs>): Prisma.PrismaPromise<GetMenuAggregateType<T>>

    /**
     * Group by Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuGroupByArgs['orderBy'] }
        : { orderBy?: MenuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Menu model
   */
  readonly fields: MenuFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Menu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenuClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    meta<T extends Menu$metaArgs<ExtArgs> = {}>(args?: Subset<T, Menu$metaArgs<ExtArgs>>): Prisma__MenuMetaClient<$Result.GetResult<Prisma.$MenuMetaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    parent<T extends Menu$parentArgs<ExtArgs> = {}>(args?: Subset<T, Menu$parentArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    children<T extends Menu$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Menu$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findMany"> | Null>
    roleMenus<T extends Menu$roleMenusArgs<ExtArgs> = {}>(args?: Subset<T, Menu$roleMenusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleMenuPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Menu model
   */ 
  interface MenuFieldRefs {
    readonly id: FieldRef<"Menu", 'Int'>
    readonly name: FieldRef<"Menu", 'String'>
    readonly path: FieldRef<"Menu", 'String'>
    readonly label: FieldRef<"Menu", 'String'>
    readonly component: FieldRef<"Menu", 'String'>
    readonly redirect: FieldRef<"Menu", 'String'>
    readonly fullPath: FieldRef<"Menu", 'String'>
    readonly alias: FieldRef<"Menu", 'String'>
    readonly status: FieldRef<"Menu", 'Int'>
    readonly parentId: FieldRef<"Menu", 'Int'>
    readonly metaId: FieldRef<"Menu", 'Int'>
    readonly createdAt: FieldRef<"Menu", 'DateTime'>
    readonly updatedAt: FieldRef<"Menu", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Menu findUnique
   */
  export type MenuFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu findUniqueOrThrow
   */
  export type MenuFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu findFirst
   */
  export type MenuFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Menus.
     */
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * Menu findFirstOrThrow
   */
  export type MenuFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Menus.
     */
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * Menu findMany
   */
  export type MenuFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menus to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * Menu create
   */
  export type MenuCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * The data needed to create a Menu.
     */
    data: XOR<MenuCreateInput, MenuUncheckedCreateInput>
  }

  /**
   * Menu createMany
   */
  export type MenuCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Menus.
     */
    data: MenuCreateManyInput | MenuCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Menu createManyAndReturn
   */
  export type MenuCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Menus.
     */
    data: MenuCreateManyInput | MenuCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Menu update
   */
  export type MenuUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * The data needed to update a Menu.
     */
    data: XOR<MenuUpdateInput, MenuUncheckedUpdateInput>
    /**
     * Choose, which Menu to update.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu updateMany
   */
  export type MenuUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Menus.
     */
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyInput>
    /**
     * Filter which Menus to update
     */
    where?: MenuWhereInput
  }

  /**
   * Menu upsert
   */
  export type MenuUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * The filter to search for the Menu to update in case it exists.
     */
    where: MenuWhereUniqueInput
    /**
     * In case the Menu found by the `where` argument doesn't exist, create a new Menu with this data.
     */
    create: XOR<MenuCreateInput, MenuUncheckedCreateInput>
    /**
     * In case the Menu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenuUpdateInput, MenuUncheckedUpdateInput>
  }

  /**
   * Menu delete
   */
  export type MenuDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter which Menu to delete.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu deleteMany
   */
  export type MenuDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Menus to delete
     */
    where?: MenuWhereInput
  }

  /**
   * Menu.meta
   */
  export type Menu$metaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuMeta
     */
    select?: MenuMetaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuMetaInclude<ExtArgs> | null
    where?: MenuMetaWhereInput
  }

  /**
   * Menu.parent
   */
  export type Menu$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    where?: MenuWhereInput
  }

  /**
   * Menu.children
   */
  export type Menu$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    where?: MenuWhereInput
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    cursor?: MenuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * Menu.roleMenus
   */
  export type Menu$roleMenusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleMenu
     */
    select?: RoleMenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleMenuInclude<ExtArgs> | null
    where?: RoleMenuWhereInput
    orderBy?: RoleMenuOrderByWithRelationInput | RoleMenuOrderByWithRelationInput[]
    cursor?: RoleMenuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleMenuScalarFieldEnum | RoleMenuScalarFieldEnum[]
  }

  /**
   * Menu without action
   */
  export type MenuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
  }


  /**
   * Model MenuMeta
   */

  export type AggregateMenuMeta = {
    _count: MenuMetaCountAggregateOutputType | null
    _avg: MenuMetaAvgAggregateOutputType | null
    _sum: MenuMetaSumAggregateOutputType | null
    _min: MenuMetaMinAggregateOutputType | null
    _max: MenuMetaMaxAggregateOutputType | null
  }

  export type MenuMetaAvgAggregateOutputType = {
    id: number | null
    order: number | null
    status: number | null
    menuId: number | null
  }

  export type MenuMetaSumAggregateOutputType = {
    id: number | null
    order: number | null
    status: number | null
    menuId: number | null
  }

  export type MenuMetaMinAggregateOutputType = {
    id: number | null
    title: string | null
    layout: string | null
    order: number | null
    hidden: boolean | null
    disabled: boolean | null
    icon: string | null
    status: number | null
    menuId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuMetaMaxAggregateOutputType = {
    id: number | null
    title: string | null
    layout: string | null
    order: number | null
    hidden: boolean | null
    disabled: boolean | null
    icon: string | null
    status: number | null
    menuId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuMetaCountAggregateOutputType = {
    id: number
    title: number
    layout: number
    order: number
    hidden: number
    disabled: number
    icon: number
    status: number
    menuId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MenuMetaAvgAggregateInputType = {
    id?: true
    order?: true
    status?: true
    menuId?: true
  }

  export type MenuMetaSumAggregateInputType = {
    id?: true
    order?: true
    status?: true
    menuId?: true
  }

  export type MenuMetaMinAggregateInputType = {
    id?: true
    title?: true
    layout?: true
    order?: true
    hidden?: true
    disabled?: true
    icon?: true
    status?: true
    menuId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuMetaMaxAggregateInputType = {
    id?: true
    title?: true
    layout?: true
    order?: true
    hidden?: true
    disabled?: true
    icon?: true
    status?: true
    menuId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuMetaCountAggregateInputType = {
    id?: true
    title?: true
    layout?: true
    order?: true
    hidden?: true
    disabled?: true
    icon?: true
    status?: true
    menuId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MenuMetaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenuMeta to aggregate.
     */
    where?: MenuMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuMetas to fetch.
     */
    orderBy?: MenuMetaOrderByWithRelationInput | MenuMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenuMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenuMetas
    **/
    _count?: true | MenuMetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenuMetaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenuMetaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuMetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuMetaMaxAggregateInputType
  }

  export type GetMenuMetaAggregateType<T extends MenuMetaAggregateArgs> = {
        [P in keyof T & keyof AggregateMenuMeta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenuMeta[P]>
      : GetScalarType<T[P], AggregateMenuMeta[P]>
  }




  export type MenuMetaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuMetaWhereInput
    orderBy?: MenuMetaOrderByWithAggregationInput | MenuMetaOrderByWithAggregationInput[]
    by: MenuMetaScalarFieldEnum[] | MenuMetaScalarFieldEnum
    having?: MenuMetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuMetaCountAggregateInputType | true
    _avg?: MenuMetaAvgAggregateInputType
    _sum?: MenuMetaSumAggregateInputType
    _min?: MenuMetaMinAggregateInputType
    _max?: MenuMetaMaxAggregateInputType
  }

  export type MenuMetaGroupByOutputType = {
    id: number
    title: string | null
    layout: string | null
    order: number | null
    hidden: boolean
    disabled: boolean
    icon: string | null
    status: number
    menuId: number
    createdAt: Date
    updatedAt: Date
    _count: MenuMetaCountAggregateOutputType | null
    _avg: MenuMetaAvgAggregateOutputType | null
    _sum: MenuMetaSumAggregateOutputType | null
    _min: MenuMetaMinAggregateOutputType | null
    _max: MenuMetaMaxAggregateOutputType | null
  }

  type GetMenuMetaGroupByPayload<T extends MenuMetaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenuMetaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuMetaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuMetaGroupByOutputType[P]>
            : GetScalarType<T[P], MenuMetaGroupByOutputType[P]>
        }
      >
    >


  export type MenuMetaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    layout?: boolean
    order?: boolean
    hidden?: boolean
    disabled?: boolean
    icon?: boolean
    status?: boolean
    menuId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    menu?: boolean | MenuDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuMeta"]>

  export type MenuMetaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    layout?: boolean
    order?: boolean
    hidden?: boolean
    disabled?: boolean
    icon?: boolean
    status?: boolean
    menuId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    menu?: boolean | MenuDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuMeta"]>

  export type MenuMetaSelectScalar = {
    id?: boolean
    title?: boolean
    layout?: boolean
    order?: boolean
    hidden?: boolean
    disabled?: boolean
    icon?: boolean
    status?: boolean
    menuId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MenuMetaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu?: boolean | MenuDefaultArgs<ExtArgs>
  }
  export type MenuMetaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu?: boolean | MenuDefaultArgs<ExtArgs>
  }

  export type $MenuMetaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MenuMeta"
    objects: {
      menu: Prisma.$MenuPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string | null
      layout: string | null
      order: number | null
      hidden: boolean
      disabled: boolean
      icon: string | null
      status: number
      menuId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["menuMeta"]>
    composites: {}
  }

  type MenuMetaGetPayload<S extends boolean | null | undefined | MenuMetaDefaultArgs> = $Result.GetResult<Prisma.$MenuMetaPayload, S>

  type MenuMetaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MenuMetaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MenuMetaCountAggregateInputType | true
    }

  export interface MenuMetaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MenuMeta'], meta: { name: 'MenuMeta' } }
    /**
     * Find zero or one MenuMeta that matches the filter.
     * @param {MenuMetaFindUniqueArgs} args - Arguments to find a MenuMeta
     * @example
     * // Get one MenuMeta
     * const menuMeta = await prisma.menuMeta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenuMetaFindUniqueArgs>(args: SelectSubset<T, MenuMetaFindUniqueArgs<ExtArgs>>): Prisma__MenuMetaClient<$Result.GetResult<Prisma.$MenuMetaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MenuMeta that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MenuMetaFindUniqueOrThrowArgs} args - Arguments to find a MenuMeta
     * @example
     * // Get one MenuMeta
     * const menuMeta = await prisma.menuMeta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenuMetaFindUniqueOrThrowArgs>(args: SelectSubset<T, MenuMetaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenuMetaClient<$Result.GetResult<Prisma.$MenuMetaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MenuMeta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuMetaFindFirstArgs} args - Arguments to find a MenuMeta
     * @example
     * // Get one MenuMeta
     * const menuMeta = await prisma.menuMeta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenuMetaFindFirstArgs>(args?: SelectSubset<T, MenuMetaFindFirstArgs<ExtArgs>>): Prisma__MenuMetaClient<$Result.GetResult<Prisma.$MenuMetaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MenuMeta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuMetaFindFirstOrThrowArgs} args - Arguments to find a MenuMeta
     * @example
     * // Get one MenuMeta
     * const menuMeta = await prisma.menuMeta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenuMetaFindFirstOrThrowArgs>(args?: SelectSubset<T, MenuMetaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenuMetaClient<$Result.GetResult<Prisma.$MenuMetaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MenuMetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuMetaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenuMetas
     * const menuMetas = await prisma.menuMeta.findMany()
     * 
     * // Get first 10 MenuMetas
     * const menuMetas = await prisma.menuMeta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menuMetaWithIdOnly = await prisma.menuMeta.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MenuMetaFindManyArgs>(args?: SelectSubset<T, MenuMetaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuMetaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MenuMeta.
     * @param {MenuMetaCreateArgs} args - Arguments to create a MenuMeta.
     * @example
     * // Create one MenuMeta
     * const MenuMeta = await prisma.menuMeta.create({
     *   data: {
     *     // ... data to create a MenuMeta
     *   }
     * })
     * 
     */
    create<T extends MenuMetaCreateArgs>(args: SelectSubset<T, MenuMetaCreateArgs<ExtArgs>>): Prisma__MenuMetaClient<$Result.GetResult<Prisma.$MenuMetaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MenuMetas.
     * @param {MenuMetaCreateManyArgs} args - Arguments to create many MenuMetas.
     * @example
     * // Create many MenuMetas
     * const menuMeta = await prisma.menuMeta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenuMetaCreateManyArgs>(args?: SelectSubset<T, MenuMetaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MenuMetas and returns the data saved in the database.
     * @param {MenuMetaCreateManyAndReturnArgs} args - Arguments to create many MenuMetas.
     * @example
     * // Create many MenuMetas
     * const menuMeta = await prisma.menuMeta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MenuMetas and only return the `id`
     * const menuMetaWithIdOnly = await prisma.menuMeta.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenuMetaCreateManyAndReturnArgs>(args?: SelectSubset<T, MenuMetaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuMetaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MenuMeta.
     * @param {MenuMetaDeleteArgs} args - Arguments to delete one MenuMeta.
     * @example
     * // Delete one MenuMeta
     * const MenuMeta = await prisma.menuMeta.delete({
     *   where: {
     *     // ... filter to delete one MenuMeta
     *   }
     * })
     * 
     */
    delete<T extends MenuMetaDeleteArgs>(args: SelectSubset<T, MenuMetaDeleteArgs<ExtArgs>>): Prisma__MenuMetaClient<$Result.GetResult<Prisma.$MenuMetaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MenuMeta.
     * @param {MenuMetaUpdateArgs} args - Arguments to update one MenuMeta.
     * @example
     * // Update one MenuMeta
     * const menuMeta = await prisma.menuMeta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenuMetaUpdateArgs>(args: SelectSubset<T, MenuMetaUpdateArgs<ExtArgs>>): Prisma__MenuMetaClient<$Result.GetResult<Prisma.$MenuMetaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MenuMetas.
     * @param {MenuMetaDeleteManyArgs} args - Arguments to filter MenuMetas to delete.
     * @example
     * // Delete a few MenuMetas
     * const { count } = await prisma.menuMeta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenuMetaDeleteManyArgs>(args?: SelectSubset<T, MenuMetaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuMetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenuMetas
     * const menuMeta = await prisma.menuMeta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenuMetaUpdateManyArgs>(args: SelectSubset<T, MenuMetaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MenuMeta.
     * @param {MenuMetaUpsertArgs} args - Arguments to update or create a MenuMeta.
     * @example
     * // Update or create a MenuMeta
     * const menuMeta = await prisma.menuMeta.upsert({
     *   create: {
     *     // ... data to create a MenuMeta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenuMeta we want to update
     *   }
     * })
     */
    upsert<T extends MenuMetaUpsertArgs>(args: SelectSubset<T, MenuMetaUpsertArgs<ExtArgs>>): Prisma__MenuMetaClient<$Result.GetResult<Prisma.$MenuMetaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MenuMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuMetaCountArgs} args - Arguments to filter MenuMetas to count.
     * @example
     * // Count the number of MenuMetas
     * const count = await prisma.menuMeta.count({
     *   where: {
     *     // ... the filter for the MenuMetas we want to count
     *   }
     * })
    **/
    count<T extends MenuMetaCountArgs>(
      args?: Subset<T, MenuMetaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuMetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenuMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuMetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuMetaAggregateArgs>(args: Subset<T, MenuMetaAggregateArgs>): Prisma.PrismaPromise<GetMenuMetaAggregateType<T>>

    /**
     * Group by MenuMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuMetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuMetaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuMetaGroupByArgs['orderBy'] }
        : { orderBy?: MenuMetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuMetaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuMetaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MenuMeta model
   */
  readonly fields: MenuMetaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenuMeta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenuMetaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    menu<T extends MenuDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MenuDefaultArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MenuMeta model
   */ 
  interface MenuMetaFieldRefs {
    readonly id: FieldRef<"MenuMeta", 'Int'>
    readonly title: FieldRef<"MenuMeta", 'String'>
    readonly layout: FieldRef<"MenuMeta", 'String'>
    readonly order: FieldRef<"MenuMeta", 'Int'>
    readonly hidden: FieldRef<"MenuMeta", 'Boolean'>
    readonly disabled: FieldRef<"MenuMeta", 'Boolean'>
    readonly icon: FieldRef<"MenuMeta", 'String'>
    readonly status: FieldRef<"MenuMeta", 'Int'>
    readonly menuId: FieldRef<"MenuMeta", 'Int'>
    readonly createdAt: FieldRef<"MenuMeta", 'DateTime'>
    readonly updatedAt: FieldRef<"MenuMeta", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MenuMeta findUnique
   */
  export type MenuMetaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuMeta
     */
    select?: MenuMetaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuMetaInclude<ExtArgs> | null
    /**
     * Filter, which MenuMeta to fetch.
     */
    where: MenuMetaWhereUniqueInput
  }

  /**
   * MenuMeta findUniqueOrThrow
   */
  export type MenuMetaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuMeta
     */
    select?: MenuMetaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuMetaInclude<ExtArgs> | null
    /**
     * Filter, which MenuMeta to fetch.
     */
    where: MenuMetaWhereUniqueInput
  }

  /**
   * MenuMeta findFirst
   */
  export type MenuMetaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuMeta
     */
    select?: MenuMetaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuMetaInclude<ExtArgs> | null
    /**
     * Filter, which MenuMeta to fetch.
     */
    where?: MenuMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuMetas to fetch.
     */
    orderBy?: MenuMetaOrderByWithRelationInput | MenuMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuMetas.
     */
    cursor?: MenuMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuMetas.
     */
    distinct?: MenuMetaScalarFieldEnum | MenuMetaScalarFieldEnum[]
  }

  /**
   * MenuMeta findFirstOrThrow
   */
  export type MenuMetaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuMeta
     */
    select?: MenuMetaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuMetaInclude<ExtArgs> | null
    /**
     * Filter, which MenuMeta to fetch.
     */
    where?: MenuMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuMetas to fetch.
     */
    orderBy?: MenuMetaOrderByWithRelationInput | MenuMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuMetas.
     */
    cursor?: MenuMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuMetas.
     */
    distinct?: MenuMetaScalarFieldEnum | MenuMetaScalarFieldEnum[]
  }

  /**
   * MenuMeta findMany
   */
  export type MenuMetaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuMeta
     */
    select?: MenuMetaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuMetaInclude<ExtArgs> | null
    /**
     * Filter, which MenuMetas to fetch.
     */
    where?: MenuMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuMetas to fetch.
     */
    orderBy?: MenuMetaOrderByWithRelationInput | MenuMetaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenuMetas.
     */
    cursor?: MenuMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuMetas.
     */
    skip?: number
    distinct?: MenuMetaScalarFieldEnum | MenuMetaScalarFieldEnum[]
  }

  /**
   * MenuMeta create
   */
  export type MenuMetaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuMeta
     */
    select?: MenuMetaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuMetaInclude<ExtArgs> | null
    /**
     * The data needed to create a MenuMeta.
     */
    data: XOR<MenuMetaCreateInput, MenuMetaUncheckedCreateInput>
  }

  /**
   * MenuMeta createMany
   */
  export type MenuMetaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MenuMetas.
     */
    data: MenuMetaCreateManyInput | MenuMetaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MenuMeta createManyAndReturn
   */
  export type MenuMetaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuMeta
     */
    select?: MenuMetaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MenuMetas.
     */
    data: MenuMetaCreateManyInput | MenuMetaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuMetaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenuMeta update
   */
  export type MenuMetaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuMeta
     */
    select?: MenuMetaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuMetaInclude<ExtArgs> | null
    /**
     * The data needed to update a MenuMeta.
     */
    data: XOR<MenuMetaUpdateInput, MenuMetaUncheckedUpdateInput>
    /**
     * Choose, which MenuMeta to update.
     */
    where: MenuMetaWhereUniqueInput
  }

  /**
   * MenuMeta updateMany
   */
  export type MenuMetaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MenuMetas.
     */
    data: XOR<MenuMetaUpdateManyMutationInput, MenuMetaUncheckedUpdateManyInput>
    /**
     * Filter which MenuMetas to update
     */
    where?: MenuMetaWhereInput
  }

  /**
   * MenuMeta upsert
   */
  export type MenuMetaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuMeta
     */
    select?: MenuMetaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuMetaInclude<ExtArgs> | null
    /**
     * The filter to search for the MenuMeta to update in case it exists.
     */
    where: MenuMetaWhereUniqueInput
    /**
     * In case the MenuMeta found by the `where` argument doesn't exist, create a new MenuMeta with this data.
     */
    create: XOR<MenuMetaCreateInput, MenuMetaUncheckedCreateInput>
    /**
     * In case the MenuMeta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenuMetaUpdateInput, MenuMetaUncheckedUpdateInput>
  }

  /**
   * MenuMeta delete
   */
  export type MenuMetaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuMeta
     */
    select?: MenuMetaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuMetaInclude<ExtArgs> | null
    /**
     * Filter which MenuMeta to delete.
     */
    where: MenuMetaWhereUniqueInput
  }

  /**
   * MenuMeta deleteMany
   */
  export type MenuMetaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenuMetas to delete
     */
    where?: MenuMetaWhereInput
  }

  /**
   * MenuMeta without action
   */
  export type MenuMetaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuMeta
     */
    select?: MenuMetaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuMetaInclude<ExtArgs> | null
  }


  /**
   * Model RoleMenu
   */

  export type AggregateRoleMenu = {
    _count: RoleMenuCountAggregateOutputType | null
    _avg: RoleMenuAvgAggregateOutputType | null
    _sum: RoleMenuSumAggregateOutputType | null
    _min: RoleMenuMinAggregateOutputType | null
    _max: RoleMenuMaxAggregateOutputType | null
  }

  export type RoleMenuAvgAggregateOutputType = {
    roleId: number | null
    menuId: number | null
  }

  export type RoleMenuSumAggregateOutputType = {
    roleId: number | null
    menuId: number | null
  }

  export type RoleMenuMinAggregateOutputType = {
    roleId: number | null
    menuId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMenuMaxAggregateOutputType = {
    roleId: number | null
    menuId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMenuCountAggregateOutputType = {
    roleId: number
    menuId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMenuAvgAggregateInputType = {
    roleId?: true
    menuId?: true
  }

  export type RoleMenuSumAggregateInputType = {
    roleId?: true
    menuId?: true
  }

  export type RoleMenuMinAggregateInputType = {
    roleId?: true
    menuId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMenuMaxAggregateInputType = {
    roleId?: true
    menuId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMenuCountAggregateInputType = {
    roleId?: true
    menuId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleMenuAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleMenu to aggregate.
     */
    where?: RoleMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleMenus to fetch.
     */
    orderBy?: RoleMenuOrderByWithRelationInput | RoleMenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleMenus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoleMenus
    **/
    _count?: true | RoleMenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleMenuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleMenuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMenuMaxAggregateInputType
  }

  export type GetRoleMenuAggregateType<T extends RoleMenuAggregateArgs> = {
        [P in keyof T & keyof AggregateRoleMenu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoleMenu[P]>
      : GetScalarType<T[P], AggregateRoleMenu[P]>
  }




  export type RoleMenuGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleMenuWhereInput
    orderBy?: RoleMenuOrderByWithAggregationInput | RoleMenuOrderByWithAggregationInput[]
    by: RoleMenuScalarFieldEnum[] | RoleMenuScalarFieldEnum
    having?: RoleMenuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleMenuCountAggregateInputType | true
    _avg?: RoleMenuAvgAggregateInputType
    _sum?: RoleMenuSumAggregateInputType
    _min?: RoleMenuMinAggregateInputType
    _max?: RoleMenuMaxAggregateInputType
  }

  export type RoleMenuGroupByOutputType = {
    roleId: number
    menuId: number
    createdAt: Date
    updatedAt: Date
    _count: RoleMenuCountAggregateOutputType | null
    _avg: RoleMenuAvgAggregateOutputType | null
    _sum: RoleMenuSumAggregateOutputType | null
    _min: RoleMenuMinAggregateOutputType | null
    _max: RoleMenuMaxAggregateOutputType | null
  }

  type GetRoleMenuGroupByPayload<T extends RoleMenuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleMenuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleMenuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleMenuGroupByOutputType[P]>
            : GetScalarType<T[P], RoleMenuGroupByOutputType[P]>
        }
      >
    >


  export type RoleMenuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    menuId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    menu?: boolean | MenuDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleMenu"]>

  export type RoleMenuSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    menuId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    menu?: boolean | MenuDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleMenu"]>

  export type RoleMenuSelectScalar = {
    roleId?: boolean
    menuId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleMenuInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    menu?: boolean | MenuDefaultArgs<ExtArgs>
  }
  export type RoleMenuIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    menu?: boolean | MenuDefaultArgs<ExtArgs>
  }

  export type $RoleMenuPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoleMenu"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      menu: Prisma.$MenuPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      roleId: number
      menuId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roleMenu"]>
    composites: {}
  }

  type RoleMenuGetPayload<S extends boolean | null | undefined | RoleMenuDefaultArgs> = $Result.GetResult<Prisma.$RoleMenuPayload, S>

  type RoleMenuCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleMenuFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleMenuCountAggregateInputType | true
    }

  export interface RoleMenuDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoleMenu'], meta: { name: 'RoleMenu' } }
    /**
     * Find zero or one RoleMenu that matches the filter.
     * @param {RoleMenuFindUniqueArgs} args - Arguments to find a RoleMenu
     * @example
     * // Get one RoleMenu
     * const roleMenu = await prisma.roleMenu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleMenuFindUniqueArgs>(args: SelectSubset<T, RoleMenuFindUniqueArgs<ExtArgs>>): Prisma__RoleMenuClient<$Result.GetResult<Prisma.$RoleMenuPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RoleMenu that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleMenuFindUniqueOrThrowArgs} args - Arguments to find a RoleMenu
     * @example
     * // Get one RoleMenu
     * const roleMenu = await prisma.roleMenu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleMenuFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleMenuFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleMenuClient<$Result.GetResult<Prisma.$RoleMenuPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RoleMenu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleMenuFindFirstArgs} args - Arguments to find a RoleMenu
     * @example
     * // Get one RoleMenu
     * const roleMenu = await prisma.roleMenu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleMenuFindFirstArgs>(args?: SelectSubset<T, RoleMenuFindFirstArgs<ExtArgs>>): Prisma__RoleMenuClient<$Result.GetResult<Prisma.$RoleMenuPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RoleMenu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleMenuFindFirstOrThrowArgs} args - Arguments to find a RoleMenu
     * @example
     * // Get one RoleMenu
     * const roleMenu = await prisma.roleMenu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleMenuFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleMenuFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleMenuClient<$Result.GetResult<Prisma.$RoleMenuPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RoleMenus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleMenuFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoleMenus
     * const roleMenus = await prisma.roleMenu.findMany()
     * 
     * // Get first 10 RoleMenus
     * const roleMenus = await prisma.roleMenu.findMany({ take: 10 })
     * 
     * // Only select the `roleId`
     * const roleMenuWithRoleIdOnly = await prisma.roleMenu.findMany({ select: { roleId: true } })
     * 
     */
    findMany<T extends RoleMenuFindManyArgs>(args?: SelectSubset<T, RoleMenuFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleMenuPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RoleMenu.
     * @param {RoleMenuCreateArgs} args - Arguments to create a RoleMenu.
     * @example
     * // Create one RoleMenu
     * const RoleMenu = await prisma.roleMenu.create({
     *   data: {
     *     // ... data to create a RoleMenu
     *   }
     * })
     * 
     */
    create<T extends RoleMenuCreateArgs>(args: SelectSubset<T, RoleMenuCreateArgs<ExtArgs>>): Prisma__RoleMenuClient<$Result.GetResult<Prisma.$RoleMenuPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RoleMenus.
     * @param {RoleMenuCreateManyArgs} args - Arguments to create many RoleMenus.
     * @example
     * // Create many RoleMenus
     * const roleMenu = await prisma.roleMenu.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleMenuCreateManyArgs>(args?: SelectSubset<T, RoleMenuCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoleMenus and returns the data saved in the database.
     * @param {RoleMenuCreateManyAndReturnArgs} args - Arguments to create many RoleMenus.
     * @example
     * // Create many RoleMenus
     * const roleMenu = await prisma.roleMenu.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoleMenus and only return the `roleId`
     * const roleMenuWithRoleIdOnly = await prisma.roleMenu.createManyAndReturn({ 
     *   select: { roleId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleMenuCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleMenuCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleMenuPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RoleMenu.
     * @param {RoleMenuDeleteArgs} args - Arguments to delete one RoleMenu.
     * @example
     * // Delete one RoleMenu
     * const RoleMenu = await prisma.roleMenu.delete({
     *   where: {
     *     // ... filter to delete one RoleMenu
     *   }
     * })
     * 
     */
    delete<T extends RoleMenuDeleteArgs>(args: SelectSubset<T, RoleMenuDeleteArgs<ExtArgs>>): Prisma__RoleMenuClient<$Result.GetResult<Prisma.$RoleMenuPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RoleMenu.
     * @param {RoleMenuUpdateArgs} args - Arguments to update one RoleMenu.
     * @example
     * // Update one RoleMenu
     * const roleMenu = await prisma.roleMenu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleMenuUpdateArgs>(args: SelectSubset<T, RoleMenuUpdateArgs<ExtArgs>>): Prisma__RoleMenuClient<$Result.GetResult<Prisma.$RoleMenuPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RoleMenus.
     * @param {RoleMenuDeleteManyArgs} args - Arguments to filter RoleMenus to delete.
     * @example
     * // Delete a few RoleMenus
     * const { count } = await prisma.roleMenu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleMenuDeleteManyArgs>(args?: SelectSubset<T, RoleMenuDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleMenus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleMenuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoleMenus
     * const roleMenu = await prisma.roleMenu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleMenuUpdateManyArgs>(args: SelectSubset<T, RoleMenuUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoleMenu.
     * @param {RoleMenuUpsertArgs} args - Arguments to update or create a RoleMenu.
     * @example
     * // Update or create a RoleMenu
     * const roleMenu = await prisma.roleMenu.upsert({
     *   create: {
     *     // ... data to create a RoleMenu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoleMenu we want to update
     *   }
     * })
     */
    upsert<T extends RoleMenuUpsertArgs>(args: SelectSubset<T, RoleMenuUpsertArgs<ExtArgs>>): Prisma__RoleMenuClient<$Result.GetResult<Prisma.$RoleMenuPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RoleMenus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleMenuCountArgs} args - Arguments to filter RoleMenus to count.
     * @example
     * // Count the number of RoleMenus
     * const count = await prisma.roleMenu.count({
     *   where: {
     *     // ... the filter for the RoleMenus we want to count
     *   }
     * })
    **/
    count<T extends RoleMenuCountArgs>(
      args?: Subset<T, RoleMenuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleMenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoleMenu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleMenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleMenuAggregateArgs>(args: Subset<T, RoleMenuAggregateArgs>): Prisma.PrismaPromise<GetRoleMenuAggregateType<T>>

    /**
     * Group by RoleMenu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleMenuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleMenuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleMenuGroupByArgs['orderBy'] }
        : { orderBy?: RoleMenuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleMenuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleMenuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoleMenu model
   */
  readonly fields: RoleMenuFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoleMenu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleMenuClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    menu<T extends MenuDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MenuDefaultArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoleMenu model
   */ 
  interface RoleMenuFieldRefs {
    readonly roleId: FieldRef<"RoleMenu", 'Int'>
    readonly menuId: FieldRef<"RoleMenu", 'Int'>
    readonly createdAt: FieldRef<"RoleMenu", 'DateTime'>
    readonly updatedAt: FieldRef<"RoleMenu", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoleMenu findUnique
   */
  export type RoleMenuFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleMenu
     */
    select?: RoleMenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleMenuInclude<ExtArgs> | null
    /**
     * Filter, which RoleMenu to fetch.
     */
    where: RoleMenuWhereUniqueInput
  }

  /**
   * RoleMenu findUniqueOrThrow
   */
  export type RoleMenuFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleMenu
     */
    select?: RoleMenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleMenuInclude<ExtArgs> | null
    /**
     * Filter, which RoleMenu to fetch.
     */
    where: RoleMenuWhereUniqueInput
  }

  /**
   * RoleMenu findFirst
   */
  export type RoleMenuFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleMenu
     */
    select?: RoleMenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleMenuInclude<ExtArgs> | null
    /**
     * Filter, which RoleMenu to fetch.
     */
    where?: RoleMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleMenus to fetch.
     */
    orderBy?: RoleMenuOrderByWithRelationInput | RoleMenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleMenus.
     */
    cursor?: RoleMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleMenus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleMenus.
     */
    distinct?: RoleMenuScalarFieldEnum | RoleMenuScalarFieldEnum[]
  }

  /**
   * RoleMenu findFirstOrThrow
   */
  export type RoleMenuFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleMenu
     */
    select?: RoleMenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleMenuInclude<ExtArgs> | null
    /**
     * Filter, which RoleMenu to fetch.
     */
    where?: RoleMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleMenus to fetch.
     */
    orderBy?: RoleMenuOrderByWithRelationInput | RoleMenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleMenus.
     */
    cursor?: RoleMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleMenus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleMenus.
     */
    distinct?: RoleMenuScalarFieldEnum | RoleMenuScalarFieldEnum[]
  }

  /**
   * RoleMenu findMany
   */
  export type RoleMenuFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleMenu
     */
    select?: RoleMenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleMenuInclude<ExtArgs> | null
    /**
     * Filter, which RoleMenus to fetch.
     */
    where?: RoleMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleMenus to fetch.
     */
    orderBy?: RoleMenuOrderByWithRelationInput | RoleMenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoleMenus.
     */
    cursor?: RoleMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleMenus.
     */
    skip?: number
    distinct?: RoleMenuScalarFieldEnum | RoleMenuScalarFieldEnum[]
  }

  /**
   * RoleMenu create
   */
  export type RoleMenuCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleMenu
     */
    select?: RoleMenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleMenuInclude<ExtArgs> | null
    /**
     * The data needed to create a RoleMenu.
     */
    data: XOR<RoleMenuCreateInput, RoleMenuUncheckedCreateInput>
  }

  /**
   * RoleMenu createMany
   */
  export type RoleMenuCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoleMenus.
     */
    data: RoleMenuCreateManyInput | RoleMenuCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoleMenu createManyAndReturn
   */
  export type RoleMenuCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleMenu
     */
    select?: RoleMenuSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RoleMenus.
     */
    data: RoleMenuCreateManyInput | RoleMenuCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleMenuIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoleMenu update
   */
  export type RoleMenuUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleMenu
     */
    select?: RoleMenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleMenuInclude<ExtArgs> | null
    /**
     * The data needed to update a RoleMenu.
     */
    data: XOR<RoleMenuUpdateInput, RoleMenuUncheckedUpdateInput>
    /**
     * Choose, which RoleMenu to update.
     */
    where: RoleMenuWhereUniqueInput
  }

  /**
   * RoleMenu updateMany
   */
  export type RoleMenuUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoleMenus.
     */
    data: XOR<RoleMenuUpdateManyMutationInput, RoleMenuUncheckedUpdateManyInput>
    /**
     * Filter which RoleMenus to update
     */
    where?: RoleMenuWhereInput
  }

  /**
   * RoleMenu upsert
   */
  export type RoleMenuUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleMenu
     */
    select?: RoleMenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleMenuInclude<ExtArgs> | null
    /**
     * The filter to search for the RoleMenu to update in case it exists.
     */
    where: RoleMenuWhereUniqueInput
    /**
     * In case the RoleMenu found by the `where` argument doesn't exist, create a new RoleMenu with this data.
     */
    create: XOR<RoleMenuCreateInput, RoleMenuUncheckedCreateInput>
    /**
     * In case the RoleMenu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleMenuUpdateInput, RoleMenuUncheckedUpdateInput>
  }

  /**
   * RoleMenu delete
   */
  export type RoleMenuDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleMenu
     */
    select?: RoleMenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleMenuInclude<ExtArgs> | null
    /**
     * Filter which RoleMenu to delete.
     */
    where: RoleMenuWhereUniqueInput
  }

  /**
   * RoleMenu deleteMany
   */
  export type RoleMenuDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleMenus to delete
     */
    where?: RoleMenuWhereInput
  }

  /**
   * RoleMenu without action
   */
  export type RoleMenuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleMenu
     */
    select?: RoleMenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleMenuInclude<ExtArgs> | null
  }


  /**
   * Model DictAttachmentAttribute
   */

  export type AggregateDictAttachmentAttribute = {
    _count: DictAttachmentAttributeCountAggregateOutputType | null
    _avg: DictAttachmentAttributeAvgAggregateOutputType | null
    _sum: DictAttachmentAttributeSumAggregateOutputType | null
    _min: DictAttachmentAttributeMinAggregateOutputType | null
    _max: DictAttachmentAttributeMaxAggregateOutputType | null
  }

  export type DictAttachmentAttributeAvgAggregateOutputType = {
    id: number | null
  }

  export type DictAttachmentAttributeSumAggregateOutputType = {
    id: number | null
  }

  export type DictAttachmentAttributeMinAggregateOutputType = {
    id: number | null
    type: string | null
    name: string | null
    desc: string | null
  }

  export type DictAttachmentAttributeMaxAggregateOutputType = {
    id: number | null
    type: string | null
    name: string | null
    desc: string | null
  }

  export type DictAttachmentAttributeCountAggregateOutputType = {
    id: number
    type: number
    name: number
    desc: number
    _all: number
  }


  export type DictAttachmentAttributeAvgAggregateInputType = {
    id?: true
  }

  export type DictAttachmentAttributeSumAggregateInputType = {
    id?: true
  }

  export type DictAttachmentAttributeMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    desc?: true
  }

  export type DictAttachmentAttributeMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    desc?: true
  }

  export type DictAttachmentAttributeCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    desc?: true
    _all?: true
  }

  export type DictAttachmentAttributeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DictAttachmentAttribute to aggregate.
     */
    where?: DictAttachmentAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DictAttachmentAttributes to fetch.
     */
    orderBy?: DictAttachmentAttributeOrderByWithRelationInput | DictAttachmentAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DictAttachmentAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DictAttachmentAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DictAttachmentAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DictAttachmentAttributes
    **/
    _count?: true | DictAttachmentAttributeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DictAttachmentAttributeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DictAttachmentAttributeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DictAttachmentAttributeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DictAttachmentAttributeMaxAggregateInputType
  }

  export type GetDictAttachmentAttributeAggregateType<T extends DictAttachmentAttributeAggregateArgs> = {
        [P in keyof T & keyof AggregateDictAttachmentAttribute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDictAttachmentAttribute[P]>
      : GetScalarType<T[P], AggregateDictAttachmentAttribute[P]>
  }




  export type DictAttachmentAttributeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DictAttachmentAttributeWhereInput
    orderBy?: DictAttachmentAttributeOrderByWithAggregationInput | DictAttachmentAttributeOrderByWithAggregationInput[]
    by: DictAttachmentAttributeScalarFieldEnum[] | DictAttachmentAttributeScalarFieldEnum
    having?: DictAttachmentAttributeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DictAttachmentAttributeCountAggregateInputType | true
    _avg?: DictAttachmentAttributeAvgAggregateInputType
    _sum?: DictAttachmentAttributeSumAggregateInputType
    _min?: DictAttachmentAttributeMinAggregateInputType
    _max?: DictAttachmentAttributeMaxAggregateInputType
  }

  export type DictAttachmentAttributeGroupByOutputType = {
    id: number
    type: string
    name: string
    desc: string | null
    _count: DictAttachmentAttributeCountAggregateOutputType | null
    _avg: DictAttachmentAttributeAvgAggregateOutputType | null
    _sum: DictAttachmentAttributeSumAggregateOutputType | null
    _min: DictAttachmentAttributeMinAggregateOutputType | null
    _max: DictAttachmentAttributeMaxAggregateOutputType | null
  }

  type GetDictAttachmentAttributeGroupByPayload<T extends DictAttachmentAttributeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DictAttachmentAttributeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DictAttachmentAttributeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DictAttachmentAttributeGroupByOutputType[P]>
            : GetScalarType<T[P], DictAttachmentAttributeGroupByOutputType[P]>
        }
      >
    >


  export type DictAttachmentAttributeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    desc?: boolean
    AttachmentAttribute?: boolean | DictAttachmentAttribute$AttachmentAttributeArgs<ExtArgs>
    _count?: boolean | DictAttachmentAttributeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dictAttachmentAttribute"]>

  export type DictAttachmentAttributeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    desc?: boolean
  }, ExtArgs["result"]["dictAttachmentAttribute"]>

  export type DictAttachmentAttributeSelectScalar = {
    id?: boolean
    type?: boolean
    name?: boolean
    desc?: boolean
  }

  export type DictAttachmentAttributeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AttachmentAttribute?: boolean | DictAttachmentAttribute$AttachmentAttributeArgs<ExtArgs>
    _count?: boolean | DictAttachmentAttributeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DictAttachmentAttributeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DictAttachmentAttributePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DictAttachmentAttribute"
    objects: {
      AttachmentAttribute: Prisma.$AttachmentAttributePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      name: string
      desc: string | null
    }, ExtArgs["result"]["dictAttachmentAttribute"]>
    composites: {}
  }

  type DictAttachmentAttributeGetPayload<S extends boolean | null | undefined | DictAttachmentAttributeDefaultArgs> = $Result.GetResult<Prisma.$DictAttachmentAttributePayload, S>

  type DictAttachmentAttributeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DictAttachmentAttributeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DictAttachmentAttributeCountAggregateInputType | true
    }

  export interface DictAttachmentAttributeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DictAttachmentAttribute'], meta: { name: 'DictAttachmentAttribute' } }
    /**
     * Find zero or one DictAttachmentAttribute that matches the filter.
     * @param {DictAttachmentAttributeFindUniqueArgs} args - Arguments to find a DictAttachmentAttribute
     * @example
     * // Get one DictAttachmentAttribute
     * const dictAttachmentAttribute = await prisma.dictAttachmentAttribute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DictAttachmentAttributeFindUniqueArgs>(args: SelectSubset<T, DictAttachmentAttributeFindUniqueArgs<ExtArgs>>): Prisma__DictAttachmentAttributeClient<$Result.GetResult<Prisma.$DictAttachmentAttributePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DictAttachmentAttribute that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DictAttachmentAttributeFindUniqueOrThrowArgs} args - Arguments to find a DictAttachmentAttribute
     * @example
     * // Get one DictAttachmentAttribute
     * const dictAttachmentAttribute = await prisma.dictAttachmentAttribute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DictAttachmentAttributeFindUniqueOrThrowArgs>(args: SelectSubset<T, DictAttachmentAttributeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DictAttachmentAttributeClient<$Result.GetResult<Prisma.$DictAttachmentAttributePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DictAttachmentAttribute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictAttachmentAttributeFindFirstArgs} args - Arguments to find a DictAttachmentAttribute
     * @example
     * // Get one DictAttachmentAttribute
     * const dictAttachmentAttribute = await prisma.dictAttachmentAttribute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DictAttachmentAttributeFindFirstArgs>(args?: SelectSubset<T, DictAttachmentAttributeFindFirstArgs<ExtArgs>>): Prisma__DictAttachmentAttributeClient<$Result.GetResult<Prisma.$DictAttachmentAttributePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DictAttachmentAttribute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictAttachmentAttributeFindFirstOrThrowArgs} args - Arguments to find a DictAttachmentAttribute
     * @example
     * // Get one DictAttachmentAttribute
     * const dictAttachmentAttribute = await prisma.dictAttachmentAttribute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DictAttachmentAttributeFindFirstOrThrowArgs>(args?: SelectSubset<T, DictAttachmentAttributeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DictAttachmentAttributeClient<$Result.GetResult<Prisma.$DictAttachmentAttributePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DictAttachmentAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictAttachmentAttributeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DictAttachmentAttributes
     * const dictAttachmentAttributes = await prisma.dictAttachmentAttribute.findMany()
     * 
     * // Get first 10 DictAttachmentAttributes
     * const dictAttachmentAttributes = await prisma.dictAttachmentAttribute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dictAttachmentAttributeWithIdOnly = await prisma.dictAttachmentAttribute.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DictAttachmentAttributeFindManyArgs>(args?: SelectSubset<T, DictAttachmentAttributeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DictAttachmentAttributePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DictAttachmentAttribute.
     * @param {DictAttachmentAttributeCreateArgs} args - Arguments to create a DictAttachmentAttribute.
     * @example
     * // Create one DictAttachmentAttribute
     * const DictAttachmentAttribute = await prisma.dictAttachmentAttribute.create({
     *   data: {
     *     // ... data to create a DictAttachmentAttribute
     *   }
     * })
     * 
     */
    create<T extends DictAttachmentAttributeCreateArgs>(args: SelectSubset<T, DictAttachmentAttributeCreateArgs<ExtArgs>>): Prisma__DictAttachmentAttributeClient<$Result.GetResult<Prisma.$DictAttachmentAttributePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DictAttachmentAttributes.
     * @param {DictAttachmentAttributeCreateManyArgs} args - Arguments to create many DictAttachmentAttributes.
     * @example
     * // Create many DictAttachmentAttributes
     * const dictAttachmentAttribute = await prisma.dictAttachmentAttribute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DictAttachmentAttributeCreateManyArgs>(args?: SelectSubset<T, DictAttachmentAttributeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DictAttachmentAttributes and returns the data saved in the database.
     * @param {DictAttachmentAttributeCreateManyAndReturnArgs} args - Arguments to create many DictAttachmentAttributes.
     * @example
     * // Create many DictAttachmentAttributes
     * const dictAttachmentAttribute = await prisma.dictAttachmentAttribute.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DictAttachmentAttributes and only return the `id`
     * const dictAttachmentAttributeWithIdOnly = await prisma.dictAttachmentAttribute.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DictAttachmentAttributeCreateManyAndReturnArgs>(args?: SelectSubset<T, DictAttachmentAttributeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DictAttachmentAttributePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DictAttachmentAttribute.
     * @param {DictAttachmentAttributeDeleteArgs} args - Arguments to delete one DictAttachmentAttribute.
     * @example
     * // Delete one DictAttachmentAttribute
     * const DictAttachmentAttribute = await prisma.dictAttachmentAttribute.delete({
     *   where: {
     *     // ... filter to delete one DictAttachmentAttribute
     *   }
     * })
     * 
     */
    delete<T extends DictAttachmentAttributeDeleteArgs>(args: SelectSubset<T, DictAttachmentAttributeDeleteArgs<ExtArgs>>): Prisma__DictAttachmentAttributeClient<$Result.GetResult<Prisma.$DictAttachmentAttributePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DictAttachmentAttribute.
     * @param {DictAttachmentAttributeUpdateArgs} args - Arguments to update one DictAttachmentAttribute.
     * @example
     * // Update one DictAttachmentAttribute
     * const dictAttachmentAttribute = await prisma.dictAttachmentAttribute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DictAttachmentAttributeUpdateArgs>(args: SelectSubset<T, DictAttachmentAttributeUpdateArgs<ExtArgs>>): Prisma__DictAttachmentAttributeClient<$Result.GetResult<Prisma.$DictAttachmentAttributePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DictAttachmentAttributes.
     * @param {DictAttachmentAttributeDeleteManyArgs} args - Arguments to filter DictAttachmentAttributes to delete.
     * @example
     * // Delete a few DictAttachmentAttributes
     * const { count } = await prisma.dictAttachmentAttribute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DictAttachmentAttributeDeleteManyArgs>(args?: SelectSubset<T, DictAttachmentAttributeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DictAttachmentAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictAttachmentAttributeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DictAttachmentAttributes
     * const dictAttachmentAttribute = await prisma.dictAttachmentAttribute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DictAttachmentAttributeUpdateManyArgs>(args: SelectSubset<T, DictAttachmentAttributeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DictAttachmentAttribute.
     * @param {DictAttachmentAttributeUpsertArgs} args - Arguments to update or create a DictAttachmentAttribute.
     * @example
     * // Update or create a DictAttachmentAttribute
     * const dictAttachmentAttribute = await prisma.dictAttachmentAttribute.upsert({
     *   create: {
     *     // ... data to create a DictAttachmentAttribute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DictAttachmentAttribute we want to update
     *   }
     * })
     */
    upsert<T extends DictAttachmentAttributeUpsertArgs>(args: SelectSubset<T, DictAttachmentAttributeUpsertArgs<ExtArgs>>): Prisma__DictAttachmentAttributeClient<$Result.GetResult<Prisma.$DictAttachmentAttributePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DictAttachmentAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictAttachmentAttributeCountArgs} args - Arguments to filter DictAttachmentAttributes to count.
     * @example
     * // Count the number of DictAttachmentAttributes
     * const count = await prisma.dictAttachmentAttribute.count({
     *   where: {
     *     // ... the filter for the DictAttachmentAttributes we want to count
     *   }
     * })
    **/
    count<T extends DictAttachmentAttributeCountArgs>(
      args?: Subset<T, DictAttachmentAttributeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DictAttachmentAttributeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DictAttachmentAttribute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictAttachmentAttributeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DictAttachmentAttributeAggregateArgs>(args: Subset<T, DictAttachmentAttributeAggregateArgs>): Prisma.PrismaPromise<GetDictAttachmentAttributeAggregateType<T>>

    /**
     * Group by DictAttachmentAttribute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictAttachmentAttributeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DictAttachmentAttributeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DictAttachmentAttributeGroupByArgs['orderBy'] }
        : { orderBy?: DictAttachmentAttributeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DictAttachmentAttributeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDictAttachmentAttributeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DictAttachmentAttribute model
   */
  readonly fields: DictAttachmentAttributeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DictAttachmentAttribute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DictAttachmentAttributeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AttachmentAttribute<T extends DictAttachmentAttribute$AttachmentAttributeArgs<ExtArgs> = {}>(args?: Subset<T, DictAttachmentAttribute$AttachmentAttributeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentAttributePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DictAttachmentAttribute model
   */ 
  interface DictAttachmentAttributeFieldRefs {
    readonly id: FieldRef<"DictAttachmentAttribute", 'Int'>
    readonly type: FieldRef<"DictAttachmentAttribute", 'String'>
    readonly name: FieldRef<"DictAttachmentAttribute", 'String'>
    readonly desc: FieldRef<"DictAttachmentAttribute", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DictAttachmentAttribute findUnique
   */
  export type DictAttachmentAttributeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictAttachmentAttribute
     */
    select?: DictAttachmentAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictAttachmentAttributeInclude<ExtArgs> | null
    /**
     * Filter, which DictAttachmentAttribute to fetch.
     */
    where: DictAttachmentAttributeWhereUniqueInput
  }

  /**
   * DictAttachmentAttribute findUniqueOrThrow
   */
  export type DictAttachmentAttributeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictAttachmentAttribute
     */
    select?: DictAttachmentAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictAttachmentAttributeInclude<ExtArgs> | null
    /**
     * Filter, which DictAttachmentAttribute to fetch.
     */
    where: DictAttachmentAttributeWhereUniqueInput
  }

  /**
   * DictAttachmentAttribute findFirst
   */
  export type DictAttachmentAttributeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictAttachmentAttribute
     */
    select?: DictAttachmentAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictAttachmentAttributeInclude<ExtArgs> | null
    /**
     * Filter, which DictAttachmentAttribute to fetch.
     */
    where?: DictAttachmentAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DictAttachmentAttributes to fetch.
     */
    orderBy?: DictAttachmentAttributeOrderByWithRelationInput | DictAttachmentAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DictAttachmentAttributes.
     */
    cursor?: DictAttachmentAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DictAttachmentAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DictAttachmentAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DictAttachmentAttributes.
     */
    distinct?: DictAttachmentAttributeScalarFieldEnum | DictAttachmentAttributeScalarFieldEnum[]
  }

  /**
   * DictAttachmentAttribute findFirstOrThrow
   */
  export type DictAttachmentAttributeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictAttachmentAttribute
     */
    select?: DictAttachmentAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictAttachmentAttributeInclude<ExtArgs> | null
    /**
     * Filter, which DictAttachmentAttribute to fetch.
     */
    where?: DictAttachmentAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DictAttachmentAttributes to fetch.
     */
    orderBy?: DictAttachmentAttributeOrderByWithRelationInput | DictAttachmentAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DictAttachmentAttributes.
     */
    cursor?: DictAttachmentAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DictAttachmentAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DictAttachmentAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DictAttachmentAttributes.
     */
    distinct?: DictAttachmentAttributeScalarFieldEnum | DictAttachmentAttributeScalarFieldEnum[]
  }

  /**
   * DictAttachmentAttribute findMany
   */
  export type DictAttachmentAttributeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictAttachmentAttribute
     */
    select?: DictAttachmentAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictAttachmentAttributeInclude<ExtArgs> | null
    /**
     * Filter, which DictAttachmentAttributes to fetch.
     */
    where?: DictAttachmentAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DictAttachmentAttributes to fetch.
     */
    orderBy?: DictAttachmentAttributeOrderByWithRelationInput | DictAttachmentAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DictAttachmentAttributes.
     */
    cursor?: DictAttachmentAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DictAttachmentAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DictAttachmentAttributes.
     */
    skip?: number
    distinct?: DictAttachmentAttributeScalarFieldEnum | DictAttachmentAttributeScalarFieldEnum[]
  }

  /**
   * DictAttachmentAttribute create
   */
  export type DictAttachmentAttributeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictAttachmentAttribute
     */
    select?: DictAttachmentAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictAttachmentAttributeInclude<ExtArgs> | null
    /**
     * The data needed to create a DictAttachmentAttribute.
     */
    data: XOR<DictAttachmentAttributeCreateInput, DictAttachmentAttributeUncheckedCreateInput>
  }

  /**
   * DictAttachmentAttribute createMany
   */
  export type DictAttachmentAttributeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DictAttachmentAttributes.
     */
    data: DictAttachmentAttributeCreateManyInput | DictAttachmentAttributeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DictAttachmentAttribute createManyAndReturn
   */
  export type DictAttachmentAttributeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictAttachmentAttribute
     */
    select?: DictAttachmentAttributeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DictAttachmentAttributes.
     */
    data: DictAttachmentAttributeCreateManyInput | DictAttachmentAttributeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DictAttachmentAttribute update
   */
  export type DictAttachmentAttributeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictAttachmentAttribute
     */
    select?: DictAttachmentAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictAttachmentAttributeInclude<ExtArgs> | null
    /**
     * The data needed to update a DictAttachmentAttribute.
     */
    data: XOR<DictAttachmentAttributeUpdateInput, DictAttachmentAttributeUncheckedUpdateInput>
    /**
     * Choose, which DictAttachmentAttribute to update.
     */
    where: DictAttachmentAttributeWhereUniqueInput
  }

  /**
   * DictAttachmentAttribute updateMany
   */
  export type DictAttachmentAttributeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DictAttachmentAttributes.
     */
    data: XOR<DictAttachmentAttributeUpdateManyMutationInput, DictAttachmentAttributeUncheckedUpdateManyInput>
    /**
     * Filter which DictAttachmentAttributes to update
     */
    where?: DictAttachmentAttributeWhereInput
  }

  /**
   * DictAttachmentAttribute upsert
   */
  export type DictAttachmentAttributeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictAttachmentAttribute
     */
    select?: DictAttachmentAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictAttachmentAttributeInclude<ExtArgs> | null
    /**
     * The filter to search for the DictAttachmentAttribute to update in case it exists.
     */
    where: DictAttachmentAttributeWhereUniqueInput
    /**
     * In case the DictAttachmentAttribute found by the `where` argument doesn't exist, create a new DictAttachmentAttribute with this data.
     */
    create: XOR<DictAttachmentAttributeCreateInput, DictAttachmentAttributeUncheckedCreateInput>
    /**
     * In case the DictAttachmentAttribute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DictAttachmentAttributeUpdateInput, DictAttachmentAttributeUncheckedUpdateInput>
  }

  /**
   * DictAttachmentAttribute delete
   */
  export type DictAttachmentAttributeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictAttachmentAttribute
     */
    select?: DictAttachmentAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictAttachmentAttributeInclude<ExtArgs> | null
    /**
     * Filter which DictAttachmentAttribute to delete.
     */
    where: DictAttachmentAttributeWhereUniqueInput
  }

  /**
   * DictAttachmentAttribute deleteMany
   */
  export type DictAttachmentAttributeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DictAttachmentAttributes to delete
     */
    where?: DictAttachmentAttributeWhereInput
  }

  /**
   * DictAttachmentAttribute.AttachmentAttribute
   */
  export type DictAttachmentAttribute$AttachmentAttributeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttachmentAttribute
     */
    select?: AttachmentAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentAttributeInclude<ExtArgs> | null
    where?: AttachmentAttributeWhereInput
    orderBy?: AttachmentAttributeOrderByWithRelationInput | AttachmentAttributeOrderByWithRelationInput[]
    cursor?: AttachmentAttributeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentAttributeScalarFieldEnum | AttachmentAttributeScalarFieldEnum[]
  }

  /**
   * DictAttachmentAttribute without action
   */
  export type DictAttachmentAttributeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictAttachmentAttribute
     */
    select?: DictAttachmentAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictAttachmentAttributeInclude<ExtArgs> | null
  }


  /**
   * Model AttachmentAttribute
   */

  export type AggregateAttachmentAttribute = {
    _count: AttachmentAttributeCountAggregateOutputType | null
    _avg: AttachmentAttributeAvgAggregateOutputType | null
    _sum: AttachmentAttributeSumAggregateOutputType | null
    _min: AttachmentAttributeMinAggregateOutputType | null
    _max: AttachmentAttributeMaxAggregateOutputType | null
  }

  export type AttachmentAttributeAvgAggregateOutputType = {
    attachmentId: number | null
    attributeId: number | null
  }

  export type AttachmentAttributeSumAggregateOutputType = {
    attachmentId: number | null
    attributeId: number | null
  }

  export type AttachmentAttributeMinAggregateOutputType = {
    attachmentId: number | null
    attributeId: number | null
    value: string | null
    desc: string | null
  }

  export type AttachmentAttributeMaxAggregateOutputType = {
    attachmentId: number | null
    attributeId: number | null
    value: string | null
    desc: string | null
  }

  export type AttachmentAttributeCountAggregateOutputType = {
    attachmentId: number
    attributeId: number
    value: number
    desc: number
    _all: number
  }


  export type AttachmentAttributeAvgAggregateInputType = {
    attachmentId?: true
    attributeId?: true
  }

  export type AttachmentAttributeSumAggregateInputType = {
    attachmentId?: true
    attributeId?: true
  }

  export type AttachmentAttributeMinAggregateInputType = {
    attachmentId?: true
    attributeId?: true
    value?: true
    desc?: true
  }

  export type AttachmentAttributeMaxAggregateInputType = {
    attachmentId?: true
    attributeId?: true
    value?: true
    desc?: true
  }

  export type AttachmentAttributeCountAggregateInputType = {
    attachmentId?: true
    attributeId?: true
    value?: true
    desc?: true
    _all?: true
  }

  export type AttachmentAttributeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttachmentAttribute to aggregate.
     */
    where?: AttachmentAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttachmentAttributes to fetch.
     */
    orderBy?: AttachmentAttributeOrderByWithRelationInput | AttachmentAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttachmentAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttachmentAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttachmentAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttachmentAttributes
    **/
    _count?: true | AttachmentAttributeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttachmentAttributeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttachmentAttributeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttachmentAttributeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttachmentAttributeMaxAggregateInputType
  }

  export type GetAttachmentAttributeAggregateType<T extends AttachmentAttributeAggregateArgs> = {
        [P in keyof T & keyof AggregateAttachmentAttribute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttachmentAttribute[P]>
      : GetScalarType<T[P], AggregateAttachmentAttribute[P]>
  }




  export type AttachmentAttributeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentAttributeWhereInput
    orderBy?: AttachmentAttributeOrderByWithAggregationInput | AttachmentAttributeOrderByWithAggregationInput[]
    by: AttachmentAttributeScalarFieldEnum[] | AttachmentAttributeScalarFieldEnum
    having?: AttachmentAttributeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttachmentAttributeCountAggregateInputType | true
    _avg?: AttachmentAttributeAvgAggregateInputType
    _sum?: AttachmentAttributeSumAggregateInputType
    _min?: AttachmentAttributeMinAggregateInputType
    _max?: AttachmentAttributeMaxAggregateInputType
  }

  export type AttachmentAttributeGroupByOutputType = {
    attachmentId: number
    attributeId: number
    value: string
    desc: string | null
    _count: AttachmentAttributeCountAggregateOutputType | null
    _avg: AttachmentAttributeAvgAggregateOutputType | null
    _sum: AttachmentAttributeSumAggregateOutputType | null
    _min: AttachmentAttributeMinAggregateOutputType | null
    _max: AttachmentAttributeMaxAggregateOutputType | null
  }

  type GetAttachmentAttributeGroupByPayload<T extends AttachmentAttributeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttachmentAttributeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttachmentAttributeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttachmentAttributeGroupByOutputType[P]>
            : GetScalarType<T[P], AttachmentAttributeGroupByOutputType[P]>
        }
      >
    >


  export type AttachmentAttributeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    attachmentId?: boolean
    attributeId?: boolean
    value?: boolean
    desc?: boolean
    Attachment?: boolean | AttachmentDefaultArgs<ExtArgs>
    DictAttribute?: boolean | DictAttachmentAttributeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachmentAttribute"]>

  export type AttachmentAttributeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    attachmentId?: boolean
    attributeId?: boolean
    value?: boolean
    desc?: boolean
    Attachment?: boolean | AttachmentDefaultArgs<ExtArgs>
    DictAttribute?: boolean | DictAttachmentAttributeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachmentAttribute"]>

  export type AttachmentAttributeSelectScalar = {
    attachmentId?: boolean
    attributeId?: boolean
    value?: boolean
    desc?: boolean
  }

  export type AttachmentAttributeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Attachment?: boolean | AttachmentDefaultArgs<ExtArgs>
    DictAttribute?: boolean | DictAttachmentAttributeDefaultArgs<ExtArgs>
  }
  export type AttachmentAttributeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Attachment?: boolean | AttachmentDefaultArgs<ExtArgs>
    DictAttribute?: boolean | DictAttachmentAttributeDefaultArgs<ExtArgs>
  }

  export type $AttachmentAttributePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttachmentAttribute"
    objects: {
      Attachment: Prisma.$AttachmentPayload<ExtArgs>
      DictAttribute: Prisma.$DictAttachmentAttributePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      attachmentId: number
      attributeId: number
      value: string
      desc: string | null
    }, ExtArgs["result"]["attachmentAttribute"]>
    composites: {}
  }

  type AttachmentAttributeGetPayload<S extends boolean | null | undefined | AttachmentAttributeDefaultArgs> = $Result.GetResult<Prisma.$AttachmentAttributePayload, S>

  type AttachmentAttributeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AttachmentAttributeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AttachmentAttributeCountAggregateInputType | true
    }

  export interface AttachmentAttributeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttachmentAttribute'], meta: { name: 'AttachmentAttribute' } }
    /**
     * Find zero or one AttachmentAttribute that matches the filter.
     * @param {AttachmentAttributeFindUniqueArgs} args - Arguments to find a AttachmentAttribute
     * @example
     * // Get one AttachmentAttribute
     * const attachmentAttribute = await prisma.attachmentAttribute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttachmentAttributeFindUniqueArgs>(args: SelectSubset<T, AttachmentAttributeFindUniqueArgs<ExtArgs>>): Prisma__AttachmentAttributeClient<$Result.GetResult<Prisma.$AttachmentAttributePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AttachmentAttribute that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AttachmentAttributeFindUniqueOrThrowArgs} args - Arguments to find a AttachmentAttribute
     * @example
     * // Get one AttachmentAttribute
     * const attachmentAttribute = await prisma.attachmentAttribute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttachmentAttributeFindUniqueOrThrowArgs>(args: SelectSubset<T, AttachmentAttributeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttachmentAttributeClient<$Result.GetResult<Prisma.$AttachmentAttributePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AttachmentAttribute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentAttributeFindFirstArgs} args - Arguments to find a AttachmentAttribute
     * @example
     * // Get one AttachmentAttribute
     * const attachmentAttribute = await prisma.attachmentAttribute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttachmentAttributeFindFirstArgs>(args?: SelectSubset<T, AttachmentAttributeFindFirstArgs<ExtArgs>>): Prisma__AttachmentAttributeClient<$Result.GetResult<Prisma.$AttachmentAttributePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AttachmentAttribute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentAttributeFindFirstOrThrowArgs} args - Arguments to find a AttachmentAttribute
     * @example
     * // Get one AttachmentAttribute
     * const attachmentAttribute = await prisma.attachmentAttribute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttachmentAttributeFindFirstOrThrowArgs>(args?: SelectSubset<T, AttachmentAttributeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttachmentAttributeClient<$Result.GetResult<Prisma.$AttachmentAttributePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AttachmentAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentAttributeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttachmentAttributes
     * const attachmentAttributes = await prisma.attachmentAttribute.findMany()
     * 
     * // Get first 10 AttachmentAttributes
     * const attachmentAttributes = await prisma.attachmentAttribute.findMany({ take: 10 })
     * 
     * // Only select the `attachmentId`
     * const attachmentAttributeWithAttachmentIdOnly = await prisma.attachmentAttribute.findMany({ select: { attachmentId: true } })
     * 
     */
    findMany<T extends AttachmentAttributeFindManyArgs>(args?: SelectSubset<T, AttachmentAttributeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentAttributePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AttachmentAttribute.
     * @param {AttachmentAttributeCreateArgs} args - Arguments to create a AttachmentAttribute.
     * @example
     * // Create one AttachmentAttribute
     * const AttachmentAttribute = await prisma.attachmentAttribute.create({
     *   data: {
     *     // ... data to create a AttachmentAttribute
     *   }
     * })
     * 
     */
    create<T extends AttachmentAttributeCreateArgs>(args: SelectSubset<T, AttachmentAttributeCreateArgs<ExtArgs>>): Prisma__AttachmentAttributeClient<$Result.GetResult<Prisma.$AttachmentAttributePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AttachmentAttributes.
     * @param {AttachmentAttributeCreateManyArgs} args - Arguments to create many AttachmentAttributes.
     * @example
     * // Create many AttachmentAttributes
     * const attachmentAttribute = await prisma.attachmentAttribute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttachmentAttributeCreateManyArgs>(args?: SelectSubset<T, AttachmentAttributeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttachmentAttributes and returns the data saved in the database.
     * @param {AttachmentAttributeCreateManyAndReturnArgs} args - Arguments to create many AttachmentAttributes.
     * @example
     * // Create many AttachmentAttributes
     * const attachmentAttribute = await prisma.attachmentAttribute.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttachmentAttributes and only return the `attachmentId`
     * const attachmentAttributeWithAttachmentIdOnly = await prisma.attachmentAttribute.createManyAndReturn({ 
     *   select: { attachmentId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttachmentAttributeCreateManyAndReturnArgs>(args?: SelectSubset<T, AttachmentAttributeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentAttributePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AttachmentAttribute.
     * @param {AttachmentAttributeDeleteArgs} args - Arguments to delete one AttachmentAttribute.
     * @example
     * // Delete one AttachmentAttribute
     * const AttachmentAttribute = await prisma.attachmentAttribute.delete({
     *   where: {
     *     // ... filter to delete one AttachmentAttribute
     *   }
     * })
     * 
     */
    delete<T extends AttachmentAttributeDeleteArgs>(args: SelectSubset<T, AttachmentAttributeDeleteArgs<ExtArgs>>): Prisma__AttachmentAttributeClient<$Result.GetResult<Prisma.$AttachmentAttributePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AttachmentAttribute.
     * @param {AttachmentAttributeUpdateArgs} args - Arguments to update one AttachmentAttribute.
     * @example
     * // Update one AttachmentAttribute
     * const attachmentAttribute = await prisma.attachmentAttribute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttachmentAttributeUpdateArgs>(args: SelectSubset<T, AttachmentAttributeUpdateArgs<ExtArgs>>): Prisma__AttachmentAttributeClient<$Result.GetResult<Prisma.$AttachmentAttributePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AttachmentAttributes.
     * @param {AttachmentAttributeDeleteManyArgs} args - Arguments to filter AttachmentAttributes to delete.
     * @example
     * // Delete a few AttachmentAttributes
     * const { count } = await prisma.attachmentAttribute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttachmentAttributeDeleteManyArgs>(args?: SelectSubset<T, AttachmentAttributeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttachmentAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentAttributeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttachmentAttributes
     * const attachmentAttribute = await prisma.attachmentAttribute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttachmentAttributeUpdateManyArgs>(args: SelectSubset<T, AttachmentAttributeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AttachmentAttribute.
     * @param {AttachmentAttributeUpsertArgs} args - Arguments to update or create a AttachmentAttribute.
     * @example
     * // Update or create a AttachmentAttribute
     * const attachmentAttribute = await prisma.attachmentAttribute.upsert({
     *   create: {
     *     // ... data to create a AttachmentAttribute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttachmentAttribute we want to update
     *   }
     * })
     */
    upsert<T extends AttachmentAttributeUpsertArgs>(args: SelectSubset<T, AttachmentAttributeUpsertArgs<ExtArgs>>): Prisma__AttachmentAttributeClient<$Result.GetResult<Prisma.$AttachmentAttributePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AttachmentAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentAttributeCountArgs} args - Arguments to filter AttachmentAttributes to count.
     * @example
     * // Count the number of AttachmentAttributes
     * const count = await prisma.attachmentAttribute.count({
     *   where: {
     *     // ... the filter for the AttachmentAttributes we want to count
     *   }
     * })
    **/
    count<T extends AttachmentAttributeCountArgs>(
      args?: Subset<T, AttachmentAttributeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttachmentAttributeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttachmentAttribute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentAttributeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttachmentAttributeAggregateArgs>(args: Subset<T, AttachmentAttributeAggregateArgs>): Prisma.PrismaPromise<GetAttachmentAttributeAggregateType<T>>

    /**
     * Group by AttachmentAttribute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentAttributeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttachmentAttributeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttachmentAttributeGroupByArgs['orderBy'] }
        : { orderBy?: AttachmentAttributeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttachmentAttributeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttachmentAttributeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttachmentAttribute model
   */
  readonly fields: AttachmentAttributeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttachmentAttribute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttachmentAttributeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Attachment<T extends AttachmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AttachmentDefaultArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    DictAttribute<T extends DictAttachmentAttributeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DictAttachmentAttributeDefaultArgs<ExtArgs>>): Prisma__DictAttachmentAttributeClient<$Result.GetResult<Prisma.$DictAttachmentAttributePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttachmentAttribute model
   */ 
  interface AttachmentAttributeFieldRefs {
    readonly attachmentId: FieldRef<"AttachmentAttribute", 'Int'>
    readonly attributeId: FieldRef<"AttachmentAttribute", 'Int'>
    readonly value: FieldRef<"AttachmentAttribute", 'String'>
    readonly desc: FieldRef<"AttachmentAttribute", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AttachmentAttribute findUnique
   */
  export type AttachmentAttributeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttachmentAttribute
     */
    select?: AttachmentAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentAttributeInclude<ExtArgs> | null
    /**
     * Filter, which AttachmentAttribute to fetch.
     */
    where: AttachmentAttributeWhereUniqueInput
  }

  /**
   * AttachmentAttribute findUniqueOrThrow
   */
  export type AttachmentAttributeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttachmentAttribute
     */
    select?: AttachmentAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentAttributeInclude<ExtArgs> | null
    /**
     * Filter, which AttachmentAttribute to fetch.
     */
    where: AttachmentAttributeWhereUniqueInput
  }

  /**
   * AttachmentAttribute findFirst
   */
  export type AttachmentAttributeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttachmentAttribute
     */
    select?: AttachmentAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentAttributeInclude<ExtArgs> | null
    /**
     * Filter, which AttachmentAttribute to fetch.
     */
    where?: AttachmentAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttachmentAttributes to fetch.
     */
    orderBy?: AttachmentAttributeOrderByWithRelationInput | AttachmentAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttachmentAttributes.
     */
    cursor?: AttachmentAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttachmentAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttachmentAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttachmentAttributes.
     */
    distinct?: AttachmentAttributeScalarFieldEnum | AttachmentAttributeScalarFieldEnum[]
  }

  /**
   * AttachmentAttribute findFirstOrThrow
   */
  export type AttachmentAttributeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttachmentAttribute
     */
    select?: AttachmentAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentAttributeInclude<ExtArgs> | null
    /**
     * Filter, which AttachmentAttribute to fetch.
     */
    where?: AttachmentAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttachmentAttributes to fetch.
     */
    orderBy?: AttachmentAttributeOrderByWithRelationInput | AttachmentAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttachmentAttributes.
     */
    cursor?: AttachmentAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttachmentAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttachmentAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttachmentAttributes.
     */
    distinct?: AttachmentAttributeScalarFieldEnum | AttachmentAttributeScalarFieldEnum[]
  }

  /**
   * AttachmentAttribute findMany
   */
  export type AttachmentAttributeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttachmentAttribute
     */
    select?: AttachmentAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentAttributeInclude<ExtArgs> | null
    /**
     * Filter, which AttachmentAttributes to fetch.
     */
    where?: AttachmentAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttachmentAttributes to fetch.
     */
    orderBy?: AttachmentAttributeOrderByWithRelationInput | AttachmentAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttachmentAttributes.
     */
    cursor?: AttachmentAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttachmentAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttachmentAttributes.
     */
    skip?: number
    distinct?: AttachmentAttributeScalarFieldEnum | AttachmentAttributeScalarFieldEnum[]
  }

  /**
   * AttachmentAttribute create
   */
  export type AttachmentAttributeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttachmentAttribute
     */
    select?: AttachmentAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentAttributeInclude<ExtArgs> | null
    /**
     * The data needed to create a AttachmentAttribute.
     */
    data: XOR<AttachmentAttributeCreateInput, AttachmentAttributeUncheckedCreateInput>
  }

  /**
   * AttachmentAttribute createMany
   */
  export type AttachmentAttributeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttachmentAttributes.
     */
    data: AttachmentAttributeCreateManyInput | AttachmentAttributeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttachmentAttribute createManyAndReturn
   */
  export type AttachmentAttributeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttachmentAttribute
     */
    select?: AttachmentAttributeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AttachmentAttributes.
     */
    data: AttachmentAttributeCreateManyInput | AttachmentAttributeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentAttributeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttachmentAttribute update
   */
  export type AttachmentAttributeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttachmentAttribute
     */
    select?: AttachmentAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentAttributeInclude<ExtArgs> | null
    /**
     * The data needed to update a AttachmentAttribute.
     */
    data: XOR<AttachmentAttributeUpdateInput, AttachmentAttributeUncheckedUpdateInput>
    /**
     * Choose, which AttachmentAttribute to update.
     */
    where: AttachmentAttributeWhereUniqueInput
  }

  /**
   * AttachmentAttribute updateMany
   */
  export type AttachmentAttributeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttachmentAttributes.
     */
    data: XOR<AttachmentAttributeUpdateManyMutationInput, AttachmentAttributeUncheckedUpdateManyInput>
    /**
     * Filter which AttachmentAttributes to update
     */
    where?: AttachmentAttributeWhereInput
  }

  /**
   * AttachmentAttribute upsert
   */
  export type AttachmentAttributeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttachmentAttribute
     */
    select?: AttachmentAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentAttributeInclude<ExtArgs> | null
    /**
     * The filter to search for the AttachmentAttribute to update in case it exists.
     */
    where: AttachmentAttributeWhereUniqueInput
    /**
     * In case the AttachmentAttribute found by the `where` argument doesn't exist, create a new AttachmentAttribute with this data.
     */
    create: XOR<AttachmentAttributeCreateInput, AttachmentAttributeUncheckedCreateInput>
    /**
     * In case the AttachmentAttribute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttachmentAttributeUpdateInput, AttachmentAttributeUncheckedUpdateInput>
  }

  /**
   * AttachmentAttribute delete
   */
  export type AttachmentAttributeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttachmentAttribute
     */
    select?: AttachmentAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentAttributeInclude<ExtArgs> | null
    /**
     * Filter which AttachmentAttribute to delete.
     */
    where: AttachmentAttributeWhereUniqueInput
  }

  /**
   * AttachmentAttribute deleteMany
   */
  export type AttachmentAttributeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttachmentAttributes to delete
     */
    where?: AttachmentAttributeWhereInput
  }

  /**
   * AttachmentAttribute without action
   */
  export type AttachmentAttributeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttachmentAttribute
     */
    select?: AttachmentAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentAttributeInclude<ExtArgs> | null
  }


  /**
   * Model Attachment
   */

  export type AggregateAttachment = {
    _count: AttachmentCountAggregateOutputType | null
    _avg: AttachmentAvgAggregateOutputType | null
    _sum: AttachmentSumAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  export type AttachmentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    status: number | null
  }

  export type AttachmentSumAggregateOutputType = {
    id: number | null
    userId: number | null
    status: number | null
  }

  export type AttachmentMinAggregateOutputType = {
    id: number | null
    type: string | null
    location: string | null
    name: string | null
    ossType: string | null
    userId: number | null
    status: number | null
    desc: string | null
    createdAt: Date | null
  }

  export type AttachmentMaxAggregateOutputType = {
    id: number | null
    type: string | null
    location: string | null
    name: string | null
    ossType: string | null
    userId: number | null
    status: number | null
    desc: string | null
    createdAt: Date | null
  }

  export type AttachmentCountAggregateOutputType = {
    id: number
    type: number
    location: number
    name: number
    ossType: number
    userId: number
    status: number
    desc: number
    createdAt: number
    _all: number
  }


  export type AttachmentAvgAggregateInputType = {
    id?: true
    userId?: true
    status?: true
  }

  export type AttachmentSumAggregateInputType = {
    id?: true
    userId?: true
    status?: true
  }

  export type AttachmentMinAggregateInputType = {
    id?: true
    type?: true
    location?: true
    name?: true
    ossType?: true
    userId?: true
    status?: true
    desc?: true
    createdAt?: true
  }

  export type AttachmentMaxAggregateInputType = {
    id?: true
    type?: true
    location?: true
    name?: true
    ossType?: true
    userId?: true
    status?: true
    desc?: true
    createdAt?: true
  }

  export type AttachmentCountAggregateInputType = {
    id?: true
    type?: true
    location?: true
    name?: true
    ossType?: true
    userId?: true
    status?: true
    desc?: true
    createdAt?: true
    _all?: true
  }

  export type AttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachment to aggregate.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attachments
    **/
    _count?: true | AttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttachmentMaxAggregateInputType
  }

  export type GetAttachmentAggregateType<T extends AttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttachment[P]>
      : GetScalarType<T[P], AggregateAttachment[P]>
  }




  export type AttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithAggregationInput | AttachmentOrderByWithAggregationInput[]
    by: AttachmentScalarFieldEnum[] | AttachmentScalarFieldEnum
    having?: AttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttachmentCountAggregateInputType | true
    _avg?: AttachmentAvgAggregateInputType
    _sum?: AttachmentSumAggregateInputType
    _min?: AttachmentMinAggregateInputType
    _max?: AttachmentMaxAggregateInputType
  }

  export type AttachmentGroupByOutputType = {
    id: number
    type: string
    location: string
    name: string | null
    ossType: string | null
    userId: number
    status: number
    desc: string | null
    createdAt: Date | null
    _count: AttachmentCountAggregateOutputType | null
    _avg: AttachmentAvgAggregateOutputType | null
    _sum: AttachmentSumAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  type GetAttachmentGroupByPayload<T extends AttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
        }
      >
    >


  export type AttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    location?: boolean
    name?: boolean
    ossType?: boolean
    userId?: boolean
    status?: boolean
    desc?: boolean
    createdAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    AttachmentAttribute?: boolean | Attachment$AttachmentAttributeArgs<ExtArgs>
    Course?: boolean | Attachment$CourseArgs<ExtArgs>
    ContentAttachment?: boolean | Attachment$ContentAttachmentArgs<ExtArgs>
    _count?: boolean | AttachmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    location?: boolean
    name?: boolean
    ossType?: boolean
    userId?: boolean
    status?: boolean
    desc?: boolean
    createdAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectScalar = {
    id?: boolean
    type?: boolean
    location?: boolean
    name?: boolean
    ossType?: boolean
    userId?: boolean
    status?: boolean
    desc?: boolean
    createdAt?: boolean
  }

  export type AttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    AttachmentAttribute?: boolean | Attachment$AttachmentAttributeArgs<ExtArgs>
    Course?: boolean | Attachment$CourseArgs<ExtArgs>
    ContentAttachment?: boolean | Attachment$ContentAttachmentArgs<ExtArgs>
    _count?: boolean | AttachmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attachment"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      AttachmentAttribute: Prisma.$AttachmentAttributePayload<ExtArgs>[]
      Course: Prisma.$CoursePayload<ExtArgs>[]
      ContentAttachment: Prisma.$ContentAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      location: string
      name: string | null
      ossType: string | null
      userId: number
      status: number
      desc: string | null
      createdAt: Date | null
    }, ExtArgs["result"]["attachment"]>
    composites: {}
  }

  type AttachmentGetPayload<S extends boolean | null | undefined | AttachmentDefaultArgs> = $Result.GetResult<Prisma.$AttachmentPayload, S>

  type AttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AttachmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AttachmentCountAggregateInputType | true
    }

  export interface AttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attachment'], meta: { name: 'Attachment' } }
    /**
     * Find zero or one Attachment that matches the filter.
     * @param {AttachmentFindUniqueArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttachmentFindUniqueArgs>(args: SelectSubset<T, AttachmentFindUniqueArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Attachment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AttachmentFindUniqueOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Attachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttachmentFindFirstArgs>(args?: SelectSubset<T, AttachmentFindFirstArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Attachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attachments
     * const attachments = await prisma.attachment.findMany()
     * 
     * // Get first 10 Attachments
     * const attachments = await prisma.attachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attachmentWithIdOnly = await prisma.attachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttachmentFindManyArgs>(args?: SelectSubset<T, AttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Attachment.
     * @param {AttachmentCreateArgs} args - Arguments to create a Attachment.
     * @example
     * // Create one Attachment
     * const Attachment = await prisma.attachment.create({
     *   data: {
     *     // ... data to create a Attachment
     *   }
     * })
     * 
     */
    create<T extends AttachmentCreateArgs>(args: SelectSubset<T, AttachmentCreateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Attachments.
     * @param {AttachmentCreateManyArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttachmentCreateManyArgs>(args?: SelectSubset<T, AttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attachments and returns the data saved in the database.
     * @param {AttachmentCreateManyAndReturnArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Attachment.
     * @param {AttachmentDeleteArgs} args - Arguments to delete one Attachment.
     * @example
     * // Delete one Attachment
     * const Attachment = await prisma.attachment.delete({
     *   where: {
     *     // ... filter to delete one Attachment
     *   }
     * })
     * 
     */
    delete<T extends AttachmentDeleteArgs>(args: SelectSubset<T, AttachmentDeleteArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Attachment.
     * @param {AttachmentUpdateArgs} args - Arguments to update one Attachment.
     * @example
     * // Update one Attachment
     * const attachment = await prisma.attachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttachmentUpdateArgs>(args: SelectSubset<T, AttachmentUpdateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Attachments.
     * @param {AttachmentDeleteManyArgs} args - Arguments to filter Attachments to delete.
     * @example
     * // Delete a few Attachments
     * const { count } = await prisma.attachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttachmentDeleteManyArgs>(args?: SelectSubset<T, AttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttachmentUpdateManyArgs>(args: SelectSubset<T, AttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attachment.
     * @param {AttachmentUpsertArgs} args - Arguments to update or create a Attachment.
     * @example
     * // Update or create a Attachment
     * const attachment = await prisma.attachment.upsert({
     *   create: {
     *     // ... data to create a Attachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attachment we want to update
     *   }
     * })
     */
    upsert<T extends AttachmentUpsertArgs>(args: SelectSubset<T, AttachmentUpsertArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentCountArgs} args - Arguments to filter Attachments to count.
     * @example
     * // Count the number of Attachments
     * const count = await prisma.attachment.count({
     *   where: {
     *     // ... the filter for the Attachments we want to count
     *   }
     * })
    **/
    count<T extends AttachmentCountArgs>(
      args?: Subset<T, AttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttachmentAggregateArgs>(args: Subset<T, AttachmentAggregateArgs>): Prisma.PrismaPromise<GetAttachmentAggregateType<T>>

    /**
     * Group by Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttachmentGroupByArgs['orderBy'] }
        : { orderBy?: AttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attachment model
   */
  readonly fields: AttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    AttachmentAttribute<T extends Attachment$AttachmentAttributeArgs<ExtArgs> = {}>(args?: Subset<T, Attachment$AttachmentAttributeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentAttributePayload<ExtArgs>, T, "findMany"> | Null>
    Course<T extends Attachment$CourseArgs<ExtArgs> = {}>(args?: Subset<T, Attachment$CourseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany"> | Null>
    ContentAttachment<T extends Attachment$ContentAttachmentArgs<ExtArgs> = {}>(args?: Subset<T, Attachment$ContentAttachmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentAttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attachment model
   */ 
  interface AttachmentFieldRefs {
    readonly id: FieldRef<"Attachment", 'Int'>
    readonly type: FieldRef<"Attachment", 'String'>
    readonly location: FieldRef<"Attachment", 'String'>
    readonly name: FieldRef<"Attachment", 'String'>
    readonly ossType: FieldRef<"Attachment", 'String'>
    readonly userId: FieldRef<"Attachment", 'Int'>
    readonly status: FieldRef<"Attachment", 'Int'>
    readonly desc: FieldRef<"Attachment", 'String'>
    readonly createdAt: FieldRef<"Attachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attachment findUnique
   */
  export type AttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findUniqueOrThrow
   */
  export type AttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findFirst
   */
  export type AttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findFirstOrThrow
   */
  export type AttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findMany
   */
  export type AttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachments to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment create
   */
  export type AttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Attachment.
     */
    data: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
  }

  /**
   * Attachment createMany
   */
  export type AttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attachment createManyAndReturn
   */
  export type AttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attachment update
   */
  export type AttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Attachment.
     */
    data: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
    /**
     * Choose, which Attachment to update.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment updateMany
   */
  export type AttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
  }

  /**
   * Attachment upsert
   */
  export type AttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Attachment to update in case it exists.
     */
    where: AttachmentWhereUniqueInput
    /**
     * In case the Attachment found by the `where` argument doesn't exist, create a new Attachment with this data.
     */
    create: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
    /**
     * In case the Attachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
  }

  /**
   * Attachment delete
   */
  export type AttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter which Attachment to delete.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment deleteMany
   */
  export type AttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachments to delete
     */
    where?: AttachmentWhereInput
  }

  /**
   * Attachment.AttachmentAttribute
   */
  export type Attachment$AttachmentAttributeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttachmentAttribute
     */
    select?: AttachmentAttributeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentAttributeInclude<ExtArgs> | null
    where?: AttachmentAttributeWhereInput
    orderBy?: AttachmentAttributeOrderByWithRelationInput | AttachmentAttributeOrderByWithRelationInput[]
    cursor?: AttachmentAttributeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentAttributeScalarFieldEnum | AttachmentAttributeScalarFieldEnum[]
  }

  /**
   * Attachment.Course
   */
  export type Attachment$CourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Attachment.ContentAttachment
   */
  export type Attachment$ContentAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentAttachment
     */
    select?: ContentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentAttachmentInclude<ExtArgs> | null
    where?: ContentAttachmentWhereInput
    orderBy?: ContentAttachmentOrderByWithRelationInput | ContentAttachmentOrderByWithRelationInput[]
    cursor?: ContentAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentAttachmentScalarFieldEnum | ContentAttachmentScalarFieldEnum[]
  }

  /**
   * Attachment without action
   */
  export type AttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    id: number | null
    coverId: number | null
    authorId: number | null
    originPrice: number | null
    price: number | null
    status: number | null
    counts: number | null
    order: number | null
  }

  export type CourseSumAggregateOutputType = {
    id: number | null
    coverId: number | null
    authorId: number | null
    originPrice: number | null
    price: number | null
    status: number | null
    counts: number | null
    order: number | null
  }

  export type CourseMinAggregateOutputType = {
    id: number | null
    title: string | null
    subTitle: string | null
    desc: string | null
    coverId: number | null
    authorId: number | null
    originPrice: number | null
    price: number | null
    status: number | null
    counts: number | null
    order: number | null
    detail: string | null
    type: string | null
  }

  export type CourseMaxAggregateOutputType = {
    id: number | null
    title: string | null
    subTitle: string | null
    desc: string | null
    coverId: number | null
    authorId: number | null
    originPrice: number | null
    price: number | null
    status: number | null
    counts: number | null
    order: number | null
    detail: string | null
    type: string | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    title: number
    subTitle: number
    desc: number
    coverId: number
    authorId: number
    originPrice: number
    price: number
    status: number
    counts: number
    order: number
    detail: number
    type: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    id?: true
    coverId?: true
    authorId?: true
    originPrice?: true
    price?: true
    status?: true
    counts?: true
    order?: true
  }

  export type CourseSumAggregateInputType = {
    id?: true
    coverId?: true
    authorId?: true
    originPrice?: true
    price?: true
    status?: true
    counts?: true
    order?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    title?: true
    subTitle?: true
    desc?: true
    coverId?: true
    authorId?: true
    originPrice?: true
    price?: true
    status?: true
    counts?: true
    order?: true
    detail?: true
    type?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    title?: true
    subTitle?: true
    desc?: true
    coverId?: true
    authorId?: true
    originPrice?: true
    price?: true
    status?: true
    counts?: true
    order?: true
    detail?: true
    type?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    title?: true
    subTitle?: true
    desc?: true
    coverId?: true
    authorId?: true
    originPrice?: true
    price?: true
    status?: true
    counts?: true
    order?: true
    detail?: true
    type?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: number
    title: string
    subTitle: string | null
    desc: string | null
    coverId: number | null
    authorId: number
    originPrice: number | null
    price: number | null
    status: number
    counts: number
    order: number
    detail: string | null
    type: string | null
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subTitle?: boolean
    desc?: boolean
    coverId?: boolean
    authorId?: boolean
    originPrice?: boolean
    price?: boolean
    status?: boolean
    counts?: boolean
    order?: boolean
    detail?: boolean
    type?: boolean
    Cover?: boolean | Course$CoverArgs<ExtArgs>
    Author?: boolean | UserDefaultArgs<ExtArgs>
    Contents?: boolean | Course$ContentsArgs<ExtArgs>
    Tags?: boolean | Course$TagsArgs<ExtArgs>
    CourseComment?: boolean | Course$CourseCommentArgs<ExtArgs>
    Transaction?: boolean | Course$TransactionArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subTitle?: boolean
    desc?: boolean
    coverId?: boolean
    authorId?: boolean
    originPrice?: boolean
    price?: boolean
    status?: boolean
    counts?: boolean
    order?: boolean
    detail?: boolean
    type?: boolean
    Cover?: boolean | Course$CoverArgs<ExtArgs>
    Author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    title?: boolean
    subTitle?: boolean
    desc?: boolean
    coverId?: boolean
    authorId?: boolean
    originPrice?: boolean
    price?: boolean
    status?: boolean
    counts?: boolean
    order?: boolean
    detail?: boolean
    type?: boolean
  }

  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Cover?: boolean | Course$CoverArgs<ExtArgs>
    Author?: boolean | UserDefaultArgs<ExtArgs>
    Contents?: boolean | Course$ContentsArgs<ExtArgs>
    Tags?: boolean | Course$TagsArgs<ExtArgs>
    CourseComment?: boolean | Course$CourseCommentArgs<ExtArgs>
    Transaction?: boolean | Course$TransactionArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Cover?: boolean | Course$CoverArgs<ExtArgs>
    Author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      Cover: Prisma.$AttachmentPayload<ExtArgs> | null
      Author: Prisma.$UserPayload<ExtArgs>
      Contents: Prisma.$CourseContentPayload<ExtArgs>[]
      Tags: Prisma.$CourseTagPayload<ExtArgs>[]
      CourseComment: Prisma.$CourseCommentPayload<ExtArgs>[]
      Transaction: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      subTitle: string | null
      desc: string | null
      coverId: number | null
      authorId: number
      originPrice: number | null
      price: number | null
      status: number
      counts: number
      order: number
      detail: string | null
      type: string | null
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Cover<T extends Course$CoverArgs<ExtArgs> = {}>(args?: Subset<T, Course$CoverArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Contents<T extends Course$ContentsArgs<ExtArgs> = {}>(args?: Subset<T, Course$ContentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, "findMany"> | Null>
    Tags<T extends Course$TagsArgs<ExtArgs> = {}>(args?: Subset<T, Course$TagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "findMany"> | Null>
    CourseComment<T extends Course$CourseCommentArgs<ExtArgs> = {}>(args?: Subset<T, Course$CourseCommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseCommentPayload<ExtArgs>, T, "findMany"> | Null>
    Transaction<T extends Course$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, Course$TransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */ 
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'Int'>
    readonly title: FieldRef<"Course", 'String'>
    readonly subTitle: FieldRef<"Course", 'String'>
    readonly desc: FieldRef<"Course", 'String'>
    readonly coverId: FieldRef<"Course", 'Int'>
    readonly authorId: FieldRef<"Course", 'Int'>
    readonly originPrice: FieldRef<"Course", 'Float'>
    readonly price: FieldRef<"Course", 'Float'>
    readonly status: FieldRef<"Course", 'Int'>
    readonly counts: FieldRef<"Course", 'Int'>
    readonly order: FieldRef<"Course", 'Int'>
    readonly detail: FieldRef<"Course", 'String'>
    readonly type: FieldRef<"Course", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
  }

  /**
   * Course.Cover
   */
  export type Course$CoverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
  }

  /**
   * Course.Contents
   */
  export type Course$ContentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContent
     */
    select?: CourseContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseContentInclude<ExtArgs> | null
    where?: CourseContentWhereInput
    orderBy?: CourseContentOrderByWithRelationInput | CourseContentOrderByWithRelationInput[]
    cursor?: CourseContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseContentScalarFieldEnum | CourseContentScalarFieldEnum[]
  }

  /**
   * Course.Tags
   */
  export type Course$TagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    where?: CourseTagWhereInput
    orderBy?: CourseTagOrderByWithRelationInput | CourseTagOrderByWithRelationInput[]
    cursor?: CourseTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseTagScalarFieldEnum | CourseTagScalarFieldEnum[]
  }

  /**
   * Course.CourseComment
   */
  export type Course$CourseCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseComment
     */
    select?: CourseCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCommentInclude<ExtArgs> | null
    where?: CourseCommentWhereInput
    orderBy?: CourseCommentOrderByWithRelationInput | CourseCommentOrderByWithRelationInput[]
    cursor?: CourseCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseCommentScalarFieldEnum | CourseCommentScalarFieldEnum[]
  }

  /**
   * Course.Transaction
   */
  export type Course$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model CourseContent
   */

  export type AggregateCourseContent = {
    _count: CourseContentCountAggregateOutputType | null
    _avg: CourseContentAvgAggregateOutputType | null
    _sum: CourseContentSumAggregateOutputType | null
    _min: CourseContentMinAggregateOutputType | null
    _max: CourseContentMaxAggregateOutputType | null
  }

  export type CourseContentAvgAggregateOutputType = {
    id: number | null
    courseId: number | null
    order: number | null
    pid: number | null
    status: number | null
    authorId: number | null
  }

  export type CourseContentSumAggregateOutputType = {
    id: number | null
    courseId: number | null
    order: number | null
    pid: number | null
    status: number | null
    authorId: number | null
  }

  export type CourseContentMinAggregateOutputType = {
    id: number | null
    courseId: number | null
    title: string | null
    type: string | null
    order: number | null
    pid: number | null
    status: number | null
    authorId: number | null
  }

  export type CourseContentMaxAggregateOutputType = {
    id: number | null
    courseId: number | null
    title: string | null
    type: string | null
    order: number | null
    pid: number | null
    status: number | null
    authorId: number | null
  }

  export type CourseContentCountAggregateOutputType = {
    id: number
    courseId: number
    title: number
    type: number
    order: number
    pid: number
    status: number
    authorId: number
    _all: number
  }


  export type CourseContentAvgAggregateInputType = {
    id?: true
    courseId?: true
    order?: true
    pid?: true
    status?: true
    authorId?: true
  }

  export type CourseContentSumAggregateInputType = {
    id?: true
    courseId?: true
    order?: true
    pid?: true
    status?: true
    authorId?: true
  }

  export type CourseContentMinAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    type?: true
    order?: true
    pid?: true
    status?: true
    authorId?: true
  }

  export type CourseContentMaxAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    type?: true
    order?: true
    pid?: true
    status?: true
    authorId?: true
  }

  export type CourseContentCountAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    type?: true
    order?: true
    pid?: true
    status?: true
    authorId?: true
    _all?: true
  }

  export type CourseContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseContent to aggregate.
     */
    where?: CourseContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseContents to fetch.
     */
    orderBy?: CourseContentOrderByWithRelationInput | CourseContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseContents
    **/
    _count?: true | CourseContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseContentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseContentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseContentMaxAggregateInputType
  }

  export type GetCourseContentAggregateType<T extends CourseContentAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseContent[P]>
      : GetScalarType<T[P], AggregateCourseContent[P]>
  }




  export type CourseContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseContentWhereInput
    orderBy?: CourseContentOrderByWithAggregationInput | CourseContentOrderByWithAggregationInput[]
    by: CourseContentScalarFieldEnum[] | CourseContentScalarFieldEnum
    having?: CourseContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseContentCountAggregateInputType | true
    _avg?: CourseContentAvgAggregateInputType
    _sum?: CourseContentSumAggregateInputType
    _min?: CourseContentMinAggregateInputType
    _max?: CourseContentMaxAggregateInputType
  }

  export type CourseContentGroupByOutputType = {
    id: number
    courseId: number
    title: string
    type: string | null
    order: number
    pid: number | null
    status: number
    authorId: number
    _count: CourseContentCountAggregateOutputType | null
    _avg: CourseContentAvgAggregateOutputType | null
    _sum: CourseContentSumAggregateOutputType | null
    _min: CourseContentMinAggregateOutputType | null
    _max: CourseContentMaxAggregateOutputType | null
  }

  type GetCourseContentGroupByPayload<T extends CourseContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseContentGroupByOutputType[P]>
            : GetScalarType<T[P], CourseContentGroupByOutputType[P]>
        }
      >
    >


  export type CourseContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    type?: boolean
    order?: boolean
    pid?: boolean
    status?: boolean
    authorId?: boolean
    Course?: boolean | CourseDefaultArgs<ExtArgs>
    Author?: boolean | UserDefaultArgs<ExtArgs>
    Attachments?: boolean | CourseContent$AttachmentsArgs<ExtArgs>
    Tags?: boolean | CourseContent$TagsArgs<ExtArgs>
    ContentComment?: boolean | CourseContent$ContentCommentArgs<ExtArgs>
    _count?: boolean | CourseContentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseContent"]>

  export type CourseContentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    type?: boolean
    order?: boolean
    pid?: boolean
    status?: boolean
    authorId?: boolean
    Course?: boolean | CourseDefaultArgs<ExtArgs>
    Author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseContent"]>

  export type CourseContentSelectScalar = {
    id?: boolean
    courseId?: boolean
    title?: boolean
    type?: boolean
    order?: boolean
    pid?: boolean
    status?: boolean
    authorId?: boolean
  }

  export type CourseContentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Course?: boolean | CourseDefaultArgs<ExtArgs>
    Author?: boolean | UserDefaultArgs<ExtArgs>
    Attachments?: boolean | CourseContent$AttachmentsArgs<ExtArgs>
    Tags?: boolean | CourseContent$TagsArgs<ExtArgs>
    ContentComment?: boolean | CourseContent$ContentCommentArgs<ExtArgs>
    _count?: boolean | CourseContentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseContentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Course?: boolean | CourseDefaultArgs<ExtArgs>
    Author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CourseContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseContent"
    objects: {
      Course: Prisma.$CoursePayload<ExtArgs>
      Author: Prisma.$UserPayload<ExtArgs>
      Attachments: Prisma.$ContentAttachmentPayload<ExtArgs>[]
      Tags: Prisma.$ContentTagPayload<ExtArgs>[]
      ContentComment: Prisma.$ContentCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      courseId: number
      title: string
      type: string | null
      order: number
      pid: number | null
      status: number
      authorId: number
    }, ExtArgs["result"]["courseContent"]>
    composites: {}
  }

  type CourseContentGetPayload<S extends boolean | null | undefined | CourseContentDefaultArgs> = $Result.GetResult<Prisma.$CourseContentPayload, S>

  type CourseContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseContentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseContentCountAggregateInputType | true
    }

  export interface CourseContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseContent'], meta: { name: 'CourseContent' } }
    /**
     * Find zero or one CourseContent that matches the filter.
     * @param {CourseContentFindUniqueArgs} args - Arguments to find a CourseContent
     * @example
     * // Get one CourseContent
     * const courseContent = await prisma.courseContent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseContentFindUniqueArgs>(args: SelectSubset<T, CourseContentFindUniqueArgs<ExtArgs>>): Prisma__CourseContentClient<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CourseContent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseContentFindUniqueOrThrowArgs} args - Arguments to find a CourseContent
     * @example
     * // Get one CourseContent
     * const courseContent = await prisma.courseContent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseContentFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseContentClient<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CourseContent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseContentFindFirstArgs} args - Arguments to find a CourseContent
     * @example
     * // Get one CourseContent
     * const courseContent = await prisma.courseContent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseContentFindFirstArgs>(args?: SelectSubset<T, CourseContentFindFirstArgs<ExtArgs>>): Prisma__CourseContentClient<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CourseContent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseContentFindFirstOrThrowArgs} args - Arguments to find a CourseContent
     * @example
     * // Get one CourseContent
     * const courseContent = await prisma.courseContent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseContentFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseContentClient<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CourseContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseContents
     * const courseContents = await prisma.courseContent.findMany()
     * 
     * // Get first 10 CourseContents
     * const courseContents = await prisma.courseContent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseContentWithIdOnly = await prisma.courseContent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseContentFindManyArgs>(args?: SelectSubset<T, CourseContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CourseContent.
     * @param {CourseContentCreateArgs} args - Arguments to create a CourseContent.
     * @example
     * // Create one CourseContent
     * const CourseContent = await prisma.courseContent.create({
     *   data: {
     *     // ... data to create a CourseContent
     *   }
     * })
     * 
     */
    create<T extends CourseContentCreateArgs>(args: SelectSubset<T, CourseContentCreateArgs<ExtArgs>>): Prisma__CourseContentClient<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CourseContents.
     * @param {CourseContentCreateManyArgs} args - Arguments to create many CourseContents.
     * @example
     * // Create many CourseContents
     * const courseContent = await prisma.courseContent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseContentCreateManyArgs>(args?: SelectSubset<T, CourseContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseContents and returns the data saved in the database.
     * @param {CourseContentCreateManyAndReturnArgs} args - Arguments to create many CourseContents.
     * @example
     * // Create many CourseContents
     * const courseContent = await prisma.courseContent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseContents and only return the `id`
     * const courseContentWithIdOnly = await prisma.courseContent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseContentCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseContentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CourseContent.
     * @param {CourseContentDeleteArgs} args - Arguments to delete one CourseContent.
     * @example
     * // Delete one CourseContent
     * const CourseContent = await prisma.courseContent.delete({
     *   where: {
     *     // ... filter to delete one CourseContent
     *   }
     * })
     * 
     */
    delete<T extends CourseContentDeleteArgs>(args: SelectSubset<T, CourseContentDeleteArgs<ExtArgs>>): Prisma__CourseContentClient<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CourseContent.
     * @param {CourseContentUpdateArgs} args - Arguments to update one CourseContent.
     * @example
     * // Update one CourseContent
     * const courseContent = await prisma.courseContent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseContentUpdateArgs>(args: SelectSubset<T, CourseContentUpdateArgs<ExtArgs>>): Prisma__CourseContentClient<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CourseContents.
     * @param {CourseContentDeleteManyArgs} args - Arguments to filter CourseContents to delete.
     * @example
     * // Delete a few CourseContents
     * const { count } = await prisma.courseContent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseContentDeleteManyArgs>(args?: SelectSubset<T, CourseContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseContents
     * const courseContent = await prisma.courseContent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseContentUpdateManyArgs>(args: SelectSubset<T, CourseContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseContent.
     * @param {CourseContentUpsertArgs} args - Arguments to update or create a CourseContent.
     * @example
     * // Update or create a CourseContent
     * const courseContent = await prisma.courseContent.upsert({
     *   create: {
     *     // ... data to create a CourseContent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseContent we want to update
     *   }
     * })
     */
    upsert<T extends CourseContentUpsertArgs>(args: SelectSubset<T, CourseContentUpsertArgs<ExtArgs>>): Prisma__CourseContentClient<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CourseContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseContentCountArgs} args - Arguments to filter CourseContents to count.
     * @example
     * // Count the number of CourseContents
     * const count = await prisma.courseContent.count({
     *   where: {
     *     // ... the filter for the CourseContents we want to count
     *   }
     * })
    **/
    count<T extends CourseContentCountArgs>(
      args?: Subset<T, CourseContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseContentAggregateArgs>(args: Subset<T, CourseContentAggregateArgs>): Prisma.PrismaPromise<GetCourseContentAggregateType<T>>

    /**
     * Group by CourseContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseContentGroupByArgs['orderBy'] }
        : { orderBy?: CourseContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseContent model
   */
  readonly fields: CourseContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseContent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Attachments<T extends CourseContent$AttachmentsArgs<ExtArgs> = {}>(args?: Subset<T, CourseContent$AttachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentAttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    Tags<T extends CourseContent$TagsArgs<ExtArgs> = {}>(args?: Subset<T, CourseContent$TagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentTagPayload<ExtArgs>, T, "findMany"> | Null>
    ContentComment<T extends CourseContent$ContentCommentArgs<ExtArgs> = {}>(args?: Subset<T, CourseContent$ContentCommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentCommentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseContent model
   */ 
  interface CourseContentFieldRefs {
    readonly id: FieldRef<"CourseContent", 'Int'>
    readonly courseId: FieldRef<"CourseContent", 'Int'>
    readonly title: FieldRef<"CourseContent", 'String'>
    readonly type: FieldRef<"CourseContent", 'String'>
    readonly order: FieldRef<"CourseContent", 'Int'>
    readonly pid: FieldRef<"CourseContent", 'Int'>
    readonly status: FieldRef<"CourseContent", 'Int'>
    readonly authorId: FieldRef<"CourseContent", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CourseContent findUnique
   */
  export type CourseContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContent
     */
    select?: CourseContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseContentInclude<ExtArgs> | null
    /**
     * Filter, which CourseContent to fetch.
     */
    where: CourseContentWhereUniqueInput
  }

  /**
   * CourseContent findUniqueOrThrow
   */
  export type CourseContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContent
     */
    select?: CourseContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseContentInclude<ExtArgs> | null
    /**
     * Filter, which CourseContent to fetch.
     */
    where: CourseContentWhereUniqueInput
  }

  /**
   * CourseContent findFirst
   */
  export type CourseContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContent
     */
    select?: CourseContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseContentInclude<ExtArgs> | null
    /**
     * Filter, which CourseContent to fetch.
     */
    where?: CourseContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseContents to fetch.
     */
    orderBy?: CourseContentOrderByWithRelationInput | CourseContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseContents.
     */
    cursor?: CourseContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseContents.
     */
    distinct?: CourseContentScalarFieldEnum | CourseContentScalarFieldEnum[]
  }

  /**
   * CourseContent findFirstOrThrow
   */
  export type CourseContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContent
     */
    select?: CourseContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseContentInclude<ExtArgs> | null
    /**
     * Filter, which CourseContent to fetch.
     */
    where?: CourseContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseContents to fetch.
     */
    orderBy?: CourseContentOrderByWithRelationInput | CourseContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseContents.
     */
    cursor?: CourseContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseContents.
     */
    distinct?: CourseContentScalarFieldEnum | CourseContentScalarFieldEnum[]
  }

  /**
   * CourseContent findMany
   */
  export type CourseContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContent
     */
    select?: CourseContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseContentInclude<ExtArgs> | null
    /**
     * Filter, which CourseContents to fetch.
     */
    where?: CourseContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseContents to fetch.
     */
    orderBy?: CourseContentOrderByWithRelationInput | CourseContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseContents.
     */
    cursor?: CourseContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseContents.
     */
    skip?: number
    distinct?: CourseContentScalarFieldEnum | CourseContentScalarFieldEnum[]
  }

  /**
   * CourseContent create
   */
  export type CourseContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContent
     */
    select?: CourseContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseContentInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseContent.
     */
    data: XOR<CourseContentCreateInput, CourseContentUncheckedCreateInput>
  }

  /**
   * CourseContent createMany
   */
  export type CourseContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseContents.
     */
    data: CourseContentCreateManyInput | CourseContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseContent createManyAndReturn
   */
  export type CourseContentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContent
     */
    select?: CourseContentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CourseContents.
     */
    data: CourseContentCreateManyInput | CourseContentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseContentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseContent update
   */
  export type CourseContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContent
     */
    select?: CourseContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseContentInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseContent.
     */
    data: XOR<CourseContentUpdateInput, CourseContentUncheckedUpdateInput>
    /**
     * Choose, which CourseContent to update.
     */
    where: CourseContentWhereUniqueInput
  }

  /**
   * CourseContent updateMany
   */
  export type CourseContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseContents.
     */
    data: XOR<CourseContentUpdateManyMutationInput, CourseContentUncheckedUpdateManyInput>
    /**
     * Filter which CourseContents to update
     */
    where?: CourseContentWhereInput
  }

  /**
   * CourseContent upsert
   */
  export type CourseContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContent
     */
    select?: CourseContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseContentInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseContent to update in case it exists.
     */
    where: CourseContentWhereUniqueInput
    /**
     * In case the CourseContent found by the `where` argument doesn't exist, create a new CourseContent with this data.
     */
    create: XOR<CourseContentCreateInput, CourseContentUncheckedCreateInput>
    /**
     * In case the CourseContent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseContentUpdateInput, CourseContentUncheckedUpdateInput>
  }

  /**
   * CourseContent delete
   */
  export type CourseContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContent
     */
    select?: CourseContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseContentInclude<ExtArgs> | null
    /**
     * Filter which CourseContent to delete.
     */
    where: CourseContentWhereUniqueInput
  }

  /**
   * CourseContent deleteMany
   */
  export type CourseContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseContents to delete
     */
    where?: CourseContentWhereInput
  }

  /**
   * CourseContent.Attachments
   */
  export type CourseContent$AttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentAttachment
     */
    select?: ContentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentAttachmentInclude<ExtArgs> | null
    where?: ContentAttachmentWhereInput
    orderBy?: ContentAttachmentOrderByWithRelationInput | ContentAttachmentOrderByWithRelationInput[]
    cursor?: ContentAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentAttachmentScalarFieldEnum | ContentAttachmentScalarFieldEnum[]
  }

  /**
   * CourseContent.Tags
   */
  export type CourseContent$TagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagInclude<ExtArgs> | null
    where?: ContentTagWhereInput
    orderBy?: ContentTagOrderByWithRelationInput | ContentTagOrderByWithRelationInput[]
    cursor?: ContentTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentTagScalarFieldEnum | ContentTagScalarFieldEnum[]
  }

  /**
   * CourseContent.ContentComment
   */
  export type CourseContent$ContentCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentComment
     */
    select?: ContentCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCommentInclude<ExtArgs> | null
    where?: ContentCommentWhereInput
    orderBy?: ContentCommentOrderByWithRelationInput | ContentCommentOrderByWithRelationInput[]
    cursor?: ContentCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentCommentScalarFieldEnum | ContentCommentScalarFieldEnum[]
  }

  /**
   * CourseContent without action
   */
  export type CourseContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseContent
     */
    select?: CourseContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseContentInclude<ExtArgs> | null
  }


  /**
   * Model ContentAttachment
   */

  export type AggregateContentAttachment = {
    _count: ContentAttachmentCountAggregateOutputType | null
    _avg: ContentAttachmentAvgAggregateOutputType | null
    _sum: ContentAttachmentSumAggregateOutputType | null
    _min: ContentAttachmentMinAggregateOutputType | null
    _max: ContentAttachmentMaxAggregateOutputType | null
  }

  export type ContentAttachmentAvgAggregateOutputType = {
    contentId: number | null
    attachmentId: number | null
  }

  export type ContentAttachmentSumAggregateOutputType = {
    contentId: number | null
    attachmentId: number | null
  }

  export type ContentAttachmentMinAggregateOutputType = {
    contentId: number | null
    attachmentId: number | null
  }

  export type ContentAttachmentMaxAggregateOutputType = {
    contentId: number | null
    attachmentId: number | null
  }

  export type ContentAttachmentCountAggregateOutputType = {
    contentId: number
    attachmentId: number
    _all: number
  }


  export type ContentAttachmentAvgAggregateInputType = {
    contentId?: true
    attachmentId?: true
  }

  export type ContentAttachmentSumAggregateInputType = {
    contentId?: true
    attachmentId?: true
  }

  export type ContentAttachmentMinAggregateInputType = {
    contentId?: true
    attachmentId?: true
  }

  export type ContentAttachmentMaxAggregateInputType = {
    contentId?: true
    attachmentId?: true
  }

  export type ContentAttachmentCountAggregateInputType = {
    contentId?: true
    attachmentId?: true
    _all?: true
  }

  export type ContentAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentAttachment to aggregate.
     */
    where?: ContentAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentAttachments to fetch.
     */
    orderBy?: ContentAttachmentOrderByWithRelationInput | ContentAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentAttachments
    **/
    _count?: true | ContentAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentAttachmentMaxAggregateInputType
  }

  export type GetContentAttachmentAggregateType<T extends ContentAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateContentAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentAttachment[P]>
      : GetScalarType<T[P], AggregateContentAttachment[P]>
  }




  export type ContentAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentAttachmentWhereInput
    orderBy?: ContentAttachmentOrderByWithAggregationInput | ContentAttachmentOrderByWithAggregationInput[]
    by: ContentAttachmentScalarFieldEnum[] | ContentAttachmentScalarFieldEnum
    having?: ContentAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentAttachmentCountAggregateInputType | true
    _avg?: ContentAttachmentAvgAggregateInputType
    _sum?: ContentAttachmentSumAggregateInputType
    _min?: ContentAttachmentMinAggregateInputType
    _max?: ContentAttachmentMaxAggregateInputType
  }

  export type ContentAttachmentGroupByOutputType = {
    contentId: number
    attachmentId: number
    _count: ContentAttachmentCountAggregateOutputType | null
    _avg: ContentAttachmentAvgAggregateOutputType | null
    _sum: ContentAttachmentSumAggregateOutputType | null
    _min: ContentAttachmentMinAggregateOutputType | null
    _max: ContentAttachmentMaxAggregateOutputType | null
  }

  type GetContentAttachmentGroupByPayload<T extends ContentAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], ContentAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type ContentAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contentId?: boolean
    attachmentId?: boolean
    Content?: boolean | CourseContentDefaultArgs<ExtArgs>
    Attachment?: boolean | AttachmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentAttachment"]>

  export type ContentAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contentId?: boolean
    attachmentId?: boolean
    Content?: boolean | CourseContentDefaultArgs<ExtArgs>
    Attachment?: boolean | AttachmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentAttachment"]>

  export type ContentAttachmentSelectScalar = {
    contentId?: boolean
    attachmentId?: boolean
  }

  export type ContentAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Content?: boolean | CourseContentDefaultArgs<ExtArgs>
    Attachment?: boolean | AttachmentDefaultArgs<ExtArgs>
  }
  export type ContentAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Content?: boolean | CourseContentDefaultArgs<ExtArgs>
    Attachment?: boolean | AttachmentDefaultArgs<ExtArgs>
  }

  export type $ContentAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentAttachment"
    objects: {
      Content: Prisma.$CourseContentPayload<ExtArgs>
      Attachment: Prisma.$AttachmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      contentId: number
      attachmentId: number
    }, ExtArgs["result"]["contentAttachment"]>
    composites: {}
  }

  type ContentAttachmentGetPayload<S extends boolean | null | undefined | ContentAttachmentDefaultArgs> = $Result.GetResult<Prisma.$ContentAttachmentPayload, S>

  type ContentAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContentAttachmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContentAttachmentCountAggregateInputType | true
    }

  export interface ContentAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentAttachment'], meta: { name: 'ContentAttachment' } }
    /**
     * Find zero or one ContentAttachment that matches the filter.
     * @param {ContentAttachmentFindUniqueArgs} args - Arguments to find a ContentAttachment
     * @example
     * // Get one ContentAttachment
     * const contentAttachment = await prisma.contentAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentAttachmentFindUniqueArgs>(args: SelectSubset<T, ContentAttachmentFindUniqueArgs<ExtArgs>>): Prisma__ContentAttachmentClient<$Result.GetResult<Prisma.$ContentAttachmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContentAttachment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContentAttachmentFindUniqueOrThrowArgs} args - Arguments to find a ContentAttachment
     * @example
     * // Get one ContentAttachment
     * const contentAttachment = await prisma.contentAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentAttachmentClient<$Result.GetResult<Prisma.$ContentAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContentAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentAttachmentFindFirstArgs} args - Arguments to find a ContentAttachment
     * @example
     * // Get one ContentAttachment
     * const contentAttachment = await prisma.contentAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentAttachmentFindFirstArgs>(args?: SelectSubset<T, ContentAttachmentFindFirstArgs<ExtArgs>>): Prisma__ContentAttachmentClient<$Result.GetResult<Prisma.$ContentAttachmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContentAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentAttachmentFindFirstOrThrowArgs} args - Arguments to find a ContentAttachment
     * @example
     * // Get one ContentAttachment
     * const contentAttachment = await prisma.contentAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentAttachmentClient<$Result.GetResult<Prisma.$ContentAttachmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContentAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentAttachments
     * const contentAttachments = await prisma.contentAttachment.findMany()
     * 
     * // Get first 10 ContentAttachments
     * const contentAttachments = await prisma.contentAttachment.findMany({ take: 10 })
     * 
     * // Only select the `contentId`
     * const contentAttachmentWithContentIdOnly = await prisma.contentAttachment.findMany({ select: { contentId: true } })
     * 
     */
    findMany<T extends ContentAttachmentFindManyArgs>(args?: SelectSubset<T, ContentAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentAttachmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContentAttachment.
     * @param {ContentAttachmentCreateArgs} args - Arguments to create a ContentAttachment.
     * @example
     * // Create one ContentAttachment
     * const ContentAttachment = await prisma.contentAttachment.create({
     *   data: {
     *     // ... data to create a ContentAttachment
     *   }
     * })
     * 
     */
    create<T extends ContentAttachmentCreateArgs>(args: SelectSubset<T, ContentAttachmentCreateArgs<ExtArgs>>): Prisma__ContentAttachmentClient<$Result.GetResult<Prisma.$ContentAttachmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContentAttachments.
     * @param {ContentAttachmentCreateManyArgs} args - Arguments to create many ContentAttachments.
     * @example
     * // Create many ContentAttachments
     * const contentAttachment = await prisma.contentAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentAttachmentCreateManyArgs>(args?: SelectSubset<T, ContentAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentAttachments and returns the data saved in the database.
     * @param {ContentAttachmentCreateManyAndReturnArgs} args - Arguments to create many ContentAttachments.
     * @example
     * // Create many ContentAttachments
     * const contentAttachment = await prisma.contentAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentAttachments and only return the `contentId`
     * const contentAttachmentWithContentIdOnly = await prisma.contentAttachment.createManyAndReturn({ 
     *   select: { contentId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentAttachmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ContentAttachment.
     * @param {ContentAttachmentDeleteArgs} args - Arguments to delete one ContentAttachment.
     * @example
     * // Delete one ContentAttachment
     * const ContentAttachment = await prisma.contentAttachment.delete({
     *   where: {
     *     // ... filter to delete one ContentAttachment
     *   }
     * })
     * 
     */
    delete<T extends ContentAttachmentDeleteArgs>(args: SelectSubset<T, ContentAttachmentDeleteArgs<ExtArgs>>): Prisma__ContentAttachmentClient<$Result.GetResult<Prisma.$ContentAttachmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContentAttachment.
     * @param {ContentAttachmentUpdateArgs} args - Arguments to update one ContentAttachment.
     * @example
     * // Update one ContentAttachment
     * const contentAttachment = await prisma.contentAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentAttachmentUpdateArgs>(args: SelectSubset<T, ContentAttachmentUpdateArgs<ExtArgs>>): Prisma__ContentAttachmentClient<$Result.GetResult<Prisma.$ContentAttachmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContentAttachments.
     * @param {ContentAttachmentDeleteManyArgs} args - Arguments to filter ContentAttachments to delete.
     * @example
     * // Delete a few ContentAttachments
     * const { count } = await prisma.contentAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentAttachmentDeleteManyArgs>(args?: SelectSubset<T, ContentAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentAttachments
     * const contentAttachment = await prisma.contentAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentAttachmentUpdateManyArgs>(args: SelectSubset<T, ContentAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContentAttachment.
     * @param {ContentAttachmentUpsertArgs} args - Arguments to update or create a ContentAttachment.
     * @example
     * // Update or create a ContentAttachment
     * const contentAttachment = await prisma.contentAttachment.upsert({
     *   create: {
     *     // ... data to create a ContentAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentAttachment we want to update
     *   }
     * })
     */
    upsert<T extends ContentAttachmentUpsertArgs>(args: SelectSubset<T, ContentAttachmentUpsertArgs<ExtArgs>>): Prisma__ContentAttachmentClient<$Result.GetResult<Prisma.$ContentAttachmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContentAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentAttachmentCountArgs} args - Arguments to filter ContentAttachments to count.
     * @example
     * // Count the number of ContentAttachments
     * const count = await prisma.contentAttachment.count({
     *   where: {
     *     // ... the filter for the ContentAttachments we want to count
     *   }
     * })
    **/
    count<T extends ContentAttachmentCountArgs>(
      args?: Subset<T, ContentAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentAttachmentAggregateArgs>(args: Subset<T, ContentAttachmentAggregateArgs>): Prisma.PrismaPromise<GetContentAttachmentAggregateType<T>>

    /**
     * Group by ContentAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: ContentAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentAttachment model
   */
  readonly fields: ContentAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Content<T extends CourseContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseContentDefaultArgs<ExtArgs>>): Prisma__CourseContentClient<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Attachment<T extends AttachmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AttachmentDefaultArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentAttachment model
   */ 
  interface ContentAttachmentFieldRefs {
    readonly contentId: FieldRef<"ContentAttachment", 'Int'>
    readonly attachmentId: FieldRef<"ContentAttachment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ContentAttachment findUnique
   */
  export type ContentAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentAttachment
     */
    select?: ContentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which ContentAttachment to fetch.
     */
    where: ContentAttachmentWhereUniqueInput
  }

  /**
   * ContentAttachment findUniqueOrThrow
   */
  export type ContentAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentAttachment
     */
    select?: ContentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which ContentAttachment to fetch.
     */
    where: ContentAttachmentWhereUniqueInput
  }

  /**
   * ContentAttachment findFirst
   */
  export type ContentAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentAttachment
     */
    select?: ContentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which ContentAttachment to fetch.
     */
    where?: ContentAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentAttachments to fetch.
     */
    orderBy?: ContentAttachmentOrderByWithRelationInput | ContentAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentAttachments.
     */
    cursor?: ContentAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentAttachments.
     */
    distinct?: ContentAttachmentScalarFieldEnum | ContentAttachmentScalarFieldEnum[]
  }

  /**
   * ContentAttachment findFirstOrThrow
   */
  export type ContentAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentAttachment
     */
    select?: ContentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which ContentAttachment to fetch.
     */
    where?: ContentAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentAttachments to fetch.
     */
    orderBy?: ContentAttachmentOrderByWithRelationInput | ContentAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentAttachments.
     */
    cursor?: ContentAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentAttachments.
     */
    distinct?: ContentAttachmentScalarFieldEnum | ContentAttachmentScalarFieldEnum[]
  }

  /**
   * ContentAttachment findMany
   */
  export type ContentAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentAttachment
     */
    select?: ContentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which ContentAttachments to fetch.
     */
    where?: ContentAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentAttachments to fetch.
     */
    orderBy?: ContentAttachmentOrderByWithRelationInput | ContentAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentAttachments.
     */
    cursor?: ContentAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentAttachments.
     */
    skip?: number
    distinct?: ContentAttachmentScalarFieldEnum | ContentAttachmentScalarFieldEnum[]
  }

  /**
   * ContentAttachment create
   */
  export type ContentAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentAttachment
     */
    select?: ContentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentAttachment.
     */
    data: XOR<ContentAttachmentCreateInput, ContentAttachmentUncheckedCreateInput>
  }

  /**
   * ContentAttachment createMany
   */
  export type ContentAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentAttachments.
     */
    data: ContentAttachmentCreateManyInput | ContentAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentAttachment createManyAndReturn
   */
  export type ContentAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentAttachment
     */
    select?: ContentAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ContentAttachments.
     */
    data: ContentAttachmentCreateManyInput | ContentAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentAttachment update
   */
  export type ContentAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentAttachment
     */
    select?: ContentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentAttachment.
     */
    data: XOR<ContentAttachmentUpdateInput, ContentAttachmentUncheckedUpdateInput>
    /**
     * Choose, which ContentAttachment to update.
     */
    where: ContentAttachmentWhereUniqueInput
  }

  /**
   * ContentAttachment updateMany
   */
  export type ContentAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentAttachments.
     */
    data: XOR<ContentAttachmentUpdateManyMutationInput, ContentAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which ContentAttachments to update
     */
    where?: ContentAttachmentWhereInput
  }

  /**
   * ContentAttachment upsert
   */
  export type ContentAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentAttachment
     */
    select?: ContentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentAttachment to update in case it exists.
     */
    where: ContentAttachmentWhereUniqueInput
    /**
     * In case the ContentAttachment found by the `where` argument doesn't exist, create a new ContentAttachment with this data.
     */
    create: XOR<ContentAttachmentCreateInput, ContentAttachmentUncheckedCreateInput>
    /**
     * In case the ContentAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentAttachmentUpdateInput, ContentAttachmentUncheckedUpdateInput>
  }

  /**
   * ContentAttachment delete
   */
  export type ContentAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentAttachment
     */
    select?: ContentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentAttachmentInclude<ExtArgs> | null
    /**
     * Filter which ContentAttachment to delete.
     */
    where: ContentAttachmentWhereUniqueInput
  }

  /**
   * ContentAttachment deleteMany
   */
  export type ContentAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentAttachments to delete
     */
    where?: ContentAttachmentWhereInput
  }

  /**
   * ContentAttachment without action
   */
  export type ContentAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentAttachment
     */
    select?: ContentAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model DictCourseTag
   */

  export type AggregateDictCourseTag = {
    _count: DictCourseTagCountAggregateOutputType | null
    _avg: DictCourseTagAvgAggregateOutputType | null
    _sum: DictCourseTagSumAggregateOutputType | null
    _min: DictCourseTagMinAggregateOutputType | null
    _max: DictCourseTagMaxAggregateOutputType | null
  }

  export type DictCourseTagAvgAggregateOutputType = {
    id: number | null
    typeId: number | null
    order: number | null
    status: number | null
  }

  export type DictCourseTagSumAggregateOutputType = {
    id: number | null
    typeId: number | null
    order: number | null
    status: number | null
  }

  export type DictCourseTagMinAggregateOutputType = {
    id: number | null
    name: string | null
    typeId: number | null
    order: number | null
    status: number | null
  }

  export type DictCourseTagMaxAggregateOutputType = {
    id: number | null
    name: string | null
    typeId: number | null
    order: number | null
    status: number | null
  }

  export type DictCourseTagCountAggregateOutputType = {
    id: number
    name: number
    typeId: number
    order: number
    status: number
    _all: number
  }


  export type DictCourseTagAvgAggregateInputType = {
    id?: true
    typeId?: true
    order?: true
    status?: true
  }

  export type DictCourseTagSumAggregateInputType = {
    id?: true
    typeId?: true
    order?: true
    status?: true
  }

  export type DictCourseTagMinAggregateInputType = {
    id?: true
    name?: true
    typeId?: true
    order?: true
    status?: true
  }

  export type DictCourseTagMaxAggregateInputType = {
    id?: true
    name?: true
    typeId?: true
    order?: true
    status?: true
  }

  export type DictCourseTagCountAggregateInputType = {
    id?: true
    name?: true
    typeId?: true
    order?: true
    status?: true
    _all?: true
  }

  export type DictCourseTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DictCourseTag to aggregate.
     */
    where?: DictCourseTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DictCourseTags to fetch.
     */
    orderBy?: DictCourseTagOrderByWithRelationInput | DictCourseTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DictCourseTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DictCourseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DictCourseTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DictCourseTags
    **/
    _count?: true | DictCourseTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DictCourseTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DictCourseTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DictCourseTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DictCourseTagMaxAggregateInputType
  }

  export type GetDictCourseTagAggregateType<T extends DictCourseTagAggregateArgs> = {
        [P in keyof T & keyof AggregateDictCourseTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDictCourseTag[P]>
      : GetScalarType<T[P], AggregateDictCourseTag[P]>
  }




  export type DictCourseTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DictCourseTagWhereInput
    orderBy?: DictCourseTagOrderByWithAggregationInput | DictCourseTagOrderByWithAggregationInput[]
    by: DictCourseTagScalarFieldEnum[] | DictCourseTagScalarFieldEnum
    having?: DictCourseTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DictCourseTagCountAggregateInputType | true
    _avg?: DictCourseTagAvgAggregateInputType
    _sum?: DictCourseTagSumAggregateInputType
    _min?: DictCourseTagMinAggregateInputType
    _max?: DictCourseTagMaxAggregateInputType
  }

  export type DictCourseTagGroupByOutputType = {
    id: number
    name: string
    typeId: number | null
    order: number
    status: number
    _count: DictCourseTagCountAggregateOutputType | null
    _avg: DictCourseTagAvgAggregateOutputType | null
    _sum: DictCourseTagSumAggregateOutputType | null
    _min: DictCourseTagMinAggregateOutputType | null
    _max: DictCourseTagMaxAggregateOutputType | null
  }

  type GetDictCourseTagGroupByPayload<T extends DictCourseTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DictCourseTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DictCourseTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DictCourseTagGroupByOutputType[P]>
            : GetScalarType<T[P], DictCourseTagGroupByOutputType[P]>
        }
      >
    >


  export type DictCourseTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    typeId?: boolean
    order?: boolean
    status?: boolean
    CourseType?: boolean | DictCourseTag$CourseTypeArgs<ExtArgs>
    CourseTag?: boolean | DictCourseTag$CourseTagArgs<ExtArgs>
    ContentTag?: boolean | DictCourseTag$ContentTagArgs<ExtArgs>
    _count?: boolean | DictCourseTagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dictCourseTag"]>

  export type DictCourseTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    typeId?: boolean
    order?: boolean
    status?: boolean
    CourseType?: boolean | DictCourseTag$CourseTypeArgs<ExtArgs>
  }, ExtArgs["result"]["dictCourseTag"]>

  export type DictCourseTagSelectScalar = {
    id?: boolean
    name?: boolean
    typeId?: boolean
    order?: boolean
    status?: boolean
  }

  export type DictCourseTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CourseType?: boolean | DictCourseTag$CourseTypeArgs<ExtArgs>
    CourseTag?: boolean | DictCourseTag$CourseTagArgs<ExtArgs>
    ContentTag?: boolean | DictCourseTag$ContentTagArgs<ExtArgs>
    _count?: boolean | DictCourseTagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DictCourseTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CourseType?: boolean | DictCourseTag$CourseTypeArgs<ExtArgs>
  }

  export type $DictCourseTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DictCourseTag"
    objects: {
      CourseType: Prisma.$DictCourseTypePayload<ExtArgs> | null
      CourseTag: Prisma.$CourseTagPayload<ExtArgs>[]
      ContentTag: Prisma.$ContentTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      typeId: number | null
      order: number
      status: number
    }, ExtArgs["result"]["dictCourseTag"]>
    composites: {}
  }

  type DictCourseTagGetPayload<S extends boolean | null | undefined | DictCourseTagDefaultArgs> = $Result.GetResult<Prisma.$DictCourseTagPayload, S>

  type DictCourseTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DictCourseTagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DictCourseTagCountAggregateInputType | true
    }

  export interface DictCourseTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DictCourseTag'], meta: { name: 'DictCourseTag' } }
    /**
     * Find zero or one DictCourseTag that matches the filter.
     * @param {DictCourseTagFindUniqueArgs} args - Arguments to find a DictCourseTag
     * @example
     * // Get one DictCourseTag
     * const dictCourseTag = await prisma.dictCourseTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DictCourseTagFindUniqueArgs>(args: SelectSubset<T, DictCourseTagFindUniqueArgs<ExtArgs>>): Prisma__DictCourseTagClient<$Result.GetResult<Prisma.$DictCourseTagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DictCourseTag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DictCourseTagFindUniqueOrThrowArgs} args - Arguments to find a DictCourseTag
     * @example
     * // Get one DictCourseTag
     * const dictCourseTag = await prisma.dictCourseTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DictCourseTagFindUniqueOrThrowArgs>(args: SelectSubset<T, DictCourseTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DictCourseTagClient<$Result.GetResult<Prisma.$DictCourseTagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DictCourseTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictCourseTagFindFirstArgs} args - Arguments to find a DictCourseTag
     * @example
     * // Get one DictCourseTag
     * const dictCourseTag = await prisma.dictCourseTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DictCourseTagFindFirstArgs>(args?: SelectSubset<T, DictCourseTagFindFirstArgs<ExtArgs>>): Prisma__DictCourseTagClient<$Result.GetResult<Prisma.$DictCourseTagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DictCourseTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictCourseTagFindFirstOrThrowArgs} args - Arguments to find a DictCourseTag
     * @example
     * // Get one DictCourseTag
     * const dictCourseTag = await prisma.dictCourseTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DictCourseTagFindFirstOrThrowArgs>(args?: SelectSubset<T, DictCourseTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__DictCourseTagClient<$Result.GetResult<Prisma.$DictCourseTagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DictCourseTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictCourseTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DictCourseTags
     * const dictCourseTags = await prisma.dictCourseTag.findMany()
     * 
     * // Get first 10 DictCourseTags
     * const dictCourseTags = await prisma.dictCourseTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dictCourseTagWithIdOnly = await prisma.dictCourseTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DictCourseTagFindManyArgs>(args?: SelectSubset<T, DictCourseTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DictCourseTagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DictCourseTag.
     * @param {DictCourseTagCreateArgs} args - Arguments to create a DictCourseTag.
     * @example
     * // Create one DictCourseTag
     * const DictCourseTag = await prisma.dictCourseTag.create({
     *   data: {
     *     // ... data to create a DictCourseTag
     *   }
     * })
     * 
     */
    create<T extends DictCourseTagCreateArgs>(args: SelectSubset<T, DictCourseTagCreateArgs<ExtArgs>>): Prisma__DictCourseTagClient<$Result.GetResult<Prisma.$DictCourseTagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DictCourseTags.
     * @param {DictCourseTagCreateManyArgs} args - Arguments to create many DictCourseTags.
     * @example
     * // Create many DictCourseTags
     * const dictCourseTag = await prisma.dictCourseTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DictCourseTagCreateManyArgs>(args?: SelectSubset<T, DictCourseTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DictCourseTags and returns the data saved in the database.
     * @param {DictCourseTagCreateManyAndReturnArgs} args - Arguments to create many DictCourseTags.
     * @example
     * // Create many DictCourseTags
     * const dictCourseTag = await prisma.dictCourseTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DictCourseTags and only return the `id`
     * const dictCourseTagWithIdOnly = await prisma.dictCourseTag.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DictCourseTagCreateManyAndReturnArgs>(args?: SelectSubset<T, DictCourseTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DictCourseTagPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DictCourseTag.
     * @param {DictCourseTagDeleteArgs} args - Arguments to delete one DictCourseTag.
     * @example
     * // Delete one DictCourseTag
     * const DictCourseTag = await prisma.dictCourseTag.delete({
     *   where: {
     *     // ... filter to delete one DictCourseTag
     *   }
     * })
     * 
     */
    delete<T extends DictCourseTagDeleteArgs>(args: SelectSubset<T, DictCourseTagDeleteArgs<ExtArgs>>): Prisma__DictCourseTagClient<$Result.GetResult<Prisma.$DictCourseTagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DictCourseTag.
     * @param {DictCourseTagUpdateArgs} args - Arguments to update one DictCourseTag.
     * @example
     * // Update one DictCourseTag
     * const dictCourseTag = await prisma.dictCourseTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DictCourseTagUpdateArgs>(args: SelectSubset<T, DictCourseTagUpdateArgs<ExtArgs>>): Prisma__DictCourseTagClient<$Result.GetResult<Prisma.$DictCourseTagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DictCourseTags.
     * @param {DictCourseTagDeleteManyArgs} args - Arguments to filter DictCourseTags to delete.
     * @example
     * // Delete a few DictCourseTags
     * const { count } = await prisma.dictCourseTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DictCourseTagDeleteManyArgs>(args?: SelectSubset<T, DictCourseTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DictCourseTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictCourseTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DictCourseTags
     * const dictCourseTag = await prisma.dictCourseTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DictCourseTagUpdateManyArgs>(args: SelectSubset<T, DictCourseTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DictCourseTag.
     * @param {DictCourseTagUpsertArgs} args - Arguments to update or create a DictCourseTag.
     * @example
     * // Update or create a DictCourseTag
     * const dictCourseTag = await prisma.dictCourseTag.upsert({
     *   create: {
     *     // ... data to create a DictCourseTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DictCourseTag we want to update
     *   }
     * })
     */
    upsert<T extends DictCourseTagUpsertArgs>(args: SelectSubset<T, DictCourseTagUpsertArgs<ExtArgs>>): Prisma__DictCourseTagClient<$Result.GetResult<Prisma.$DictCourseTagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DictCourseTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictCourseTagCountArgs} args - Arguments to filter DictCourseTags to count.
     * @example
     * // Count the number of DictCourseTags
     * const count = await prisma.dictCourseTag.count({
     *   where: {
     *     // ... the filter for the DictCourseTags we want to count
     *   }
     * })
    **/
    count<T extends DictCourseTagCountArgs>(
      args?: Subset<T, DictCourseTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DictCourseTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DictCourseTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictCourseTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DictCourseTagAggregateArgs>(args: Subset<T, DictCourseTagAggregateArgs>): Prisma.PrismaPromise<GetDictCourseTagAggregateType<T>>

    /**
     * Group by DictCourseTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictCourseTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DictCourseTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DictCourseTagGroupByArgs['orderBy'] }
        : { orderBy?: DictCourseTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DictCourseTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDictCourseTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DictCourseTag model
   */
  readonly fields: DictCourseTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DictCourseTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DictCourseTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CourseType<T extends DictCourseTag$CourseTypeArgs<ExtArgs> = {}>(args?: Subset<T, DictCourseTag$CourseTypeArgs<ExtArgs>>): Prisma__DictCourseTypeClient<$Result.GetResult<Prisma.$DictCourseTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    CourseTag<T extends DictCourseTag$CourseTagArgs<ExtArgs> = {}>(args?: Subset<T, DictCourseTag$CourseTagArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "findMany"> | Null>
    ContentTag<T extends DictCourseTag$ContentTagArgs<ExtArgs> = {}>(args?: Subset<T, DictCourseTag$ContentTagArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentTagPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DictCourseTag model
   */ 
  interface DictCourseTagFieldRefs {
    readonly id: FieldRef<"DictCourseTag", 'Int'>
    readonly name: FieldRef<"DictCourseTag", 'String'>
    readonly typeId: FieldRef<"DictCourseTag", 'Int'>
    readonly order: FieldRef<"DictCourseTag", 'Int'>
    readonly status: FieldRef<"DictCourseTag", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DictCourseTag findUnique
   */
  export type DictCourseTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCourseTag
     */
    select?: DictCourseTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCourseTagInclude<ExtArgs> | null
    /**
     * Filter, which DictCourseTag to fetch.
     */
    where: DictCourseTagWhereUniqueInput
  }

  /**
   * DictCourseTag findUniqueOrThrow
   */
  export type DictCourseTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCourseTag
     */
    select?: DictCourseTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCourseTagInclude<ExtArgs> | null
    /**
     * Filter, which DictCourseTag to fetch.
     */
    where: DictCourseTagWhereUniqueInput
  }

  /**
   * DictCourseTag findFirst
   */
  export type DictCourseTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCourseTag
     */
    select?: DictCourseTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCourseTagInclude<ExtArgs> | null
    /**
     * Filter, which DictCourseTag to fetch.
     */
    where?: DictCourseTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DictCourseTags to fetch.
     */
    orderBy?: DictCourseTagOrderByWithRelationInput | DictCourseTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DictCourseTags.
     */
    cursor?: DictCourseTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DictCourseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DictCourseTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DictCourseTags.
     */
    distinct?: DictCourseTagScalarFieldEnum | DictCourseTagScalarFieldEnum[]
  }

  /**
   * DictCourseTag findFirstOrThrow
   */
  export type DictCourseTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCourseTag
     */
    select?: DictCourseTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCourseTagInclude<ExtArgs> | null
    /**
     * Filter, which DictCourseTag to fetch.
     */
    where?: DictCourseTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DictCourseTags to fetch.
     */
    orderBy?: DictCourseTagOrderByWithRelationInput | DictCourseTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DictCourseTags.
     */
    cursor?: DictCourseTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DictCourseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DictCourseTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DictCourseTags.
     */
    distinct?: DictCourseTagScalarFieldEnum | DictCourseTagScalarFieldEnum[]
  }

  /**
   * DictCourseTag findMany
   */
  export type DictCourseTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCourseTag
     */
    select?: DictCourseTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCourseTagInclude<ExtArgs> | null
    /**
     * Filter, which DictCourseTags to fetch.
     */
    where?: DictCourseTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DictCourseTags to fetch.
     */
    orderBy?: DictCourseTagOrderByWithRelationInput | DictCourseTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DictCourseTags.
     */
    cursor?: DictCourseTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DictCourseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DictCourseTags.
     */
    skip?: number
    distinct?: DictCourseTagScalarFieldEnum | DictCourseTagScalarFieldEnum[]
  }

  /**
   * DictCourseTag create
   */
  export type DictCourseTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCourseTag
     */
    select?: DictCourseTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCourseTagInclude<ExtArgs> | null
    /**
     * The data needed to create a DictCourseTag.
     */
    data: XOR<DictCourseTagCreateInput, DictCourseTagUncheckedCreateInput>
  }

  /**
   * DictCourseTag createMany
   */
  export type DictCourseTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DictCourseTags.
     */
    data: DictCourseTagCreateManyInput | DictCourseTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DictCourseTag createManyAndReturn
   */
  export type DictCourseTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCourseTag
     */
    select?: DictCourseTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DictCourseTags.
     */
    data: DictCourseTagCreateManyInput | DictCourseTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCourseTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DictCourseTag update
   */
  export type DictCourseTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCourseTag
     */
    select?: DictCourseTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCourseTagInclude<ExtArgs> | null
    /**
     * The data needed to update a DictCourseTag.
     */
    data: XOR<DictCourseTagUpdateInput, DictCourseTagUncheckedUpdateInput>
    /**
     * Choose, which DictCourseTag to update.
     */
    where: DictCourseTagWhereUniqueInput
  }

  /**
   * DictCourseTag updateMany
   */
  export type DictCourseTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DictCourseTags.
     */
    data: XOR<DictCourseTagUpdateManyMutationInput, DictCourseTagUncheckedUpdateManyInput>
    /**
     * Filter which DictCourseTags to update
     */
    where?: DictCourseTagWhereInput
  }

  /**
   * DictCourseTag upsert
   */
  export type DictCourseTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCourseTag
     */
    select?: DictCourseTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCourseTagInclude<ExtArgs> | null
    /**
     * The filter to search for the DictCourseTag to update in case it exists.
     */
    where: DictCourseTagWhereUniqueInput
    /**
     * In case the DictCourseTag found by the `where` argument doesn't exist, create a new DictCourseTag with this data.
     */
    create: XOR<DictCourseTagCreateInput, DictCourseTagUncheckedCreateInput>
    /**
     * In case the DictCourseTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DictCourseTagUpdateInput, DictCourseTagUncheckedUpdateInput>
  }

  /**
   * DictCourseTag delete
   */
  export type DictCourseTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCourseTag
     */
    select?: DictCourseTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCourseTagInclude<ExtArgs> | null
    /**
     * Filter which DictCourseTag to delete.
     */
    where: DictCourseTagWhereUniqueInput
  }

  /**
   * DictCourseTag deleteMany
   */
  export type DictCourseTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DictCourseTags to delete
     */
    where?: DictCourseTagWhereInput
  }

  /**
   * DictCourseTag.CourseType
   */
  export type DictCourseTag$CourseTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCourseType
     */
    select?: DictCourseTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCourseTypeInclude<ExtArgs> | null
    where?: DictCourseTypeWhereInput
  }

  /**
   * DictCourseTag.CourseTag
   */
  export type DictCourseTag$CourseTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    where?: CourseTagWhereInput
    orderBy?: CourseTagOrderByWithRelationInput | CourseTagOrderByWithRelationInput[]
    cursor?: CourseTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseTagScalarFieldEnum | CourseTagScalarFieldEnum[]
  }

  /**
   * DictCourseTag.ContentTag
   */
  export type DictCourseTag$ContentTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagInclude<ExtArgs> | null
    where?: ContentTagWhereInput
    orderBy?: ContentTagOrderByWithRelationInput | ContentTagOrderByWithRelationInput[]
    cursor?: ContentTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentTagScalarFieldEnum | ContentTagScalarFieldEnum[]
  }

  /**
   * DictCourseTag without action
   */
  export type DictCourseTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCourseTag
     */
    select?: DictCourseTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCourseTagInclude<ExtArgs> | null
  }


  /**
   * Model DictCourseType
   */

  export type AggregateDictCourseType = {
    _count: DictCourseTypeCountAggregateOutputType | null
    _avg: DictCourseTypeAvgAggregateOutputType | null
    _sum: DictCourseTypeSumAggregateOutputType | null
    _min: DictCourseTypeMinAggregateOutputType | null
    _max: DictCourseTypeMaxAggregateOutputType | null
  }

  export type DictCourseTypeAvgAggregateOutputType = {
    id: number | null
    order: number | null
    status: number | null
  }

  export type DictCourseTypeSumAggregateOutputType = {
    id: number | null
    order: number | null
    status: number | null
  }

  export type DictCourseTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    order: number | null
    status: number | null
  }

  export type DictCourseTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    order: number | null
    status: number | null
  }

  export type DictCourseTypeCountAggregateOutputType = {
    id: number
    name: number
    order: number
    status: number
    _all: number
  }


  export type DictCourseTypeAvgAggregateInputType = {
    id?: true
    order?: true
    status?: true
  }

  export type DictCourseTypeSumAggregateInputType = {
    id?: true
    order?: true
    status?: true
  }

  export type DictCourseTypeMinAggregateInputType = {
    id?: true
    name?: true
    order?: true
    status?: true
  }

  export type DictCourseTypeMaxAggregateInputType = {
    id?: true
    name?: true
    order?: true
    status?: true
  }

  export type DictCourseTypeCountAggregateInputType = {
    id?: true
    name?: true
    order?: true
    status?: true
    _all?: true
  }

  export type DictCourseTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DictCourseType to aggregate.
     */
    where?: DictCourseTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DictCourseTypes to fetch.
     */
    orderBy?: DictCourseTypeOrderByWithRelationInput | DictCourseTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DictCourseTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DictCourseTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DictCourseTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DictCourseTypes
    **/
    _count?: true | DictCourseTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DictCourseTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DictCourseTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DictCourseTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DictCourseTypeMaxAggregateInputType
  }

  export type GetDictCourseTypeAggregateType<T extends DictCourseTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateDictCourseType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDictCourseType[P]>
      : GetScalarType<T[P], AggregateDictCourseType[P]>
  }




  export type DictCourseTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DictCourseTypeWhereInput
    orderBy?: DictCourseTypeOrderByWithAggregationInput | DictCourseTypeOrderByWithAggregationInput[]
    by: DictCourseTypeScalarFieldEnum[] | DictCourseTypeScalarFieldEnum
    having?: DictCourseTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DictCourseTypeCountAggregateInputType | true
    _avg?: DictCourseTypeAvgAggregateInputType
    _sum?: DictCourseTypeSumAggregateInputType
    _min?: DictCourseTypeMinAggregateInputType
    _max?: DictCourseTypeMaxAggregateInputType
  }

  export type DictCourseTypeGroupByOutputType = {
    id: number
    name: string
    order: number
    status: number
    _count: DictCourseTypeCountAggregateOutputType | null
    _avg: DictCourseTypeAvgAggregateOutputType | null
    _sum: DictCourseTypeSumAggregateOutputType | null
    _min: DictCourseTypeMinAggregateOutputType | null
    _max: DictCourseTypeMaxAggregateOutputType | null
  }

  type GetDictCourseTypeGroupByPayload<T extends DictCourseTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DictCourseTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DictCourseTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DictCourseTypeGroupByOutputType[P]>
            : GetScalarType<T[P], DictCourseTypeGroupByOutputType[P]>
        }
      >
    >


  export type DictCourseTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    status?: boolean
    CourseTags?: boolean | DictCourseType$CourseTagsArgs<ExtArgs>
    _count?: boolean | DictCourseTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dictCourseType"]>

  export type DictCourseTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    status?: boolean
  }, ExtArgs["result"]["dictCourseType"]>

  export type DictCourseTypeSelectScalar = {
    id?: boolean
    name?: boolean
    order?: boolean
    status?: boolean
  }

  export type DictCourseTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CourseTags?: boolean | DictCourseType$CourseTagsArgs<ExtArgs>
    _count?: boolean | DictCourseTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DictCourseTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DictCourseTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DictCourseType"
    objects: {
      CourseTags: Prisma.$DictCourseTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      order: number
      status: number
    }, ExtArgs["result"]["dictCourseType"]>
    composites: {}
  }

  type DictCourseTypeGetPayload<S extends boolean | null | undefined | DictCourseTypeDefaultArgs> = $Result.GetResult<Prisma.$DictCourseTypePayload, S>

  type DictCourseTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DictCourseTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DictCourseTypeCountAggregateInputType | true
    }

  export interface DictCourseTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DictCourseType'], meta: { name: 'DictCourseType' } }
    /**
     * Find zero or one DictCourseType that matches the filter.
     * @param {DictCourseTypeFindUniqueArgs} args - Arguments to find a DictCourseType
     * @example
     * // Get one DictCourseType
     * const dictCourseType = await prisma.dictCourseType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DictCourseTypeFindUniqueArgs>(args: SelectSubset<T, DictCourseTypeFindUniqueArgs<ExtArgs>>): Prisma__DictCourseTypeClient<$Result.GetResult<Prisma.$DictCourseTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DictCourseType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DictCourseTypeFindUniqueOrThrowArgs} args - Arguments to find a DictCourseType
     * @example
     * // Get one DictCourseType
     * const dictCourseType = await prisma.dictCourseType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DictCourseTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, DictCourseTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DictCourseTypeClient<$Result.GetResult<Prisma.$DictCourseTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DictCourseType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictCourseTypeFindFirstArgs} args - Arguments to find a DictCourseType
     * @example
     * // Get one DictCourseType
     * const dictCourseType = await prisma.dictCourseType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DictCourseTypeFindFirstArgs>(args?: SelectSubset<T, DictCourseTypeFindFirstArgs<ExtArgs>>): Prisma__DictCourseTypeClient<$Result.GetResult<Prisma.$DictCourseTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DictCourseType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictCourseTypeFindFirstOrThrowArgs} args - Arguments to find a DictCourseType
     * @example
     * // Get one DictCourseType
     * const dictCourseType = await prisma.dictCourseType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DictCourseTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, DictCourseTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DictCourseTypeClient<$Result.GetResult<Prisma.$DictCourseTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DictCourseTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictCourseTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DictCourseTypes
     * const dictCourseTypes = await prisma.dictCourseType.findMany()
     * 
     * // Get first 10 DictCourseTypes
     * const dictCourseTypes = await prisma.dictCourseType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dictCourseTypeWithIdOnly = await prisma.dictCourseType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DictCourseTypeFindManyArgs>(args?: SelectSubset<T, DictCourseTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DictCourseTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DictCourseType.
     * @param {DictCourseTypeCreateArgs} args - Arguments to create a DictCourseType.
     * @example
     * // Create one DictCourseType
     * const DictCourseType = await prisma.dictCourseType.create({
     *   data: {
     *     // ... data to create a DictCourseType
     *   }
     * })
     * 
     */
    create<T extends DictCourseTypeCreateArgs>(args: SelectSubset<T, DictCourseTypeCreateArgs<ExtArgs>>): Prisma__DictCourseTypeClient<$Result.GetResult<Prisma.$DictCourseTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DictCourseTypes.
     * @param {DictCourseTypeCreateManyArgs} args - Arguments to create many DictCourseTypes.
     * @example
     * // Create many DictCourseTypes
     * const dictCourseType = await prisma.dictCourseType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DictCourseTypeCreateManyArgs>(args?: SelectSubset<T, DictCourseTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DictCourseTypes and returns the data saved in the database.
     * @param {DictCourseTypeCreateManyAndReturnArgs} args - Arguments to create many DictCourseTypes.
     * @example
     * // Create many DictCourseTypes
     * const dictCourseType = await prisma.dictCourseType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DictCourseTypes and only return the `id`
     * const dictCourseTypeWithIdOnly = await prisma.dictCourseType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DictCourseTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, DictCourseTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DictCourseTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DictCourseType.
     * @param {DictCourseTypeDeleteArgs} args - Arguments to delete one DictCourseType.
     * @example
     * // Delete one DictCourseType
     * const DictCourseType = await prisma.dictCourseType.delete({
     *   where: {
     *     // ... filter to delete one DictCourseType
     *   }
     * })
     * 
     */
    delete<T extends DictCourseTypeDeleteArgs>(args: SelectSubset<T, DictCourseTypeDeleteArgs<ExtArgs>>): Prisma__DictCourseTypeClient<$Result.GetResult<Prisma.$DictCourseTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DictCourseType.
     * @param {DictCourseTypeUpdateArgs} args - Arguments to update one DictCourseType.
     * @example
     * // Update one DictCourseType
     * const dictCourseType = await prisma.dictCourseType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DictCourseTypeUpdateArgs>(args: SelectSubset<T, DictCourseTypeUpdateArgs<ExtArgs>>): Prisma__DictCourseTypeClient<$Result.GetResult<Prisma.$DictCourseTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DictCourseTypes.
     * @param {DictCourseTypeDeleteManyArgs} args - Arguments to filter DictCourseTypes to delete.
     * @example
     * // Delete a few DictCourseTypes
     * const { count } = await prisma.dictCourseType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DictCourseTypeDeleteManyArgs>(args?: SelectSubset<T, DictCourseTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DictCourseTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictCourseTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DictCourseTypes
     * const dictCourseType = await prisma.dictCourseType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DictCourseTypeUpdateManyArgs>(args: SelectSubset<T, DictCourseTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DictCourseType.
     * @param {DictCourseTypeUpsertArgs} args - Arguments to update or create a DictCourseType.
     * @example
     * // Update or create a DictCourseType
     * const dictCourseType = await prisma.dictCourseType.upsert({
     *   create: {
     *     // ... data to create a DictCourseType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DictCourseType we want to update
     *   }
     * })
     */
    upsert<T extends DictCourseTypeUpsertArgs>(args: SelectSubset<T, DictCourseTypeUpsertArgs<ExtArgs>>): Prisma__DictCourseTypeClient<$Result.GetResult<Prisma.$DictCourseTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DictCourseTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictCourseTypeCountArgs} args - Arguments to filter DictCourseTypes to count.
     * @example
     * // Count the number of DictCourseTypes
     * const count = await prisma.dictCourseType.count({
     *   where: {
     *     // ... the filter for the DictCourseTypes we want to count
     *   }
     * })
    **/
    count<T extends DictCourseTypeCountArgs>(
      args?: Subset<T, DictCourseTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DictCourseTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DictCourseType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictCourseTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DictCourseTypeAggregateArgs>(args: Subset<T, DictCourseTypeAggregateArgs>): Prisma.PrismaPromise<GetDictCourseTypeAggregateType<T>>

    /**
     * Group by DictCourseType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictCourseTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DictCourseTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DictCourseTypeGroupByArgs['orderBy'] }
        : { orderBy?: DictCourseTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DictCourseTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDictCourseTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DictCourseType model
   */
  readonly fields: DictCourseTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DictCourseType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DictCourseTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CourseTags<T extends DictCourseType$CourseTagsArgs<ExtArgs> = {}>(args?: Subset<T, DictCourseType$CourseTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DictCourseTagPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DictCourseType model
   */ 
  interface DictCourseTypeFieldRefs {
    readonly id: FieldRef<"DictCourseType", 'Int'>
    readonly name: FieldRef<"DictCourseType", 'String'>
    readonly order: FieldRef<"DictCourseType", 'Int'>
    readonly status: FieldRef<"DictCourseType", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DictCourseType findUnique
   */
  export type DictCourseTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCourseType
     */
    select?: DictCourseTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCourseTypeInclude<ExtArgs> | null
    /**
     * Filter, which DictCourseType to fetch.
     */
    where: DictCourseTypeWhereUniqueInput
  }

  /**
   * DictCourseType findUniqueOrThrow
   */
  export type DictCourseTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCourseType
     */
    select?: DictCourseTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCourseTypeInclude<ExtArgs> | null
    /**
     * Filter, which DictCourseType to fetch.
     */
    where: DictCourseTypeWhereUniqueInput
  }

  /**
   * DictCourseType findFirst
   */
  export type DictCourseTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCourseType
     */
    select?: DictCourseTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCourseTypeInclude<ExtArgs> | null
    /**
     * Filter, which DictCourseType to fetch.
     */
    where?: DictCourseTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DictCourseTypes to fetch.
     */
    orderBy?: DictCourseTypeOrderByWithRelationInput | DictCourseTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DictCourseTypes.
     */
    cursor?: DictCourseTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DictCourseTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DictCourseTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DictCourseTypes.
     */
    distinct?: DictCourseTypeScalarFieldEnum | DictCourseTypeScalarFieldEnum[]
  }

  /**
   * DictCourseType findFirstOrThrow
   */
  export type DictCourseTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCourseType
     */
    select?: DictCourseTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCourseTypeInclude<ExtArgs> | null
    /**
     * Filter, which DictCourseType to fetch.
     */
    where?: DictCourseTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DictCourseTypes to fetch.
     */
    orderBy?: DictCourseTypeOrderByWithRelationInput | DictCourseTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DictCourseTypes.
     */
    cursor?: DictCourseTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DictCourseTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DictCourseTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DictCourseTypes.
     */
    distinct?: DictCourseTypeScalarFieldEnum | DictCourseTypeScalarFieldEnum[]
  }

  /**
   * DictCourseType findMany
   */
  export type DictCourseTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCourseType
     */
    select?: DictCourseTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCourseTypeInclude<ExtArgs> | null
    /**
     * Filter, which DictCourseTypes to fetch.
     */
    where?: DictCourseTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DictCourseTypes to fetch.
     */
    orderBy?: DictCourseTypeOrderByWithRelationInput | DictCourseTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DictCourseTypes.
     */
    cursor?: DictCourseTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DictCourseTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DictCourseTypes.
     */
    skip?: number
    distinct?: DictCourseTypeScalarFieldEnum | DictCourseTypeScalarFieldEnum[]
  }

  /**
   * DictCourseType create
   */
  export type DictCourseTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCourseType
     */
    select?: DictCourseTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCourseTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a DictCourseType.
     */
    data: XOR<DictCourseTypeCreateInput, DictCourseTypeUncheckedCreateInput>
  }

  /**
   * DictCourseType createMany
   */
  export type DictCourseTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DictCourseTypes.
     */
    data: DictCourseTypeCreateManyInput | DictCourseTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DictCourseType createManyAndReturn
   */
  export type DictCourseTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCourseType
     */
    select?: DictCourseTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DictCourseTypes.
     */
    data: DictCourseTypeCreateManyInput | DictCourseTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DictCourseType update
   */
  export type DictCourseTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCourseType
     */
    select?: DictCourseTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCourseTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a DictCourseType.
     */
    data: XOR<DictCourseTypeUpdateInput, DictCourseTypeUncheckedUpdateInput>
    /**
     * Choose, which DictCourseType to update.
     */
    where: DictCourseTypeWhereUniqueInput
  }

  /**
   * DictCourseType updateMany
   */
  export type DictCourseTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DictCourseTypes.
     */
    data: XOR<DictCourseTypeUpdateManyMutationInput, DictCourseTypeUncheckedUpdateManyInput>
    /**
     * Filter which DictCourseTypes to update
     */
    where?: DictCourseTypeWhereInput
  }

  /**
   * DictCourseType upsert
   */
  export type DictCourseTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCourseType
     */
    select?: DictCourseTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCourseTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the DictCourseType to update in case it exists.
     */
    where: DictCourseTypeWhereUniqueInput
    /**
     * In case the DictCourseType found by the `where` argument doesn't exist, create a new DictCourseType with this data.
     */
    create: XOR<DictCourseTypeCreateInput, DictCourseTypeUncheckedCreateInput>
    /**
     * In case the DictCourseType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DictCourseTypeUpdateInput, DictCourseTypeUncheckedUpdateInput>
  }

  /**
   * DictCourseType delete
   */
  export type DictCourseTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCourseType
     */
    select?: DictCourseTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCourseTypeInclude<ExtArgs> | null
    /**
     * Filter which DictCourseType to delete.
     */
    where: DictCourseTypeWhereUniqueInput
  }

  /**
   * DictCourseType deleteMany
   */
  export type DictCourseTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DictCourseTypes to delete
     */
    where?: DictCourseTypeWhereInput
  }

  /**
   * DictCourseType.CourseTags
   */
  export type DictCourseType$CourseTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCourseTag
     */
    select?: DictCourseTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCourseTagInclude<ExtArgs> | null
    where?: DictCourseTagWhereInput
    orderBy?: DictCourseTagOrderByWithRelationInput | DictCourseTagOrderByWithRelationInput[]
    cursor?: DictCourseTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DictCourseTagScalarFieldEnum | DictCourseTagScalarFieldEnum[]
  }

  /**
   * DictCourseType without action
   */
  export type DictCourseTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCourseType
     */
    select?: DictCourseTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCourseTypeInclude<ExtArgs> | null
  }


  /**
   * Model CourseTag
   */

  export type AggregateCourseTag = {
    _count: CourseTagCountAggregateOutputType | null
    _avg: CourseTagAvgAggregateOutputType | null
    _sum: CourseTagSumAggregateOutputType | null
    _min: CourseTagMinAggregateOutputType | null
    _max: CourseTagMaxAggregateOutputType | null
  }

  export type CourseTagAvgAggregateOutputType = {
    courseId: number | null
    tagId: number | null
  }

  export type CourseTagSumAggregateOutputType = {
    courseId: number | null
    tagId: number | null
  }

  export type CourseTagMinAggregateOutputType = {
    courseId: number | null
    tagId: number | null
  }

  export type CourseTagMaxAggregateOutputType = {
    courseId: number | null
    tagId: number | null
  }

  export type CourseTagCountAggregateOutputType = {
    courseId: number
    tagId: number
    _all: number
  }


  export type CourseTagAvgAggregateInputType = {
    courseId?: true
    tagId?: true
  }

  export type CourseTagSumAggregateInputType = {
    courseId?: true
    tagId?: true
  }

  export type CourseTagMinAggregateInputType = {
    courseId?: true
    tagId?: true
  }

  export type CourseTagMaxAggregateInputType = {
    courseId?: true
    tagId?: true
  }

  export type CourseTagCountAggregateInputType = {
    courseId?: true
    tagId?: true
    _all?: true
  }

  export type CourseTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseTag to aggregate.
     */
    where?: CourseTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTags to fetch.
     */
    orderBy?: CourseTagOrderByWithRelationInput | CourseTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseTags
    **/
    _count?: true | CourseTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseTagMaxAggregateInputType
  }

  export type GetCourseTagAggregateType<T extends CourseTagAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseTag[P]>
      : GetScalarType<T[P], AggregateCourseTag[P]>
  }




  export type CourseTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseTagWhereInput
    orderBy?: CourseTagOrderByWithAggregationInput | CourseTagOrderByWithAggregationInput[]
    by: CourseTagScalarFieldEnum[] | CourseTagScalarFieldEnum
    having?: CourseTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseTagCountAggregateInputType | true
    _avg?: CourseTagAvgAggregateInputType
    _sum?: CourseTagSumAggregateInputType
    _min?: CourseTagMinAggregateInputType
    _max?: CourseTagMaxAggregateInputType
  }

  export type CourseTagGroupByOutputType = {
    courseId: number
    tagId: number
    _count: CourseTagCountAggregateOutputType | null
    _avg: CourseTagAvgAggregateOutputType | null
    _sum: CourseTagSumAggregateOutputType | null
    _min: CourseTagMinAggregateOutputType | null
    _max: CourseTagMaxAggregateOutputType | null
  }

  type GetCourseTagGroupByPayload<T extends CourseTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseTagGroupByOutputType[P]>
            : GetScalarType<T[P], CourseTagGroupByOutputType[P]>
        }
      >
    >


  export type CourseTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    tagId?: boolean
    Course?: boolean | CourseDefaultArgs<ExtArgs>
    Tag?: boolean | DictCourseTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseTag"]>

  export type CourseTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    tagId?: boolean
    Course?: boolean | CourseDefaultArgs<ExtArgs>
    Tag?: boolean | DictCourseTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseTag"]>

  export type CourseTagSelectScalar = {
    courseId?: boolean
    tagId?: boolean
  }

  export type CourseTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Course?: boolean | CourseDefaultArgs<ExtArgs>
    Tag?: boolean | DictCourseTagDefaultArgs<ExtArgs>
  }
  export type CourseTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Course?: boolean | CourseDefaultArgs<ExtArgs>
    Tag?: boolean | DictCourseTagDefaultArgs<ExtArgs>
  }

  export type $CourseTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseTag"
    objects: {
      Course: Prisma.$CoursePayload<ExtArgs>
      Tag: Prisma.$DictCourseTagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      courseId: number
      tagId: number
    }, ExtArgs["result"]["courseTag"]>
    composites: {}
  }

  type CourseTagGetPayload<S extends boolean | null | undefined | CourseTagDefaultArgs> = $Result.GetResult<Prisma.$CourseTagPayload, S>

  type CourseTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseTagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseTagCountAggregateInputType | true
    }

  export interface CourseTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseTag'], meta: { name: 'CourseTag' } }
    /**
     * Find zero or one CourseTag that matches the filter.
     * @param {CourseTagFindUniqueArgs} args - Arguments to find a CourseTag
     * @example
     * // Get one CourseTag
     * const courseTag = await prisma.courseTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseTagFindUniqueArgs>(args: SelectSubset<T, CourseTagFindUniqueArgs<ExtArgs>>): Prisma__CourseTagClient<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CourseTag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseTagFindUniqueOrThrowArgs} args - Arguments to find a CourseTag
     * @example
     * // Get one CourseTag
     * const courseTag = await prisma.courseTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseTagFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseTagClient<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CourseTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagFindFirstArgs} args - Arguments to find a CourseTag
     * @example
     * // Get one CourseTag
     * const courseTag = await prisma.courseTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseTagFindFirstArgs>(args?: SelectSubset<T, CourseTagFindFirstArgs<ExtArgs>>): Prisma__CourseTagClient<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CourseTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagFindFirstOrThrowArgs} args - Arguments to find a CourseTag
     * @example
     * // Get one CourseTag
     * const courseTag = await prisma.courseTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseTagFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseTagClient<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CourseTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseTags
     * const courseTags = await prisma.courseTag.findMany()
     * 
     * // Get first 10 CourseTags
     * const courseTags = await prisma.courseTag.findMany({ take: 10 })
     * 
     * // Only select the `courseId`
     * const courseTagWithCourseIdOnly = await prisma.courseTag.findMany({ select: { courseId: true } })
     * 
     */
    findMany<T extends CourseTagFindManyArgs>(args?: SelectSubset<T, CourseTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CourseTag.
     * @param {CourseTagCreateArgs} args - Arguments to create a CourseTag.
     * @example
     * // Create one CourseTag
     * const CourseTag = await prisma.courseTag.create({
     *   data: {
     *     // ... data to create a CourseTag
     *   }
     * })
     * 
     */
    create<T extends CourseTagCreateArgs>(args: SelectSubset<T, CourseTagCreateArgs<ExtArgs>>): Prisma__CourseTagClient<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CourseTags.
     * @param {CourseTagCreateManyArgs} args - Arguments to create many CourseTags.
     * @example
     * // Create many CourseTags
     * const courseTag = await prisma.courseTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseTagCreateManyArgs>(args?: SelectSubset<T, CourseTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseTags and returns the data saved in the database.
     * @param {CourseTagCreateManyAndReturnArgs} args - Arguments to create many CourseTags.
     * @example
     * // Create many CourseTags
     * const courseTag = await prisma.courseTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseTags and only return the `courseId`
     * const courseTagWithCourseIdOnly = await prisma.courseTag.createManyAndReturn({ 
     *   select: { courseId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseTagCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CourseTag.
     * @param {CourseTagDeleteArgs} args - Arguments to delete one CourseTag.
     * @example
     * // Delete one CourseTag
     * const CourseTag = await prisma.courseTag.delete({
     *   where: {
     *     // ... filter to delete one CourseTag
     *   }
     * })
     * 
     */
    delete<T extends CourseTagDeleteArgs>(args: SelectSubset<T, CourseTagDeleteArgs<ExtArgs>>): Prisma__CourseTagClient<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CourseTag.
     * @param {CourseTagUpdateArgs} args - Arguments to update one CourseTag.
     * @example
     * // Update one CourseTag
     * const courseTag = await prisma.courseTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseTagUpdateArgs>(args: SelectSubset<T, CourseTagUpdateArgs<ExtArgs>>): Prisma__CourseTagClient<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CourseTags.
     * @param {CourseTagDeleteManyArgs} args - Arguments to filter CourseTags to delete.
     * @example
     * // Delete a few CourseTags
     * const { count } = await prisma.courseTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseTagDeleteManyArgs>(args?: SelectSubset<T, CourseTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseTags
     * const courseTag = await prisma.courseTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseTagUpdateManyArgs>(args: SelectSubset<T, CourseTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseTag.
     * @param {CourseTagUpsertArgs} args - Arguments to update or create a CourseTag.
     * @example
     * // Update or create a CourseTag
     * const courseTag = await prisma.courseTag.upsert({
     *   create: {
     *     // ... data to create a CourseTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseTag we want to update
     *   }
     * })
     */
    upsert<T extends CourseTagUpsertArgs>(args: SelectSubset<T, CourseTagUpsertArgs<ExtArgs>>): Prisma__CourseTagClient<$Result.GetResult<Prisma.$CourseTagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CourseTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagCountArgs} args - Arguments to filter CourseTags to count.
     * @example
     * // Count the number of CourseTags
     * const count = await prisma.courseTag.count({
     *   where: {
     *     // ... the filter for the CourseTags we want to count
     *   }
     * })
    **/
    count<T extends CourseTagCountArgs>(
      args?: Subset<T, CourseTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseTagAggregateArgs>(args: Subset<T, CourseTagAggregateArgs>): Prisma.PrismaPromise<GetCourseTagAggregateType<T>>

    /**
     * Group by CourseTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseTagGroupByArgs['orderBy'] }
        : { orderBy?: CourseTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseTag model
   */
  readonly fields: CourseTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Tag<T extends DictCourseTagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DictCourseTagDefaultArgs<ExtArgs>>): Prisma__DictCourseTagClient<$Result.GetResult<Prisma.$DictCourseTagPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseTag model
   */ 
  interface CourseTagFieldRefs {
    readonly courseId: FieldRef<"CourseTag", 'Int'>
    readonly tagId: FieldRef<"CourseTag", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CourseTag findUnique
   */
  export type CourseTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * Filter, which CourseTag to fetch.
     */
    where: CourseTagWhereUniqueInput
  }

  /**
   * CourseTag findUniqueOrThrow
   */
  export type CourseTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * Filter, which CourseTag to fetch.
     */
    where: CourseTagWhereUniqueInput
  }

  /**
   * CourseTag findFirst
   */
  export type CourseTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * Filter, which CourseTag to fetch.
     */
    where?: CourseTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTags to fetch.
     */
    orderBy?: CourseTagOrderByWithRelationInput | CourseTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseTags.
     */
    cursor?: CourseTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseTags.
     */
    distinct?: CourseTagScalarFieldEnum | CourseTagScalarFieldEnum[]
  }

  /**
   * CourseTag findFirstOrThrow
   */
  export type CourseTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * Filter, which CourseTag to fetch.
     */
    where?: CourseTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTags to fetch.
     */
    orderBy?: CourseTagOrderByWithRelationInput | CourseTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseTags.
     */
    cursor?: CourseTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseTags.
     */
    distinct?: CourseTagScalarFieldEnum | CourseTagScalarFieldEnum[]
  }

  /**
   * CourseTag findMany
   */
  export type CourseTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * Filter, which CourseTags to fetch.
     */
    where?: CourseTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTags to fetch.
     */
    orderBy?: CourseTagOrderByWithRelationInput | CourseTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseTags.
     */
    cursor?: CourseTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTags.
     */
    skip?: number
    distinct?: CourseTagScalarFieldEnum | CourseTagScalarFieldEnum[]
  }

  /**
   * CourseTag create
   */
  export type CourseTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseTag.
     */
    data: XOR<CourseTagCreateInput, CourseTagUncheckedCreateInput>
  }

  /**
   * CourseTag createMany
   */
  export type CourseTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseTags.
     */
    data: CourseTagCreateManyInput | CourseTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseTag createManyAndReturn
   */
  export type CourseTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CourseTags.
     */
    data: CourseTagCreateManyInput | CourseTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseTag update
   */
  export type CourseTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseTag.
     */
    data: XOR<CourseTagUpdateInput, CourseTagUncheckedUpdateInput>
    /**
     * Choose, which CourseTag to update.
     */
    where: CourseTagWhereUniqueInput
  }

  /**
   * CourseTag updateMany
   */
  export type CourseTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseTags.
     */
    data: XOR<CourseTagUpdateManyMutationInput, CourseTagUncheckedUpdateManyInput>
    /**
     * Filter which CourseTags to update
     */
    where?: CourseTagWhereInput
  }

  /**
   * CourseTag upsert
   */
  export type CourseTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseTag to update in case it exists.
     */
    where: CourseTagWhereUniqueInput
    /**
     * In case the CourseTag found by the `where` argument doesn't exist, create a new CourseTag with this data.
     */
    create: XOR<CourseTagCreateInput, CourseTagUncheckedCreateInput>
    /**
     * In case the CourseTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseTagUpdateInput, CourseTagUncheckedUpdateInput>
  }

  /**
   * CourseTag delete
   */
  export type CourseTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
    /**
     * Filter which CourseTag to delete.
     */
    where: CourseTagWhereUniqueInput
  }

  /**
   * CourseTag deleteMany
   */
  export type CourseTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseTags to delete
     */
    where?: CourseTagWhereInput
  }

  /**
   * CourseTag without action
   */
  export type CourseTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTag
     */
    select?: CourseTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTagInclude<ExtArgs> | null
  }


  /**
   * Model ContentTag
   */

  export type AggregateContentTag = {
    _count: ContentTagCountAggregateOutputType | null
    _avg: ContentTagAvgAggregateOutputType | null
    _sum: ContentTagSumAggregateOutputType | null
    _min: ContentTagMinAggregateOutputType | null
    _max: ContentTagMaxAggregateOutputType | null
  }

  export type ContentTagAvgAggregateOutputType = {
    contentId: number | null
    tagId: number | null
  }

  export type ContentTagSumAggregateOutputType = {
    contentId: number | null
    tagId: number | null
  }

  export type ContentTagMinAggregateOutputType = {
    contentId: number | null
    tagId: number | null
  }

  export type ContentTagMaxAggregateOutputType = {
    contentId: number | null
    tagId: number | null
  }

  export type ContentTagCountAggregateOutputType = {
    contentId: number
    tagId: number
    _all: number
  }


  export type ContentTagAvgAggregateInputType = {
    contentId?: true
    tagId?: true
  }

  export type ContentTagSumAggregateInputType = {
    contentId?: true
    tagId?: true
  }

  export type ContentTagMinAggregateInputType = {
    contentId?: true
    tagId?: true
  }

  export type ContentTagMaxAggregateInputType = {
    contentId?: true
    tagId?: true
  }

  export type ContentTagCountAggregateInputType = {
    contentId?: true
    tagId?: true
    _all?: true
  }

  export type ContentTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentTag to aggregate.
     */
    where?: ContentTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentTags to fetch.
     */
    orderBy?: ContentTagOrderByWithRelationInput | ContentTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentTags
    **/
    _count?: true | ContentTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentTagMaxAggregateInputType
  }

  export type GetContentTagAggregateType<T extends ContentTagAggregateArgs> = {
        [P in keyof T & keyof AggregateContentTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentTag[P]>
      : GetScalarType<T[P], AggregateContentTag[P]>
  }




  export type ContentTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentTagWhereInput
    orderBy?: ContentTagOrderByWithAggregationInput | ContentTagOrderByWithAggregationInput[]
    by: ContentTagScalarFieldEnum[] | ContentTagScalarFieldEnum
    having?: ContentTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentTagCountAggregateInputType | true
    _avg?: ContentTagAvgAggregateInputType
    _sum?: ContentTagSumAggregateInputType
    _min?: ContentTagMinAggregateInputType
    _max?: ContentTagMaxAggregateInputType
  }

  export type ContentTagGroupByOutputType = {
    contentId: number
    tagId: number
    _count: ContentTagCountAggregateOutputType | null
    _avg: ContentTagAvgAggregateOutputType | null
    _sum: ContentTagSumAggregateOutputType | null
    _min: ContentTagMinAggregateOutputType | null
    _max: ContentTagMaxAggregateOutputType | null
  }

  type GetContentTagGroupByPayload<T extends ContentTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentTagGroupByOutputType[P]>
            : GetScalarType<T[P], ContentTagGroupByOutputType[P]>
        }
      >
    >


  export type ContentTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contentId?: boolean
    tagId?: boolean
    Content?: boolean | CourseContentDefaultArgs<ExtArgs>
    Tag?: boolean | DictCourseTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentTag"]>

  export type ContentTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contentId?: boolean
    tagId?: boolean
    Content?: boolean | CourseContentDefaultArgs<ExtArgs>
    Tag?: boolean | DictCourseTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentTag"]>

  export type ContentTagSelectScalar = {
    contentId?: boolean
    tagId?: boolean
  }

  export type ContentTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Content?: boolean | CourseContentDefaultArgs<ExtArgs>
    Tag?: boolean | DictCourseTagDefaultArgs<ExtArgs>
  }
  export type ContentTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Content?: boolean | CourseContentDefaultArgs<ExtArgs>
    Tag?: boolean | DictCourseTagDefaultArgs<ExtArgs>
  }

  export type $ContentTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentTag"
    objects: {
      Content: Prisma.$CourseContentPayload<ExtArgs>
      Tag: Prisma.$DictCourseTagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      contentId: number
      tagId: number
    }, ExtArgs["result"]["contentTag"]>
    composites: {}
  }

  type ContentTagGetPayload<S extends boolean | null | undefined | ContentTagDefaultArgs> = $Result.GetResult<Prisma.$ContentTagPayload, S>

  type ContentTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContentTagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContentTagCountAggregateInputType | true
    }

  export interface ContentTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentTag'], meta: { name: 'ContentTag' } }
    /**
     * Find zero or one ContentTag that matches the filter.
     * @param {ContentTagFindUniqueArgs} args - Arguments to find a ContentTag
     * @example
     * // Get one ContentTag
     * const contentTag = await prisma.contentTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentTagFindUniqueArgs>(args: SelectSubset<T, ContentTagFindUniqueArgs<ExtArgs>>): Prisma__ContentTagClient<$Result.GetResult<Prisma.$ContentTagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContentTag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContentTagFindUniqueOrThrowArgs} args - Arguments to find a ContentTag
     * @example
     * // Get one ContentTag
     * const contentTag = await prisma.contentTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentTagFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentTagClient<$Result.GetResult<Prisma.$ContentTagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContentTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTagFindFirstArgs} args - Arguments to find a ContentTag
     * @example
     * // Get one ContentTag
     * const contentTag = await prisma.contentTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentTagFindFirstArgs>(args?: SelectSubset<T, ContentTagFindFirstArgs<ExtArgs>>): Prisma__ContentTagClient<$Result.GetResult<Prisma.$ContentTagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContentTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTagFindFirstOrThrowArgs} args - Arguments to find a ContentTag
     * @example
     * // Get one ContentTag
     * const contentTag = await prisma.contentTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentTagFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentTagClient<$Result.GetResult<Prisma.$ContentTagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContentTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentTags
     * const contentTags = await prisma.contentTag.findMany()
     * 
     * // Get first 10 ContentTags
     * const contentTags = await prisma.contentTag.findMany({ take: 10 })
     * 
     * // Only select the `contentId`
     * const contentTagWithContentIdOnly = await prisma.contentTag.findMany({ select: { contentId: true } })
     * 
     */
    findMany<T extends ContentTagFindManyArgs>(args?: SelectSubset<T, ContentTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentTagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContentTag.
     * @param {ContentTagCreateArgs} args - Arguments to create a ContentTag.
     * @example
     * // Create one ContentTag
     * const ContentTag = await prisma.contentTag.create({
     *   data: {
     *     // ... data to create a ContentTag
     *   }
     * })
     * 
     */
    create<T extends ContentTagCreateArgs>(args: SelectSubset<T, ContentTagCreateArgs<ExtArgs>>): Prisma__ContentTagClient<$Result.GetResult<Prisma.$ContentTagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContentTags.
     * @param {ContentTagCreateManyArgs} args - Arguments to create many ContentTags.
     * @example
     * // Create many ContentTags
     * const contentTag = await prisma.contentTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentTagCreateManyArgs>(args?: SelectSubset<T, ContentTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentTags and returns the data saved in the database.
     * @param {ContentTagCreateManyAndReturnArgs} args - Arguments to create many ContentTags.
     * @example
     * // Create many ContentTags
     * const contentTag = await prisma.contentTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentTags and only return the `contentId`
     * const contentTagWithContentIdOnly = await prisma.contentTag.createManyAndReturn({ 
     *   select: { contentId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentTagCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentTagPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ContentTag.
     * @param {ContentTagDeleteArgs} args - Arguments to delete one ContentTag.
     * @example
     * // Delete one ContentTag
     * const ContentTag = await prisma.contentTag.delete({
     *   where: {
     *     // ... filter to delete one ContentTag
     *   }
     * })
     * 
     */
    delete<T extends ContentTagDeleteArgs>(args: SelectSubset<T, ContentTagDeleteArgs<ExtArgs>>): Prisma__ContentTagClient<$Result.GetResult<Prisma.$ContentTagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContentTag.
     * @param {ContentTagUpdateArgs} args - Arguments to update one ContentTag.
     * @example
     * // Update one ContentTag
     * const contentTag = await prisma.contentTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentTagUpdateArgs>(args: SelectSubset<T, ContentTagUpdateArgs<ExtArgs>>): Prisma__ContentTagClient<$Result.GetResult<Prisma.$ContentTagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContentTags.
     * @param {ContentTagDeleteManyArgs} args - Arguments to filter ContentTags to delete.
     * @example
     * // Delete a few ContentTags
     * const { count } = await prisma.contentTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentTagDeleteManyArgs>(args?: SelectSubset<T, ContentTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentTags
     * const contentTag = await prisma.contentTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentTagUpdateManyArgs>(args: SelectSubset<T, ContentTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContentTag.
     * @param {ContentTagUpsertArgs} args - Arguments to update or create a ContentTag.
     * @example
     * // Update or create a ContentTag
     * const contentTag = await prisma.contentTag.upsert({
     *   create: {
     *     // ... data to create a ContentTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentTag we want to update
     *   }
     * })
     */
    upsert<T extends ContentTagUpsertArgs>(args: SelectSubset<T, ContentTagUpsertArgs<ExtArgs>>): Prisma__ContentTagClient<$Result.GetResult<Prisma.$ContentTagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContentTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTagCountArgs} args - Arguments to filter ContentTags to count.
     * @example
     * // Count the number of ContentTags
     * const count = await prisma.contentTag.count({
     *   where: {
     *     // ... the filter for the ContentTags we want to count
     *   }
     * })
    **/
    count<T extends ContentTagCountArgs>(
      args?: Subset<T, ContentTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentTagAggregateArgs>(args: Subset<T, ContentTagAggregateArgs>): Prisma.PrismaPromise<GetContentTagAggregateType<T>>

    /**
     * Group by ContentTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentTagGroupByArgs['orderBy'] }
        : { orderBy?: ContentTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentTag model
   */
  readonly fields: ContentTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Content<T extends CourseContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseContentDefaultArgs<ExtArgs>>): Prisma__CourseContentClient<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Tag<T extends DictCourseTagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DictCourseTagDefaultArgs<ExtArgs>>): Prisma__DictCourseTagClient<$Result.GetResult<Prisma.$DictCourseTagPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentTag model
   */ 
  interface ContentTagFieldRefs {
    readonly contentId: FieldRef<"ContentTag", 'Int'>
    readonly tagId: FieldRef<"ContentTag", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ContentTag findUnique
   */
  export type ContentTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagInclude<ExtArgs> | null
    /**
     * Filter, which ContentTag to fetch.
     */
    where: ContentTagWhereUniqueInput
  }

  /**
   * ContentTag findUniqueOrThrow
   */
  export type ContentTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagInclude<ExtArgs> | null
    /**
     * Filter, which ContentTag to fetch.
     */
    where: ContentTagWhereUniqueInput
  }

  /**
   * ContentTag findFirst
   */
  export type ContentTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagInclude<ExtArgs> | null
    /**
     * Filter, which ContentTag to fetch.
     */
    where?: ContentTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentTags to fetch.
     */
    orderBy?: ContentTagOrderByWithRelationInput | ContentTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentTags.
     */
    cursor?: ContentTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentTags.
     */
    distinct?: ContentTagScalarFieldEnum | ContentTagScalarFieldEnum[]
  }

  /**
   * ContentTag findFirstOrThrow
   */
  export type ContentTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagInclude<ExtArgs> | null
    /**
     * Filter, which ContentTag to fetch.
     */
    where?: ContentTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentTags to fetch.
     */
    orderBy?: ContentTagOrderByWithRelationInput | ContentTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentTags.
     */
    cursor?: ContentTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentTags.
     */
    distinct?: ContentTagScalarFieldEnum | ContentTagScalarFieldEnum[]
  }

  /**
   * ContentTag findMany
   */
  export type ContentTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagInclude<ExtArgs> | null
    /**
     * Filter, which ContentTags to fetch.
     */
    where?: ContentTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentTags to fetch.
     */
    orderBy?: ContentTagOrderByWithRelationInput | ContentTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentTags.
     */
    cursor?: ContentTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentTags.
     */
    skip?: number
    distinct?: ContentTagScalarFieldEnum | ContentTagScalarFieldEnum[]
  }

  /**
   * ContentTag create
   */
  export type ContentTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentTag.
     */
    data: XOR<ContentTagCreateInput, ContentTagUncheckedCreateInput>
  }

  /**
   * ContentTag createMany
   */
  export type ContentTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentTags.
     */
    data: ContentTagCreateManyInput | ContentTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentTag createManyAndReturn
   */
  export type ContentTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ContentTags.
     */
    data: ContentTagCreateManyInput | ContentTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentTag update
   */
  export type ContentTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentTag.
     */
    data: XOR<ContentTagUpdateInput, ContentTagUncheckedUpdateInput>
    /**
     * Choose, which ContentTag to update.
     */
    where: ContentTagWhereUniqueInput
  }

  /**
   * ContentTag updateMany
   */
  export type ContentTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentTags.
     */
    data: XOR<ContentTagUpdateManyMutationInput, ContentTagUncheckedUpdateManyInput>
    /**
     * Filter which ContentTags to update
     */
    where?: ContentTagWhereInput
  }

  /**
   * ContentTag upsert
   */
  export type ContentTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentTag to update in case it exists.
     */
    where: ContentTagWhereUniqueInput
    /**
     * In case the ContentTag found by the `where` argument doesn't exist, create a new ContentTag with this data.
     */
    create: XOR<ContentTagCreateInput, ContentTagUncheckedCreateInput>
    /**
     * In case the ContentTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentTagUpdateInput, ContentTagUncheckedUpdateInput>
  }

  /**
   * ContentTag delete
   */
  export type ContentTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagInclude<ExtArgs> | null
    /**
     * Filter which ContentTag to delete.
     */
    where: ContentTagWhereUniqueInput
  }

  /**
   * ContentTag deleteMany
   */
  export type ContentTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentTags to delete
     */
    where?: ContentTagWhereInput
  }

  /**
   * ContentTag without action
   */
  export type ContentTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentTag
     */
    select?: ContentTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTagInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    id: number | null
    pid: number | null
    userId: number | null
    hands: number | null
    status: number | null
    isBest: number | null
  }

  export type CommentSumAggregateOutputType = {
    id: number | null
    pid: number | null
    userId: number | null
    hands: bigint | null
    status: number | null
    isBest: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: number | null
    pid: number | null
    userId: number | null
    created: Date | null
    hands: bigint | null
    status: number | null
    isBest: number | null
  }

  export type CommentMaxAggregateOutputType = {
    id: number | null
    pid: number | null
    userId: number | null
    created: Date | null
    hands: bigint | null
    status: number | null
    isBest: number | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    pid: number
    userId: number
    created: number
    hands: number
    status: number
    isBest: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    id?: true
    pid?: true
    userId?: true
    hands?: true
    status?: true
    isBest?: true
  }

  export type CommentSumAggregateInputType = {
    id?: true
    pid?: true
    userId?: true
    hands?: true
    status?: true
    isBest?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    pid?: true
    userId?: true
    created?: true
    hands?: true
    status?: true
    isBest?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    pid?: true
    userId?: true
    created?: true
    hands?: true
    status?: true
    isBest?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    pid?: true
    userId?: true
    created?: true
    hands?: true
    status?: true
    isBest?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: number
    pid: number | null
    userId: number
    created: Date
    hands: bigint
    status: number
    isBest: number
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pid?: boolean
    userId?: boolean
    created?: boolean
    hands?: boolean
    status?: boolean
    isBest?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    children?: boolean | Comment$childrenArgs<ExtArgs>
    CourseComment?: boolean | Comment$CourseCommentArgs<ExtArgs>
    ContentComment?: boolean | Comment$ContentCommentArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pid?: boolean
    userId?: boolean
    created?: boolean
    hands?: boolean
    status?: boolean
    isBest?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    pid?: boolean
    userId?: boolean
    created?: boolean
    hands?: boolean
    status?: boolean
    isBest?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    children?: boolean | Comment$childrenArgs<ExtArgs>
    CourseComment?: boolean | Comment$CourseCommentArgs<ExtArgs>
    ContentComment?: boolean | Comment$ContentCommentArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      parent: Prisma.$CommentPayload<ExtArgs> | null
      children: Prisma.$CommentPayload<ExtArgs>[]
      CourseComment: Prisma.$CourseCommentPayload<ExtArgs>[]
      ContentComment: Prisma.$ContentCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pid: number | null
      userId: number
      created: Date
      hands: bigint
      status: number
      isBest: number
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parent<T extends Comment$parentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$parentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    children<T extends Comment$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Comment$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    CourseComment<T extends Comment$CourseCommentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$CourseCommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseCommentPayload<ExtArgs>, T, "findMany"> | Null>
    ContentComment<T extends Comment$ContentCommentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$ContentCommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentCommentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'Int'>
    readonly pid: FieldRef<"Comment", 'Int'>
    readonly userId: FieldRef<"Comment", 'Int'>
    readonly created: FieldRef<"Comment", 'DateTime'>
    readonly hands: FieldRef<"Comment", 'BigInt'>
    readonly status: FieldRef<"Comment", 'Int'>
    readonly isBest: FieldRef<"Comment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }

  /**
   * Comment.parent
   */
  export type Comment$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Comment.children
   */
  export type Comment$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment.CourseComment
   */
  export type Comment$CourseCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseComment
     */
    select?: CourseCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCommentInclude<ExtArgs> | null
    where?: CourseCommentWhereInput
    orderBy?: CourseCommentOrderByWithRelationInput | CourseCommentOrderByWithRelationInput[]
    cursor?: CourseCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseCommentScalarFieldEnum | CourseCommentScalarFieldEnum[]
  }

  /**
   * Comment.ContentComment
   */
  export type Comment$ContentCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentComment
     */
    select?: ContentCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCommentInclude<ExtArgs> | null
    where?: ContentCommentWhereInput
    orderBy?: ContentCommentOrderByWithRelationInput | ContentCommentOrderByWithRelationInput[]
    cursor?: ContentCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentCommentScalarFieldEnum | ContentCommentScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model CourseComment
   */

  export type AggregateCourseComment = {
    _count: CourseCommentCountAggregateOutputType | null
    _avg: CourseCommentAvgAggregateOutputType | null
    _sum: CourseCommentSumAggregateOutputType | null
    _min: CourseCommentMinAggregateOutputType | null
    _max: CourseCommentMaxAggregateOutputType | null
  }

  export type CourseCommentAvgAggregateOutputType = {
    courseId: number | null
    commentId: number | null
  }

  export type CourseCommentSumAggregateOutputType = {
    courseId: number | null
    commentId: number | null
  }

  export type CourseCommentMinAggregateOutputType = {
    courseId: number | null
    commentId: number | null
  }

  export type CourseCommentMaxAggregateOutputType = {
    courseId: number | null
    commentId: number | null
  }

  export type CourseCommentCountAggregateOutputType = {
    courseId: number
    commentId: number
    _all: number
  }


  export type CourseCommentAvgAggregateInputType = {
    courseId?: true
    commentId?: true
  }

  export type CourseCommentSumAggregateInputType = {
    courseId?: true
    commentId?: true
  }

  export type CourseCommentMinAggregateInputType = {
    courseId?: true
    commentId?: true
  }

  export type CourseCommentMaxAggregateInputType = {
    courseId?: true
    commentId?: true
  }

  export type CourseCommentCountAggregateInputType = {
    courseId?: true
    commentId?: true
    _all?: true
  }

  export type CourseCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseComment to aggregate.
     */
    where?: CourseCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseComments to fetch.
     */
    orderBy?: CourseCommentOrderByWithRelationInput | CourseCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseComments
    **/
    _count?: true | CourseCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseCommentMaxAggregateInputType
  }

  export type GetCourseCommentAggregateType<T extends CourseCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseComment[P]>
      : GetScalarType<T[P], AggregateCourseComment[P]>
  }




  export type CourseCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseCommentWhereInput
    orderBy?: CourseCommentOrderByWithAggregationInput | CourseCommentOrderByWithAggregationInput[]
    by: CourseCommentScalarFieldEnum[] | CourseCommentScalarFieldEnum
    having?: CourseCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCommentCountAggregateInputType | true
    _avg?: CourseCommentAvgAggregateInputType
    _sum?: CourseCommentSumAggregateInputType
    _min?: CourseCommentMinAggregateInputType
    _max?: CourseCommentMaxAggregateInputType
  }

  export type CourseCommentGroupByOutputType = {
    courseId: number
    commentId: number
    _count: CourseCommentCountAggregateOutputType | null
    _avg: CourseCommentAvgAggregateOutputType | null
    _sum: CourseCommentSumAggregateOutputType | null
    _min: CourseCommentMinAggregateOutputType | null
    _max: CourseCommentMaxAggregateOutputType | null
  }

  type GetCourseCommentGroupByPayload<T extends CourseCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseCommentGroupByOutputType[P]>
            : GetScalarType<T[P], CourseCommentGroupByOutputType[P]>
        }
      >
    >


  export type CourseCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    commentId?: boolean
    Course?: boolean | CourseDefaultArgs<ExtArgs>
    Comment?: boolean | CommentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseComment"]>

  export type CourseCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    commentId?: boolean
    Course?: boolean | CourseDefaultArgs<ExtArgs>
    Comment?: boolean | CommentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseComment"]>

  export type CourseCommentSelectScalar = {
    courseId?: boolean
    commentId?: boolean
  }

  export type CourseCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Course?: boolean | CourseDefaultArgs<ExtArgs>
    Comment?: boolean | CommentDefaultArgs<ExtArgs>
  }
  export type CourseCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Course?: boolean | CourseDefaultArgs<ExtArgs>
    Comment?: boolean | CommentDefaultArgs<ExtArgs>
  }

  export type $CourseCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseComment"
    objects: {
      Course: Prisma.$CoursePayload<ExtArgs>
      Comment: Prisma.$CommentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      courseId: number
      commentId: number
    }, ExtArgs["result"]["courseComment"]>
    composites: {}
  }

  type CourseCommentGetPayload<S extends boolean | null | undefined | CourseCommentDefaultArgs> = $Result.GetResult<Prisma.$CourseCommentPayload, S>

  type CourseCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseCommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseCommentCountAggregateInputType | true
    }

  export interface CourseCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseComment'], meta: { name: 'CourseComment' } }
    /**
     * Find zero or one CourseComment that matches the filter.
     * @param {CourseCommentFindUniqueArgs} args - Arguments to find a CourseComment
     * @example
     * // Get one CourseComment
     * const courseComment = await prisma.courseComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseCommentFindUniqueArgs>(args: SelectSubset<T, CourseCommentFindUniqueArgs<ExtArgs>>): Prisma__CourseCommentClient<$Result.GetResult<Prisma.$CourseCommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CourseComment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseCommentFindUniqueOrThrowArgs} args - Arguments to find a CourseComment
     * @example
     * // Get one CourseComment
     * const courseComment = await prisma.courseComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseCommentClient<$Result.GetResult<Prisma.$CourseCommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CourseComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCommentFindFirstArgs} args - Arguments to find a CourseComment
     * @example
     * // Get one CourseComment
     * const courseComment = await prisma.courseComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseCommentFindFirstArgs>(args?: SelectSubset<T, CourseCommentFindFirstArgs<ExtArgs>>): Prisma__CourseCommentClient<$Result.GetResult<Prisma.$CourseCommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CourseComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCommentFindFirstOrThrowArgs} args - Arguments to find a CourseComment
     * @example
     * // Get one CourseComment
     * const courseComment = await prisma.courseComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseCommentClient<$Result.GetResult<Prisma.$CourseCommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CourseComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseComments
     * const courseComments = await prisma.courseComment.findMany()
     * 
     * // Get first 10 CourseComments
     * const courseComments = await prisma.courseComment.findMany({ take: 10 })
     * 
     * // Only select the `courseId`
     * const courseCommentWithCourseIdOnly = await prisma.courseComment.findMany({ select: { courseId: true } })
     * 
     */
    findMany<T extends CourseCommentFindManyArgs>(args?: SelectSubset<T, CourseCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseCommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CourseComment.
     * @param {CourseCommentCreateArgs} args - Arguments to create a CourseComment.
     * @example
     * // Create one CourseComment
     * const CourseComment = await prisma.courseComment.create({
     *   data: {
     *     // ... data to create a CourseComment
     *   }
     * })
     * 
     */
    create<T extends CourseCommentCreateArgs>(args: SelectSubset<T, CourseCommentCreateArgs<ExtArgs>>): Prisma__CourseCommentClient<$Result.GetResult<Prisma.$CourseCommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CourseComments.
     * @param {CourseCommentCreateManyArgs} args - Arguments to create many CourseComments.
     * @example
     * // Create many CourseComments
     * const courseComment = await prisma.courseComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCommentCreateManyArgs>(args?: SelectSubset<T, CourseCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseComments and returns the data saved in the database.
     * @param {CourseCommentCreateManyAndReturnArgs} args - Arguments to create many CourseComments.
     * @example
     * // Create many CourseComments
     * const courseComment = await prisma.courseComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseComments and only return the `courseId`
     * const courseCommentWithCourseIdOnly = await prisma.courseComment.createManyAndReturn({ 
     *   select: { courseId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseCommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CourseComment.
     * @param {CourseCommentDeleteArgs} args - Arguments to delete one CourseComment.
     * @example
     * // Delete one CourseComment
     * const CourseComment = await prisma.courseComment.delete({
     *   where: {
     *     // ... filter to delete one CourseComment
     *   }
     * })
     * 
     */
    delete<T extends CourseCommentDeleteArgs>(args: SelectSubset<T, CourseCommentDeleteArgs<ExtArgs>>): Prisma__CourseCommentClient<$Result.GetResult<Prisma.$CourseCommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CourseComment.
     * @param {CourseCommentUpdateArgs} args - Arguments to update one CourseComment.
     * @example
     * // Update one CourseComment
     * const courseComment = await prisma.courseComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseCommentUpdateArgs>(args: SelectSubset<T, CourseCommentUpdateArgs<ExtArgs>>): Prisma__CourseCommentClient<$Result.GetResult<Prisma.$CourseCommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CourseComments.
     * @param {CourseCommentDeleteManyArgs} args - Arguments to filter CourseComments to delete.
     * @example
     * // Delete a few CourseComments
     * const { count } = await prisma.courseComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseCommentDeleteManyArgs>(args?: SelectSubset<T, CourseCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseComments
     * const courseComment = await prisma.courseComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseCommentUpdateManyArgs>(args: SelectSubset<T, CourseCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseComment.
     * @param {CourseCommentUpsertArgs} args - Arguments to update or create a CourseComment.
     * @example
     * // Update or create a CourseComment
     * const courseComment = await prisma.courseComment.upsert({
     *   create: {
     *     // ... data to create a CourseComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseComment we want to update
     *   }
     * })
     */
    upsert<T extends CourseCommentUpsertArgs>(args: SelectSubset<T, CourseCommentUpsertArgs<ExtArgs>>): Prisma__CourseCommentClient<$Result.GetResult<Prisma.$CourseCommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CourseComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCommentCountArgs} args - Arguments to filter CourseComments to count.
     * @example
     * // Count the number of CourseComments
     * const count = await prisma.courseComment.count({
     *   where: {
     *     // ... the filter for the CourseComments we want to count
     *   }
     * })
    **/
    count<T extends CourseCommentCountArgs>(
      args?: Subset<T, CourseCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseCommentAggregateArgs>(args: Subset<T, CourseCommentAggregateArgs>): Prisma.PrismaPromise<GetCourseCommentAggregateType<T>>

    /**
     * Group by CourseComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseCommentGroupByArgs['orderBy'] }
        : { orderBy?: CourseCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseComment model
   */
  readonly fields: CourseCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Comment<T extends CommentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommentDefaultArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseComment model
   */ 
  interface CourseCommentFieldRefs {
    readonly courseId: FieldRef<"CourseComment", 'Int'>
    readonly commentId: FieldRef<"CourseComment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CourseComment findUnique
   */
  export type CourseCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseComment
     */
    select?: CourseCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCommentInclude<ExtArgs> | null
    /**
     * Filter, which CourseComment to fetch.
     */
    where: CourseCommentWhereUniqueInput
  }

  /**
   * CourseComment findUniqueOrThrow
   */
  export type CourseCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseComment
     */
    select?: CourseCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCommentInclude<ExtArgs> | null
    /**
     * Filter, which CourseComment to fetch.
     */
    where: CourseCommentWhereUniqueInput
  }

  /**
   * CourseComment findFirst
   */
  export type CourseCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseComment
     */
    select?: CourseCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCommentInclude<ExtArgs> | null
    /**
     * Filter, which CourseComment to fetch.
     */
    where?: CourseCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseComments to fetch.
     */
    orderBy?: CourseCommentOrderByWithRelationInput | CourseCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseComments.
     */
    cursor?: CourseCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseComments.
     */
    distinct?: CourseCommentScalarFieldEnum | CourseCommentScalarFieldEnum[]
  }

  /**
   * CourseComment findFirstOrThrow
   */
  export type CourseCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseComment
     */
    select?: CourseCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCommentInclude<ExtArgs> | null
    /**
     * Filter, which CourseComment to fetch.
     */
    where?: CourseCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseComments to fetch.
     */
    orderBy?: CourseCommentOrderByWithRelationInput | CourseCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseComments.
     */
    cursor?: CourseCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseComments.
     */
    distinct?: CourseCommentScalarFieldEnum | CourseCommentScalarFieldEnum[]
  }

  /**
   * CourseComment findMany
   */
  export type CourseCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseComment
     */
    select?: CourseCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCommentInclude<ExtArgs> | null
    /**
     * Filter, which CourseComments to fetch.
     */
    where?: CourseCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseComments to fetch.
     */
    orderBy?: CourseCommentOrderByWithRelationInput | CourseCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseComments.
     */
    cursor?: CourseCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseComments.
     */
    skip?: number
    distinct?: CourseCommentScalarFieldEnum | CourseCommentScalarFieldEnum[]
  }

  /**
   * CourseComment create
   */
  export type CourseCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseComment
     */
    select?: CourseCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseComment.
     */
    data: XOR<CourseCommentCreateInput, CourseCommentUncheckedCreateInput>
  }

  /**
   * CourseComment createMany
   */
  export type CourseCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseComments.
     */
    data: CourseCommentCreateManyInput | CourseCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseComment createManyAndReturn
   */
  export type CourseCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseComment
     */
    select?: CourseCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CourseComments.
     */
    data: CourseCommentCreateManyInput | CourseCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseComment update
   */
  export type CourseCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseComment
     */
    select?: CourseCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseComment.
     */
    data: XOR<CourseCommentUpdateInput, CourseCommentUncheckedUpdateInput>
    /**
     * Choose, which CourseComment to update.
     */
    where: CourseCommentWhereUniqueInput
  }

  /**
   * CourseComment updateMany
   */
  export type CourseCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseComments.
     */
    data: XOR<CourseCommentUpdateManyMutationInput, CourseCommentUncheckedUpdateManyInput>
    /**
     * Filter which CourseComments to update
     */
    where?: CourseCommentWhereInput
  }

  /**
   * CourseComment upsert
   */
  export type CourseCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseComment
     */
    select?: CourseCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseComment to update in case it exists.
     */
    where: CourseCommentWhereUniqueInput
    /**
     * In case the CourseComment found by the `where` argument doesn't exist, create a new CourseComment with this data.
     */
    create: XOR<CourseCommentCreateInput, CourseCommentUncheckedCreateInput>
    /**
     * In case the CourseComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseCommentUpdateInput, CourseCommentUncheckedUpdateInput>
  }

  /**
   * CourseComment delete
   */
  export type CourseCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseComment
     */
    select?: CourseCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCommentInclude<ExtArgs> | null
    /**
     * Filter which CourseComment to delete.
     */
    where: CourseCommentWhereUniqueInput
  }

  /**
   * CourseComment deleteMany
   */
  export type CourseCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseComments to delete
     */
    where?: CourseCommentWhereInput
  }

  /**
   * CourseComment without action
   */
  export type CourseCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseComment
     */
    select?: CourseCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCommentInclude<ExtArgs> | null
  }


  /**
   * Model ContentComment
   */

  export type AggregateContentComment = {
    _count: ContentCommentCountAggregateOutputType | null
    _avg: ContentCommentAvgAggregateOutputType | null
    _sum: ContentCommentSumAggregateOutputType | null
    _min: ContentCommentMinAggregateOutputType | null
    _max: ContentCommentMaxAggregateOutputType | null
  }

  export type ContentCommentAvgAggregateOutputType = {
    contentId: number | null
    commentId: number | null
  }

  export type ContentCommentSumAggregateOutputType = {
    contentId: number | null
    commentId: number | null
  }

  export type ContentCommentMinAggregateOutputType = {
    contentId: number | null
    commentId: number | null
  }

  export type ContentCommentMaxAggregateOutputType = {
    contentId: number | null
    commentId: number | null
  }

  export type ContentCommentCountAggregateOutputType = {
    contentId: number
    commentId: number
    _all: number
  }


  export type ContentCommentAvgAggregateInputType = {
    contentId?: true
    commentId?: true
  }

  export type ContentCommentSumAggregateInputType = {
    contentId?: true
    commentId?: true
  }

  export type ContentCommentMinAggregateInputType = {
    contentId?: true
    commentId?: true
  }

  export type ContentCommentMaxAggregateInputType = {
    contentId?: true
    commentId?: true
  }

  export type ContentCommentCountAggregateInputType = {
    contentId?: true
    commentId?: true
    _all?: true
  }

  export type ContentCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentComment to aggregate.
     */
    where?: ContentCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentComments to fetch.
     */
    orderBy?: ContentCommentOrderByWithRelationInput | ContentCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentComments
    **/
    _count?: true | ContentCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentCommentMaxAggregateInputType
  }

  export type GetContentCommentAggregateType<T extends ContentCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateContentComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentComment[P]>
      : GetScalarType<T[P], AggregateContentComment[P]>
  }




  export type ContentCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentCommentWhereInput
    orderBy?: ContentCommentOrderByWithAggregationInput | ContentCommentOrderByWithAggregationInput[]
    by: ContentCommentScalarFieldEnum[] | ContentCommentScalarFieldEnum
    having?: ContentCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentCommentCountAggregateInputType | true
    _avg?: ContentCommentAvgAggregateInputType
    _sum?: ContentCommentSumAggregateInputType
    _min?: ContentCommentMinAggregateInputType
    _max?: ContentCommentMaxAggregateInputType
  }

  export type ContentCommentGroupByOutputType = {
    contentId: number
    commentId: number
    _count: ContentCommentCountAggregateOutputType | null
    _avg: ContentCommentAvgAggregateOutputType | null
    _sum: ContentCommentSumAggregateOutputType | null
    _min: ContentCommentMinAggregateOutputType | null
    _max: ContentCommentMaxAggregateOutputType | null
  }

  type GetContentCommentGroupByPayload<T extends ContentCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentCommentGroupByOutputType[P]>
            : GetScalarType<T[P], ContentCommentGroupByOutputType[P]>
        }
      >
    >


  export type ContentCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contentId?: boolean
    commentId?: boolean
    Content?: boolean | CourseContentDefaultArgs<ExtArgs>
    Comment?: boolean | CommentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentComment"]>

  export type ContentCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contentId?: boolean
    commentId?: boolean
    Content?: boolean | CourseContentDefaultArgs<ExtArgs>
    Comment?: boolean | CommentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentComment"]>

  export type ContentCommentSelectScalar = {
    contentId?: boolean
    commentId?: boolean
  }

  export type ContentCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Content?: boolean | CourseContentDefaultArgs<ExtArgs>
    Comment?: boolean | CommentDefaultArgs<ExtArgs>
  }
  export type ContentCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Content?: boolean | CourseContentDefaultArgs<ExtArgs>
    Comment?: boolean | CommentDefaultArgs<ExtArgs>
  }

  export type $ContentCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentComment"
    objects: {
      Content: Prisma.$CourseContentPayload<ExtArgs>
      Comment: Prisma.$CommentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      contentId: number
      commentId: number
    }, ExtArgs["result"]["contentComment"]>
    composites: {}
  }

  type ContentCommentGetPayload<S extends boolean | null | undefined | ContentCommentDefaultArgs> = $Result.GetResult<Prisma.$ContentCommentPayload, S>

  type ContentCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContentCommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContentCommentCountAggregateInputType | true
    }

  export interface ContentCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentComment'], meta: { name: 'ContentComment' } }
    /**
     * Find zero or one ContentComment that matches the filter.
     * @param {ContentCommentFindUniqueArgs} args - Arguments to find a ContentComment
     * @example
     * // Get one ContentComment
     * const contentComment = await prisma.contentComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentCommentFindUniqueArgs>(args: SelectSubset<T, ContentCommentFindUniqueArgs<ExtArgs>>): Prisma__ContentCommentClient<$Result.GetResult<Prisma.$ContentCommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContentComment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContentCommentFindUniqueOrThrowArgs} args - Arguments to find a ContentComment
     * @example
     * // Get one ContentComment
     * const contentComment = await prisma.contentComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentCommentClient<$Result.GetResult<Prisma.$ContentCommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContentComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCommentFindFirstArgs} args - Arguments to find a ContentComment
     * @example
     * // Get one ContentComment
     * const contentComment = await prisma.contentComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentCommentFindFirstArgs>(args?: SelectSubset<T, ContentCommentFindFirstArgs<ExtArgs>>): Prisma__ContentCommentClient<$Result.GetResult<Prisma.$ContentCommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContentComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCommentFindFirstOrThrowArgs} args - Arguments to find a ContentComment
     * @example
     * // Get one ContentComment
     * const contentComment = await prisma.contentComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentCommentClient<$Result.GetResult<Prisma.$ContentCommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContentComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentComments
     * const contentComments = await prisma.contentComment.findMany()
     * 
     * // Get first 10 ContentComments
     * const contentComments = await prisma.contentComment.findMany({ take: 10 })
     * 
     * // Only select the `contentId`
     * const contentCommentWithContentIdOnly = await prisma.contentComment.findMany({ select: { contentId: true } })
     * 
     */
    findMany<T extends ContentCommentFindManyArgs>(args?: SelectSubset<T, ContentCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentCommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContentComment.
     * @param {ContentCommentCreateArgs} args - Arguments to create a ContentComment.
     * @example
     * // Create one ContentComment
     * const ContentComment = await prisma.contentComment.create({
     *   data: {
     *     // ... data to create a ContentComment
     *   }
     * })
     * 
     */
    create<T extends ContentCommentCreateArgs>(args: SelectSubset<T, ContentCommentCreateArgs<ExtArgs>>): Prisma__ContentCommentClient<$Result.GetResult<Prisma.$ContentCommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContentComments.
     * @param {ContentCommentCreateManyArgs} args - Arguments to create many ContentComments.
     * @example
     * // Create many ContentComments
     * const contentComment = await prisma.contentComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentCommentCreateManyArgs>(args?: SelectSubset<T, ContentCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentComments and returns the data saved in the database.
     * @param {ContentCommentCreateManyAndReturnArgs} args - Arguments to create many ContentComments.
     * @example
     * // Create many ContentComments
     * const contentComment = await prisma.contentComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentComments and only return the `contentId`
     * const contentCommentWithContentIdOnly = await prisma.contentComment.createManyAndReturn({ 
     *   select: { contentId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentCommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ContentComment.
     * @param {ContentCommentDeleteArgs} args - Arguments to delete one ContentComment.
     * @example
     * // Delete one ContentComment
     * const ContentComment = await prisma.contentComment.delete({
     *   where: {
     *     // ... filter to delete one ContentComment
     *   }
     * })
     * 
     */
    delete<T extends ContentCommentDeleteArgs>(args: SelectSubset<T, ContentCommentDeleteArgs<ExtArgs>>): Prisma__ContentCommentClient<$Result.GetResult<Prisma.$ContentCommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContentComment.
     * @param {ContentCommentUpdateArgs} args - Arguments to update one ContentComment.
     * @example
     * // Update one ContentComment
     * const contentComment = await prisma.contentComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentCommentUpdateArgs>(args: SelectSubset<T, ContentCommentUpdateArgs<ExtArgs>>): Prisma__ContentCommentClient<$Result.GetResult<Prisma.$ContentCommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContentComments.
     * @param {ContentCommentDeleteManyArgs} args - Arguments to filter ContentComments to delete.
     * @example
     * // Delete a few ContentComments
     * const { count } = await prisma.contentComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentCommentDeleteManyArgs>(args?: SelectSubset<T, ContentCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentComments
     * const contentComment = await prisma.contentComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentCommentUpdateManyArgs>(args: SelectSubset<T, ContentCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContentComment.
     * @param {ContentCommentUpsertArgs} args - Arguments to update or create a ContentComment.
     * @example
     * // Update or create a ContentComment
     * const contentComment = await prisma.contentComment.upsert({
     *   create: {
     *     // ... data to create a ContentComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentComment we want to update
     *   }
     * })
     */
    upsert<T extends ContentCommentUpsertArgs>(args: SelectSubset<T, ContentCommentUpsertArgs<ExtArgs>>): Prisma__ContentCommentClient<$Result.GetResult<Prisma.$ContentCommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContentComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCommentCountArgs} args - Arguments to filter ContentComments to count.
     * @example
     * // Count the number of ContentComments
     * const count = await prisma.contentComment.count({
     *   where: {
     *     // ... the filter for the ContentComments we want to count
     *   }
     * })
    **/
    count<T extends ContentCommentCountArgs>(
      args?: Subset<T, ContentCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentCommentAggregateArgs>(args: Subset<T, ContentCommentAggregateArgs>): Prisma.PrismaPromise<GetContentCommentAggregateType<T>>

    /**
     * Group by ContentComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentCommentGroupByArgs['orderBy'] }
        : { orderBy?: ContentCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentComment model
   */
  readonly fields: ContentCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Content<T extends CourseContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseContentDefaultArgs<ExtArgs>>): Prisma__CourseContentClient<$Result.GetResult<Prisma.$CourseContentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Comment<T extends CommentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommentDefaultArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentComment model
   */ 
  interface ContentCommentFieldRefs {
    readonly contentId: FieldRef<"ContentComment", 'Int'>
    readonly commentId: FieldRef<"ContentComment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ContentComment findUnique
   */
  export type ContentCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentComment
     */
    select?: ContentCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCommentInclude<ExtArgs> | null
    /**
     * Filter, which ContentComment to fetch.
     */
    where: ContentCommentWhereUniqueInput
  }

  /**
   * ContentComment findUniqueOrThrow
   */
  export type ContentCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentComment
     */
    select?: ContentCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCommentInclude<ExtArgs> | null
    /**
     * Filter, which ContentComment to fetch.
     */
    where: ContentCommentWhereUniqueInput
  }

  /**
   * ContentComment findFirst
   */
  export type ContentCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentComment
     */
    select?: ContentCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCommentInclude<ExtArgs> | null
    /**
     * Filter, which ContentComment to fetch.
     */
    where?: ContentCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentComments to fetch.
     */
    orderBy?: ContentCommentOrderByWithRelationInput | ContentCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentComments.
     */
    cursor?: ContentCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentComments.
     */
    distinct?: ContentCommentScalarFieldEnum | ContentCommentScalarFieldEnum[]
  }

  /**
   * ContentComment findFirstOrThrow
   */
  export type ContentCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentComment
     */
    select?: ContentCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCommentInclude<ExtArgs> | null
    /**
     * Filter, which ContentComment to fetch.
     */
    where?: ContentCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentComments to fetch.
     */
    orderBy?: ContentCommentOrderByWithRelationInput | ContentCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentComments.
     */
    cursor?: ContentCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentComments.
     */
    distinct?: ContentCommentScalarFieldEnum | ContentCommentScalarFieldEnum[]
  }

  /**
   * ContentComment findMany
   */
  export type ContentCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentComment
     */
    select?: ContentCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCommentInclude<ExtArgs> | null
    /**
     * Filter, which ContentComments to fetch.
     */
    where?: ContentCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentComments to fetch.
     */
    orderBy?: ContentCommentOrderByWithRelationInput | ContentCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentComments.
     */
    cursor?: ContentCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentComments.
     */
    skip?: number
    distinct?: ContentCommentScalarFieldEnum | ContentCommentScalarFieldEnum[]
  }

  /**
   * ContentComment create
   */
  export type ContentCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentComment
     */
    select?: ContentCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentComment.
     */
    data: XOR<ContentCommentCreateInput, ContentCommentUncheckedCreateInput>
  }

  /**
   * ContentComment createMany
   */
  export type ContentCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentComments.
     */
    data: ContentCommentCreateManyInput | ContentCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentComment createManyAndReturn
   */
  export type ContentCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentComment
     */
    select?: ContentCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ContentComments.
     */
    data: ContentCommentCreateManyInput | ContentCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentComment update
   */
  export type ContentCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentComment
     */
    select?: ContentCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentComment.
     */
    data: XOR<ContentCommentUpdateInput, ContentCommentUncheckedUpdateInput>
    /**
     * Choose, which ContentComment to update.
     */
    where: ContentCommentWhereUniqueInput
  }

  /**
   * ContentComment updateMany
   */
  export type ContentCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentComments.
     */
    data: XOR<ContentCommentUpdateManyMutationInput, ContentCommentUncheckedUpdateManyInput>
    /**
     * Filter which ContentComments to update
     */
    where?: ContentCommentWhereInput
  }

  /**
   * ContentComment upsert
   */
  export type ContentCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentComment
     */
    select?: ContentCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentComment to update in case it exists.
     */
    where: ContentCommentWhereUniqueInput
    /**
     * In case the ContentComment found by the `where` argument doesn't exist, create a new ContentComment with this data.
     */
    create: XOR<ContentCommentCreateInput, ContentCommentUncheckedCreateInput>
    /**
     * In case the ContentComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentCommentUpdateInput, ContentCommentUncheckedUpdateInput>
  }

  /**
   * ContentComment delete
   */
  export type ContentCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentComment
     */
    select?: ContentCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCommentInclude<ExtArgs> | null
    /**
     * Filter which ContentComment to delete.
     */
    where: ContentCommentWhereUniqueInput
  }

  /**
   * ContentComment deleteMany
   */
  export type ContentCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentComments to delete
     */
    where?: ContentCommentWhereInput
  }

  /**
   * ContentComment without action
   */
  export type ContentCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentComment
     */
    select?: ContentCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentCommentInclude<ExtArgs> | null
  }


  /**
   * Model Note
   */

  export type AggregateNote = {
    _count: NoteCountAggregateOutputType | null
    _avg: NoteAvgAggregateOutputType | null
    _sum: NoteSumAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  export type NoteAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    status: number | null
  }

  export type NoteSumAggregateOutputType = {
    id: number | null
    userId: number | null
    status: number | null
  }

  export type NoteMinAggregateOutputType = {
    id: number | null
    userId: number | null
    content: string | null
    createAt: Date | null
    updateAt: Date | null
    status: number | null
  }

  export type NoteMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    content: string | null
    createAt: Date | null
    updateAt: Date | null
    status: number | null
  }

  export type NoteCountAggregateOutputType = {
    id: number
    userId: number
    content: number
    createAt: number
    updateAt: number
    status: number
    _all: number
  }


  export type NoteAvgAggregateInputType = {
    id?: true
    userId?: true
    status?: true
  }

  export type NoteSumAggregateInputType = {
    id?: true
    userId?: true
    status?: true
  }

  export type NoteMinAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    createAt?: true
    updateAt?: true
    status?: true
  }

  export type NoteMaxAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    createAt?: true
    updateAt?: true
    status?: true
  }

  export type NoteCountAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    createAt?: true
    updateAt?: true
    status?: true
    _all?: true
  }

  export type NoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Note to aggregate.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notes
    **/
    _count?: true | NoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoteMaxAggregateInputType
  }

  export type GetNoteAggregateType<T extends NoteAggregateArgs> = {
        [P in keyof T & keyof AggregateNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNote[P]>
      : GetScalarType<T[P], AggregateNote[P]>
  }




  export type NoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithAggregationInput | NoteOrderByWithAggregationInput[]
    by: NoteScalarFieldEnum[] | NoteScalarFieldEnum
    having?: NoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoteCountAggregateInputType | true
    _avg?: NoteAvgAggregateInputType
    _sum?: NoteSumAggregateInputType
    _min?: NoteMinAggregateInputType
    _max?: NoteMaxAggregateInputType
  }

  export type NoteGroupByOutputType = {
    id: number
    userId: number
    content: string
    createAt: Date
    updateAt: Date | null
    status: number | null
    _count: NoteCountAggregateOutputType | null
    _avg: NoteAvgAggregateOutputType | null
    _sum: NoteSumAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  type GetNoteGroupByPayload<T extends NoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoteGroupByOutputType[P]>
            : GetScalarType<T[P], NoteGroupByOutputType[P]>
        }
      >
    >


  export type NoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    createAt?: boolean
    updateAt?: boolean
    status?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>

  export type NoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    createAt?: boolean
    updateAt?: boolean
    status?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>

  export type NoteSelectScalar = {
    id?: boolean
    userId?: boolean
    content?: boolean
    createAt?: boolean
    updateAt?: boolean
    status?: boolean
  }

  export type NoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Note"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      content: string
      createAt: Date
      updateAt: Date | null
      status: number | null
    }, ExtArgs["result"]["note"]>
    composites: {}
  }

  type NoteGetPayload<S extends boolean | null | undefined | NoteDefaultArgs> = $Result.GetResult<Prisma.$NotePayload, S>

  type NoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NoteCountAggregateInputType | true
    }

  export interface NoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Note'], meta: { name: 'Note' } }
    /**
     * Find zero or one Note that matches the filter.
     * @param {NoteFindUniqueArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoteFindUniqueArgs>(args: SelectSubset<T, NoteFindUniqueArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Note that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NoteFindUniqueOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoteFindUniqueOrThrowArgs>(args: SelectSubset<T, NoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Note that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoteFindFirstArgs>(args?: SelectSubset<T, NoteFindFirstArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Note that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoteFindFirstOrThrowArgs>(args?: SelectSubset<T, NoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notes
     * const notes = await prisma.note.findMany()
     * 
     * // Get first 10 Notes
     * const notes = await prisma.note.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noteWithIdOnly = await prisma.note.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NoteFindManyArgs>(args?: SelectSubset<T, NoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Note.
     * @param {NoteCreateArgs} args - Arguments to create a Note.
     * @example
     * // Create one Note
     * const Note = await prisma.note.create({
     *   data: {
     *     // ... data to create a Note
     *   }
     * })
     * 
     */
    create<T extends NoteCreateArgs>(args: SelectSubset<T, NoteCreateArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notes.
     * @param {NoteCreateManyArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const note = await prisma.note.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoteCreateManyArgs>(args?: SelectSubset<T, NoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notes and returns the data saved in the database.
     * @param {NoteCreateManyAndReturnArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const note = await prisma.note.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notes and only return the `id`
     * const noteWithIdOnly = await prisma.note.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NoteCreateManyAndReturnArgs>(args?: SelectSubset<T, NoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Note.
     * @param {NoteDeleteArgs} args - Arguments to delete one Note.
     * @example
     * // Delete one Note
     * const Note = await prisma.note.delete({
     *   where: {
     *     // ... filter to delete one Note
     *   }
     * })
     * 
     */
    delete<T extends NoteDeleteArgs>(args: SelectSubset<T, NoteDeleteArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Note.
     * @param {NoteUpdateArgs} args - Arguments to update one Note.
     * @example
     * // Update one Note
     * const note = await prisma.note.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoteUpdateArgs>(args: SelectSubset<T, NoteUpdateArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notes.
     * @param {NoteDeleteManyArgs} args - Arguments to filter Notes to delete.
     * @example
     * // Delete a few Notes
     * const { count } = await prisma.note.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoteDeleteManyArgs>(args?: SelectSubset<T, NoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notes
     * const note = await prisma.note.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoteUpdateManyArgs>(args: SelectSubset<T, NoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Note.
     * @param {NoteUpsertArgs} args - Arguments to update or create a Note.
     * @example
     * // Update or create a Note
     * const note = await prisma.note.upsert({
     *   create: {
     *     // ... data to create a Note
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Note we want to update
     *   }
     * })
     */
    upsert<T extends NoteUpsertArgs>(args: SelectSubset<T, NoteUpsertArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteCountArgs} args - Arguments to filter Notes to count.
     * @example
     * // Count the number of Notes
     * const count = await prisma.note.count({
     *   where: {
     *     // ... the filter for the Notes we want to count
     *   }
     * })
    **/
    count<T extends NoteCountArgs>(
      args?: Subset<T, NoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoteAggregateArgs>(args: Subset<T, NoteAggregateArgs>): Prisma.PrismaPromise<GetNoteAggregateType<T>>

    /**
     * Group by Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoteGroupByArgs['orderBy'] }
        : { orderBy?: NoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Note model
   */
  readonly fields: NoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Note.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Note model
   */ 
  interface NoteFieldRefs {
    readonly id: FieldRef<"Note", 'Int'>
    readonly userId: FieldRef<"Note", 'Int'>
    readonly content: FieldRef<"Note", 'String'>
    readonly createAt: FieldRef<"Note", 'DateTime'>
    readonly updateAt: FieldRef<"Note", 'DateTime'>
    readonly status: FieldRef<"Note", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Note findUnique
   */
  export type NoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note findUniqueOrThrow
   */
  export type NoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note findFirst
   */
  export type NoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note findFirstOrThrow
   */
  export type NoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note findMany
   */
  export type NoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note create
   */
  export type NoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Note.
     */
    data: XOR<NoteCreateInput, NoteUncheckedCreateInput>
  }

  /**
   * Note createMany
   */
  export type NoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notes.
     */
    data: NoteCreateManyInput | NoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Note createManyAndReturn
   */
  export type NoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notes.
     */
    data: NoteCreateManyInput | NoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Note update
   */
  export type NoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Note.
     */
    data: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
    /**
     * Choose, which Note to update.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note updateMany
   */
  export type NoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notes.
     */
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyInput>
    /**
     * Filter which Notes to update
     */
    where?: NoteWhereInput
  }

  /**
   * Note upsert
   */
  export type NoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Note to update in case it exists.
     */
    where: NoteWhereUniqueInput
    /**
     * In case the Note found by the `where` argument doesn't exist, create a new Note with this data.
     */
    create: XOR<NoteCreateInput, NoteUncheckedCreateInput>
    /**
     * In case the Note was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
  }

  /**
   * Note delete
   */
  export type NoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter which Note to delete.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note deleteMany
   */
  export type NoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notes to delete
     */
    where?: NoteWhereInput
  }

  /**
   * Note without action
   */
  export type NoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
  }


  /**
   * Model DictPlatform
   */

  export type AggregateDictPlatform = {
    _count: DictPlatformCountAggregateOutputType | null
    _avg: DictPlatformAvgAggregateOutputType | null
    _sum: DictPlatformSumAggregateOutputType | null
    _min: DictPlatformMinAggregateOutputType | null
    _max: DictPlatformMaxAggregateOutputType | null
  }

  export type DictPlatformAvgAggregateOutputType = {
    id: number | null
  }

  export type DictPlatformSumAggregateOutputType = {
    id: number | null
  }

  export type DictPlatformMinAggregateOutputType = {
    id: number | null
    name: string | null
    url: string | null
  }

  export type DictPlatformMaxAggregateOutputType = {
    id: number | null
    name: string | null
    url: string | null
  }

  export type DictPlatformCountAggregateOutputType = {
    id: number
    name: number
    url: number
    _all: number
  }


  export type DictPlatformAvgAggregateInputType = {
    id?: true
  }

  export type DictPlatformSumAggregateInputType = {
    id?: true
  }

  export type DictPlatformMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
  }

  export type DictPlatformMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
  }

  export type DictPlatformCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    _all?: true
  }

  export type DictPlatformAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DictPlatform to aggregate.
     */
    where?: DictPlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DictPlatforms to fetch.
     */
    orderBy?: DictPlatformOrderByWithRelationInput | DictPlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DictPlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DictPlatforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DictPlatforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DictPlatforms
    **/
    _count?: true | DictPlatformCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DictPlatformAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DictPlatformSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DictPlatformMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DictPlatformMaxAggregateInputType
  }

  export type GetDictPlatformAggregateType<T extends DictPlatformAggregateArgs> = {
        [P in keyof T & keyof AggregateDictPlatform]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDictPlatform[P]>
      : GetScalarType<T[P], AggregateDictPlatform[P]>
  }




  export type DictPlatformGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DictPlatformWhereInput
    orderBy?: DictPlatformOrderByWithAggregationInput | DictPlatformOrderByWithAggregationInput[]
    by: DictPlatformScalarFieldEnum[] | DictPlatformScalarFieldEnum
    having?: DictPlatformScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DictPlatformCountAggregateInputType | true
    _avg?: DictPlatformAvgAggregateInputType
    _sum?: DictPlatformSumAggregateInputType
    _min?: DictPlatformMinAggregateInputType
    _max?: DictPlatformMaxAggregateInputType
  }

  export type DictPlatformGroupByOutputType = {
    id: number
    name: string
    url: string | null
    _count: DictPlatformCountAggregateOutputType | null
    _avg: DictPlatformAvgAggregateOutputType | null
    _sum: DictPlatformSumAggregateOutputType | null
    _min: DictPlatformMinAggregateOutputType | null
    _max: DictPlatformMaxAggregateOutputType | null
  }

  type GetDictPlatformGroupByPayload<T extends DictPlatformGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DictPlatformGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DictPlatformGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DictPlatformGroupByOutputType[P]>
            : GetScalarType<T[P], DictPlatformGroupByOutputType[P]>
        }
      >
    >


  export type DictPlatformSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    Transaction?: boolean | DictPlatform$TransactionArgs<ExtArgs>
    _count?: boolean | DictPlatformCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dictPlatform"]>

  export type DictPlatformSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
  }, ExtArgs["result"]["dictPlatform"]>

  export type DictPlatformSelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
  }

  export type DictPlatformInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Transaction?: boolean | DictPlatform$TransactionArgs<ExtArgs>
    _count?: boolean | DictPlatformCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DictPlatformIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DictPlatformPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DictPlatform"
    objects: {
      Transaction: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      url: string | null
    }, ExtArgs["result"]["dictPlatform"]>
    composites: {}
  }

  type DictPlatformGetPayload<S extends boolean | null | undefined | DictPlatformDefaultArgs> = $Result.GetResult<Prisma.$DictPlatformPayload, S>

  type DictPlatformCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DictPlatformFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DictPlatformCountAggregateInputType | true
    }

  export interface DictPlatformDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DictPlatform'], meta: { name: 'DictPlatform' } }
    /**
     * Find zero or one DictPlatform that matches the filter.
     * @param {DictPlatformFindUniqueArgs} args - Arguments to find a DictPlatform
     * @example
     * // Get one DictPlatform
     * const dictPlatform = await prisma.dictPlatform.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DictPlatformFindUniqueArgs>(args: SelectSubset<T, DictPlatformFindUniqueArgs<ExtArgs>>): Prisma__DictPlatformClient<$Result.GetResult<Prisma.$DictPlatformPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DictPlatform that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DictPlatformFindUniqueOrThrowArgs} args - Arguments to find a DictPlatform
     * @example
     * // Get one DictPlatform
     * const dictPlatform = await prisma.dictPlatform.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DictPlatformFindUniqueOrThrowArgs>(args: SelectSubset<T, DictPlatformFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DictPlatformClient<$Result.GetResult<Prisma.$DictPlatformPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DictPlatform that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictPlatformFindFirstArgs} args - Arguments to find a DictPlatform
     * @example
     * // Get one DictPlatform
     * const dictPlatform = await prisma.dictPlatform.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DictPlatformFindFirstArgs>(args?: SelectSubset<T, DictPlatformFindFirstArgs<ExtArgs>>): Prisma__DictPlatformClient<$Result.GetResult<Prisma.$DictPlatformPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DictPlatform that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictPlatformFindFirstOrThrowArgs} args - Arguments to find a DictPlatform
     * @example
     * // Get one DictPlatform
     * const dictPlatform = await prisma.dictPlatform.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DictPlatformFindFirstOrThrowArgs>(args?: SelectSubset<T, DictPlatformFindFirstOrThrowArgs<ExtArgs>>): Prisma__DictPlatformClient<$Result.GetResult<Prisma.$DictPlatformPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DictPlatforms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictPlatformFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DictPlatforms
     * const dictPlatforms = await prisma.dictPlatform.findMany()
     * 
     * // Get first 10 DictPlatforms
     * const dictPlatforms = await prisma.dictPlatform.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dictPlatformWithIdOnly = await prisma.dictPlatform.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DictPlatformFindManyArgs>(args?: SelectSubset<T, DictPlatformFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DictPlatformPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DictPlatform.
     * @param {DictPlatformCreateArgs} args - Arguments to create a DictPlatform.
     * @example
     * // Create one DictPlatform
     * const DictPlatform = await prisma.dictPlatform.create({
     *   data: {
     *     // ... data to create a DictPlatform
     *   }
     * })
     * 
     */
    create<T extends DictPlatformCreateArgs>(args: SelectSubset<T, DictPlatformCreateArgs<ExtArgs>>): Prisma__DictPlatformClient<$Result.GetResult<Prisma.$DictPlatformPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DictPlatforms.
     * @param {DictPlatformCreateManyArgs} args - Arguments to create many DictPlatforms.
     * @example
     * // Create many DictPlatforms
     * const dictPlatform = await prisma.dictPlatform.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DictPlatformCreateManyArgs>(args?: SelectSubset<T, DictPlatformCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DictPlatforms and returns the data saved in the database.
     * @param {DictPlatformCreateManyAndReturnArgs} args - Arguments to create many DictPlatforms.
     * @example
     * // Create many DictPlatforms
     * const dictPlatform = await prisma.dictPlatform.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DictPlatforms and only return the `id`
     * const dictPlatformWithIdOnly = await prisma.dictPlatform.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DictPlatformCreateManyAndReturnArgs>(args?: SelectSubset<T, DictPlatformCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DictPlatformPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DictPlatform.
     * @param {DictPlatformDeleteArgs} args - Arguments to delete one DictPlatform.
     * @example
     * // Delete one DictPlatform
     * const DictPlatform = await prisma.dictPlatform.delete({
     *   where: {
     *     // ... filter to delete one DictPlatform
     *   }
     * })
     * 
     */
    delete<T extends DictPlatformDeleteArgs>(args: SelectSubset<T, DictPlatformDeleteArgs<ExtArgs>>): Prisma__DictPlatformClient<$Result.GetResult<Prisma.$DictPlatformPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DictPlatform.
     * @param {DictPlatformUpdateArgs} args - Arguments to update one DictPlatform.
     * @example
     * // Update one DictPlatform
     * const dictPlatform = await prisma.dictPlatform.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DictPlatformUpdateArgs>(args: SelectSubset<T, DictPlatformUpdateArgs<ExtArgs>>): Prisma__DictPlatformClient<$Result.GetResult<Prisma.$DictPlatformPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DictPlatforms.
     * @param {DictPlatformDeleteManyArgs} args - Arguments to filter DictPlatforms to delete.
     * @example
     * // Delete a few DictPlatforms
     * const { count } = await prisma.dictPlatform.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DictPlatformDeleteManyArgs>(args?: SelectSubset<T, DictPlatformDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DictPlatforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictPlatformUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DictPlatforms
     * const dictPlatform = await prisma.dictPlatform.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DictPlatformUpdateManyArgs>(args: SelectSubset<T, DictPlatformUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DictPlatform.
     * @param {DictPlatformUpsertArgs} args - Arguments to update or create a DictPlatform.
     * @example
     * // Update or create a DictPlatform
     * const dictPlatform = await prisma.dictPlatform.upsert({
     *   create: {
     *     // ... data to create a DictPlatform
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DictPlatform we want to update
     *   }
     * })
     */
    upsert<T extends DictPlatformUpsertArgs>(args: SelectSubset<T, DictPlatformUpsertArgs<ExtArgs>>): Prisma__DictPlatformClient<$Result.GetResult<Prisma.$DictPlatformPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DictPlatforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictPlatformCountArgs} args - Arguments to filter DictPlatforms to count.
     * @example
     * // Count the number of DictPlatforms
     * const count = await prisma.dictPlatform.count({
     *   where: {
     *     // ... the filter for the DictPlatforms we want to count
     *   }
     * })
    **/
    count<T extends DictPlatformCountArgs>(
      args?: Subset<T, DictPlatformCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DictPlatformCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DictPlatform.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictPlatformAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DictPlatformAggregateArgs>(args: Subset<T, DictPlatformAggregateArgs>): Prisma.PrismaPromise<GetDictPlatformAggregateType<T>>

    /**
     * Group by DictPlatform.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictPlatformGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DictPlatformGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DictPlatformGroupByArgs['orderBy'] }
        : { orderBy?: DictPlatformGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DictPlatformGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDictPlatformGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DictPlatform model
   */
  readonly fields: DictPlatformFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DictPlatform.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DictPlatformClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Transaction<T extends DictPlatform$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, DictPlatform$TransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DictPlatform model
   */ 
  interface DictPlatformFieldRefs {
    readonly id: FieldRef<"DictPlatform", 'Int'>
    readonly name: FieldRef<"DictPlatform", 'String'>
    readonly url: FieldRef<"DictPlatform", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DictPlatform findUnique
   */
  export type DictPlatformFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictPlatform
     */
    select?: DictPlatformSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictPlatformInclude<ExtArgs> | null
    /**
     * Filter, which DictPlatform to fetch.
     */
    where: DictPlatformWhereUniqueInput
  }

  /**
   * DictPlatform findUniqueOrThrow
   */
  export type DictPlatformFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictPlatform
     */
    select?: DictPlatformSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictPlatformInclude<ExtArgs> | null
    /**
     * Filter, which DictPlatform to fetch.
     */
    where: DictPlatformWhereUniqueInput
  }

  /**
   * DictPlatform findFirst
   */
  export type DictPlatformFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictPlatform
     */
    select?: DictPlatformSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictPlatformInclude<ExtArgs> | null
    /**
     * Filter, which DictPlatform to fetch.
     */
    where?: DictPlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DictPlatforms to fetch.
     */
    orderBy?: DictPlatformOrderByWithRelationInput | DictPlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DictPlatforms.
     */
    cursor?: DictPlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DictPlatforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DictPlatforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DictPlatforms.
     */
    distinct?: DictPlatformScalarFieldEnum | DictPlatformScalarFieldEnum[]
  }

  /**
   * DictPlatform findFirstOrThrow
   */
  export type DictPlatformFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictPlatform
     */
    select?: DictPlatformSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictPlatformInclude<ExtArgs> | null
    /**
     * Filter, which DictPlatform to fetch.
     */
    where?: DictPlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DictPlatforms to fetch.
     */
    orderBy?: DictPlatformOrderByWithRelationInput | DictPlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DictPlatforms.
     */
    cursor?: DictPlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DictPlatforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DictPlatforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DictPlatforms.
     */
    distinct?: DictPlatformScalarFieldEnum | DictPlatformScalarFieldEnum[]
  }

  /**
   * DictPlatform findMany
   */
  export type DictPlatformFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictPlatform
     */
    select?: DictPlatformSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictPlatformInclude<ExtArgs> | null
    /**
     * Filter, which DictPlatforms to fetch.
     */
    where?: DictPlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DictPlatforms to fetch.
     */
    orderBy?: DictPlatformOrderByWithRelationInput | DictPlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DictPlatforms.
     */
    cursor?: DictPlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DictPlatforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DictPlatforms.
     */
    skip?: number
    distinct?: DictPlatformScalarFieldEnum | DictPlatformScalarFieldEnum[]
  }

  /**
   * DictPlatform create
   */
  export type DictPlatformCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictPlatform
     */
    select?: DictPlatformSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictPlatformInclude<ExtArgs> | null
    /**
     * The data needed to create a DictPlatform.
     */
    data: XOR<DictPlatformCreateInput, DictPlatformUncheckedCreateInput>
  }

  /**
   * DictPlatform createMany
   */
  export type DictPlatformCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DictPlatforms.
     */
    data: DictPlatformCreateManyInput | DictPlatformCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DictPlatform createManyAndReturn
   */
  export type DictPlatformCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictPlatform
     */
    select?: DictPlatformSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DictPlatforms.
     */
    data: DictPlatformCreateManyInput | DictPlatformCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DictPlatform update
   */
  export type DictPlatformUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictPlatform
     */
    select?: DictPlatformSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictPlatformInclude<ExtArgs> | null
    /**
     * The data needed to update a DictPlatform.
     */
    data: XOR<DictPlatformUpdateInput, DictPlatformUncheckedUpdateInput>
    /**
     * Choose, which DictPlatform to update.
     */
    where: DictPlatformWhereUniqueInput
  }

  /**
   * DictPlatform updateMany
   */
  export type DictPlatformUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DictPlatforms.
     */
    data: XOR<DictPlatformUpdateManyMutationInput, DictPlatformUncheckedUpdateManyInput>
    /**
     * Filter which DictPlatforms to update
     */
    where?: DictPlatformWhereInput
  }

  /**
   * DictPlatform upsert
   */
  export type DictPlatformUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictPlatform
     */
    select?: DictPlatformSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictPlatformInclude<ExtArgs> | null
    /**
     * The filter to search for the DictPlatform to update in case it exists.
     */
    where: DictPlatformWhereUniqueInput
    /**
     * In case the DictPlatform found by the `where` argument doesn't exist, create a new DictPlatform with this data.
     */
    create: XOR<DictPlatformCreateInput, DictPlatformUncheckedCreateInput>
    /**
     * In case the DictPlatform was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DictPlatformUpdateInput, DictPlatformUncheckedUpdateInput>
  }

  /**
   * DictPlatform delete
   */
  export type DictPlatformDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictPlatform
     */
    select?: DictPlatformSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictPlatformInclude<ExtArgs> | null
    /**
     * Filter which DictPlatform to delete.
     */
    where: DictPlatformWhereUniqueInput
  }

  /**
   * DictPlatform deleteMany
   */
  export type DictPlatformDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DictPlatforms to delete
     */
    where?: DictPlatformWhereInput
  }

  /**
   * DictPlatform.Transaction
   */
  export type DictPlatform$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * DictPlatform without action
   */
  export type DictPlatformDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictPlatform
     */
    select?: DictPlatformSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictPlatformInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    id: number | null
    courseId: number | null
    userId: number | null
    amount: number | null
    platformId: number | null
    status: number | null
  }

  export type TransactionSumAggregateOutputType = {
    id: number | null
    courseId: number | null
    userId: number | null
    amount: number | null
    platformId: number | null
    status: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: number | null
    courseId: number | null
    userId: number | null
    amount: number | null
    platformId: number | null
    status: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: number | null
    courseId: number | null
    userId: number | null
    amount: number | null
    platformId: number | null
    status: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    courseId: number
    userId: number
    amount: number
    platformId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    id?: true
    courseId?: true
    userId?: true
    amount?: true
    platformId?: true
    status?: true
  }

  export type TransactionSumAggregateInputType = {
    id?: true
    courseId?: true
    userId?: true
    amount?: true
    platformId?: true
    status?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    courseId?: true
    userId?: true
    amount?: true
    platformId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    courseId?: true
    userId?: true
    amount?: true
    platformId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    courseId?: true
    userId?: true
    amount?: true
    platformId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: number
    courseId: number
    userId: number
    amount: number
    platformId: number
    status: number
    createdAt: Date
    updatedAt: Date | null
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    userId?: boolean
    amount?: boolean
    platformId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Course?: boolean | CourseDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    Platform?: boolean | DictPlatformDefaultArgs<ExtArgs>
    GroupTransaction?: boolean | Transaction$GroupTransactionArgs<ExtArgs>
    BalanceRecord?: boolean | Transaction$BalanceRecordArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    userId?: boolean
    amount?: boolean
    platformId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Course?: boolean | CourseDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    Platform?: boolean | DictPlatformDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    courseId?: boolean
    userId?: boolean
    amount?: boolean
    platformId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Course?: boolean | CourseDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    Platform?: boolean | DictPlatformDefaultArgs<ExtArgs>
    GroupTransaction?: boolean | Transaction$GroupTransactionArgs<ExtArgs>
    BalanceRecord?: boolean | Transaction$BalanceRecordArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Course?: boolean | CourseDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    Platform?: boolean | DictPlatformDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      Course: Prisma.$CoursePayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
      Platform: Prisma.$DictPlatformPayload<ExtArgs>
      GroupTransaction: Prisma.$GroupTransactionPayload<ExtArgs>[]
      BalanceRecord: Prisma.$BalanceRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      courseId: number
      userId: number
      amount: number
      platformId: number
      status: number
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Platform<T extends DictPlatformDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DictPlatformDefaultArgs<ExtArgs>>): Prisma__DictPlatformClient<$Result.GetResult<Prisma.$DictPlatformPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    GroupTransaction<T extends Transaction$GroupTransactionArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$GroupTransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    BalanceRecord<T extends Transaction$BalanceRecordArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$BalanceRecordArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalanceRecordPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */ 
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'Int'>
    readonly courseId: FieldRef<"Transaction", 'Int'>
    readonly userId: FieldRef<"Transaction", 'Int'>
    readonly amount: FieldRef<"Transaction", 'Float'>
    readonly platformId: FieldRef<"Transaction", 'Int'>
    readonly status: FieldRef<"Transaction", 'Int'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction.GroupTransaction
   */
  export type Transaction$GroupTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupTransaction
     */
    select?: GroupTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupTransactionInclude<ExtArgs> | null
    where?: GroupTransactionWhereInput
    orderBy?: GroupTransactionOrderByWithRelationInput | GroupTransactionOrderByWithRelationInput[]
    cursor?: GroupTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupTransactionScalarFieldEnum | GroupTransactionScalarFieldEnum[]
  }

  /**
   * Transaction.BalanceRecord
   */
  export type Transaction$BalanceRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceRecord
     */
    select?: BalanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceRecordInclude<ExtArgs> | null
    where?: BalanceRecordWhereInput
    orderBy?: BalanceRecordOrderByWithRelationInput | BalanceRecordOrderByWithRelationInput[]
    cursor?: BalanceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BalanceRecordScalarFieldEnum | BalanceRecordScalarFieldEnum[]
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model GroupTransaction
   */

  export type AggregateGroupTransaction = {
    _count: GroupTransactionCountAggregateOutputType | null
    _avg: GroupTransactionAvgAggregateOutputType | null
    _sum: GroupTransactionSumAggregateOutputType | null
    _min: GroupTransactionMinAggregateOutputType | null
    _max: GroupTransactionMaxAggregateOutputType | null
  }

  export type GroupTransactionAvgAggregateOutputType = {
    id: number | null
    transactionId: number | null
  }

  export type GroupTransactionSumAggregateOutputType = {
    id: number | null
    transactionId: number | null
  }

  export type GroupTransactionMinAggregateOutputType = {
    id: number | null
    groupId: string | null
    transactionId: number | null
  }

  export type GroupTransactionMaxAggregateOutputType = {
    id: number | null
    groupId: string | null
    transactionId: number | null
  }

  export type GroupTransactionCountAggregateOutputType = {
    id: number
    groupId: number
    transactionId: number
    _all: number
  }


  export type GroupTransactionAvgAggregateInputType = {
    id?: true
    transactionId?: true
  }

  export type GroupTransactionSumAggregateInputType = {
    id?: true
    transactionId?: true
  }

  export type GroupTransactionMinAggregateInputType = {
    id?: true
    groupId?: true
    transactionId?: true
  }

  export type GroupTransactionMaxAggregateInputType = {
    id?: true
    groupId?: true
    transactionId?: true
  }

  export type GroupTransactionCountAggregateInputType = {
    id?: true
    groupId?: true
    transactionId?: true
    _all?: true
  }

  export type GroupTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupTransaction to aggregate.
     */
    where?: GroupTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupTransactions to fetch.
     */
    orderBy?: GroupTransactionOrderByWithRelationInput | GroupTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupTransactions
    **/
    _count?: true | GroupTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupTransactionMaxAggregateInputType
  }

  export type GetGroupTransactionAggregateType<T extends GroupTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupTransaction[P]>
      : GetScalarType<T[P], AggregateGroupTransaction[P]>
  }




  export type GroupTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupTransactionWhereInput
    orderBy?: GroupTransactionOrderByWithAggregationInput | GroupTransactionOrderByWithAggregationInput[]
    by: GroupTransactionScalarFieldEnum[] | GroupTransactionScalarFieldEnum
    having?: GroupTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupTransactionCountAggregateInputType | true
    _avg?: GroupTransactionAvgAggregateInputType
    _sum?: GroupTransactionSumAggregateInputType
    _min?: GroupTransactionMinAggregateInputType
    _max?: GroupTransactionMaxAggregateInputType
  }

  export type GroupTransactionGroupByOutputType = {
    id: number
    groupId: string
    transactionId: number
    _count: GroupTransactionCountAggregateOutputType | null
    _avg: GroupTransactionAvgAggregateOutputType | null
    _sum: GroupTransactionSumAggregateOutputType | null
    _min: GroupTransactionMinAggregateOutputType | null
    _max: GroupTransactionMaxAggregateOutputType | null
  }

  type GetGroupTransactionGroupByPayload<T extends GroupTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], GroupTransactionGroupByOutputType[P]>
        }
      >
    >


  export type GroupTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    transactionId?: boolean
    Transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupTransaction"]>

  export type GroupTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    transactionId?: boolean
    Transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupTransaction"]>

  export type GroupTransactionSelectScalar = {
    id?: boolean
    groupId?: boolean
    transactionId?: boolean
  }

  export type GroupTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type GroupTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }

  export type $GroupTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupTransaction"
    objects: {
      Transaction: Prisma.$TransactionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      groupId: string
      transactionId: number
    }, ExtArgs["result"]["groupTransaction"]>
    composites: {}
  }

  type GroupTransactionGetPayload<S extends boolean | null | undefined | GroupTransactionDefaultArgs> = $Result.GetResult<Prisma.$GroupTransactionPayload, S>

  type GroupTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GroupTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GroupTransactionCountAggregateInputType | true
    }

  export interface GroupTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupTransaction'], meta: { name: 'GroupTransaction' } }
    /**
     * Find zero or one GroupTransaction that matches the filter.
     * @param {GroupTransactionFindUniqueArgs} args - Arguments to find a GroupTransaction
     * @example
     * // Get one GroupTransaction
     * const groupTransaction = await prisma.groupTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupTransactionFindUniqueArgs>(args: SelectSubset<T, GroupTransactionFindUniqueArgs<ExtArgs>>): Prisma__GroupTransactionClient<$Result.GetResult<Prisma.$GroupTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GroupTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GroupTransactionFindUniqueOrThrowArgs} args - Arguments to find a GroupTransaction
     * @example
     * // Get one GroupTransaction
     * const groupTransaction = await prisma.groupTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupTransactionClient<$Result.GetResult<Prisma.$GroupTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GroupTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupTransactionFindFirstArgs} args - Arguments to find a GroupTransaction
     * @example
     * // Get one GroupTransaction
     * const groupTransaction = await prisma.groupTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupTransactionFindFirstArgs>(args?: SelectSubset<T, GroupTransactionFindFirstArgs<ExtArgs>>): Prisma__GroupTransactionClient<$Result.GetResult<Prisma.$GroupTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GroupTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupTransactionFindFirstOrThrowArgs} args - Arguments to find a GroupTransaction
     * @example
     * // Get one GroupTransaction
     * const groupTransaction = await prisma.groupTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupTransactionClient<$Result.GetResult<Prisma.$GroupTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GroupTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupTransactions
     * const groupTransactions = await prisma.groupTransaction.findMany()
     * 
     * // Get first 10 GroupTransactions
     * const groupTransactions = await prisma.groupTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupTransactionWithIdOnly = await prisma.groupTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupTransactionFindManyArgs>(args?: SelectSubset<T, GroupTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GroupTransaction.
     * @param {GroupTransactionCreateArgs} args - Arguments to create a GroupTransaction.
     * @example
     * // Create one GroupTransaction
     * const GroupTransaction = await prisma.groupTransaction.create({
     *   data: {
     *     // ... data to create a GroupTransaction
     *   }
     * })
     * 
     */
    create<T extends GroupTransactionCreateArgs>(args: SelectSubset<T, GroupTransactionCreateArgs<ExtArgs>>): Prisma__GroupTransactionClient<$Result.GetResult<Prisma.$GroupTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GroupTransactions.
     * @param {GroupTransactionCreateManyArgs} args - Arguments to create many GroupTransactions.
     * @example
     * // Create many GroupTransactions
     * const groupTransaction = await prisma.groupTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupTransactionCreateManyArgs>(args?: SelectSubset<T, GroupTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupTransactions and returns the data saved in the database.
     * @param {GroupTransactionCreateManyAndReturnArgs} args - Arguments to create many GroupTransactions.
     * @example
     * // Create many GroupTransactions
     * const groupTransaction = await prisma.groupTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupTransactions and only return the `id`
     * const groupTransactionWithIdOnly = await prisma.groupTransaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupTransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GroupTransaction.
     * @param {GroupTransactionDeleteArgs} args - Arguments to delete one GroupTransaction.
     * @example
     * // Delete one GroupTransaction
     * const GroupTransaction = await prisma.groupTransaction.delete({
     *   where: {
     *     // ... filter to delete one GroupTransaction
     *   }
     * })
     * 
     */
    delete<T extends GroupTransactionDeleteArgs>(args: SelectSubset<T, GroupTransactionDeleteArgs<ExtArgs>>): Prisma__GroupTransactionClient<$Result.GetResult<Prisma.$GroupTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GroupTransaction.
     * @param {GroupTransactionUpdateArgs} args - Arguments to update one GroupTransaction.
     * @example
     * // Update one GroupTransaction
     * const groupTransaction = await prisma.groupTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupTransactionUpdateArgs>(args: SelectSubset<T, GroupTransactionUpdateArgs<ExtArgs>>): Prisma__GroupTransactionClient<$Result.GetResult<Prisma.$GroupTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GroupTransactions.
     * @param {GroupTransactionDeleteManyArgs} args - Arguments to filter GroupTransactions to delete.
     * @example
     * // Delete a few GroupTransactions
     * const { count } = await prisma.groupTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupTransactionDeleteManyArgs>(args?: SelectSubset<T, GroupTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupTransactions
     * const groupTransaction = await prisma.groupTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupTransactionUpdateManyArgs>(args: SelectSubset<T, GroupTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GroupTransaction.
     * @param {GroupTransactionUpsertArgs} args - Arguments to update or create a GroupTransaction.
     * @example
     * // Update or create a GroupTransaction
     * const groupTransaction = await prisma.groupTransaction.upsert({
     *   create: {
     *     // ... data to create a GroupTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupTransaction we want to update
     *   }
     * })
     */
    upsert<T extends GroupTransactionUpsertArgs>(args: SelectSubset<T, GroupTransactionUpsertArgs<ExtArgs>>): Prisma__GroupTransactionClient<$Result.GetResult<Prisma.$GroupTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GroupTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupTransactionCountArgs} args - Arguments to filter GroupTransactions to count.
     * @example
     * // Count the number of GroupTransactions
     * const count = await prisma.groupTransaction.count({
     *   where: {
     *     // ... the filter for the GroupTransactions we want to count
     *   }
     * })
    **/
    count<T extends GroupTransactionCountArgs>(
      args?: Subset<T, GroupTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupTransactionAggregateArgs>(args: Subset<T, GroupTransactionAggregateArgs>): Prisma.PrismaPromise<GetGroupTransactionAggregateType<T>>

    /**
     * Group by GroupTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupTransactionGroupByArgs['orderBy'] }
        : { orderBy?: GroupTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupTransaction model
   */
  readonly fields: GroupTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupTransaction model
   */ 
  interface GroupTransactionFieldRefs {
    readonly id: FieldRef<"GroupTransaction", 'Int'>
    readonly groupId: FieldRef<"GroupTransaction", 'String'>
    readonly transactionId: FieldRef<"GroupTransaction", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * GroupTransaction findUnique
   */
  export type GroupTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupTransaction
     */
    select?: GroupTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupTransactionInclude<ExtArgs> | null
    /**
     * Filter, which GroupTransaction to fetch.
     */
    where: GroupTransactionWhereUniqueInput
  }

  /**
   * GroupTransaction findUniqueOrThrow
   */
  export type GroupTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupTransaction
     */
    select?: GroupTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupTransactionInclude<ExtArgs> | null
    /**
     * Filter, which GroupTransaction to fetch.
     */
    where: GroupTransactionWhereUniqueInput
  }

  /**
   * GroupTransaction findFirst
   */
  export type GroupTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupTransaction
     */
    select?: GroupTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupTransactionInclude<ExtArgs> | null
    /**
     * Filter, which GroupTransaction to fetch.
     */
    where?: GroupTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupTransactions to fetch.
     */
    orderBy?: GroupTransactionOrderByWithRelationInput | GroupTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupTransactions.
     */
    cursor?: GroupTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupTransactions.
     */
    distinct?: GroupTransactionScalarFieldEnum | GroupTransactionScalarFieldEnum[]
  }

  /**
   * GroupTransaction findFirstOrThrow
   */
  export type GroupTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupTransaction
     */
    select?: GroupTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupTransactionInclude<ExtArgs> | null
    /**
     * Filter, which GroupTransaction to fetch.
     */
    where?: GroupTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupTransactions to fetch.
     */
    orderBy?: GroupTransactionOrderByWithRelationInput | GroupTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupTransactions.
     */
    cursor?: GroupTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupTransactions.
     */
    distinct?: GroupTransactionScalarFieldEnum | GroupTransactionScalarFieldEnum[]
  }

  /**
   * GroupTransaction findMany
   */
  export type GroupTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupTransaction
     */
    select?: GroupTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupTransactionInclude<ExtArgs> | null
    /**
     * Filter, which GroupTransactions to fetch.
     */
    where?: GroupTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupTransactions to fetch.
     */
    orderBy?: GroupTransactionOrderByWithRelationInput | GroupTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupTransactions.
     */
    cursor?: GroupTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupTransactions.
     */
    skip?: number
    distinct?: GroupTransactionScalarFieldEnum | GroupTransactionScalarFieldEnum[]
  }

  /**
   * GroupTransaction create
   */
  export type GroupTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupTransaction
     */
    select?: GroupTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupTransaction.
     */
    data: XOR<GroupTransactionCreateInput, GroupTransactionUncheckedCreateInput>
  }

  /**
   * GroupTransaction createMany
   */
  export type GroupTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupTransactions.
     */
    data: GroupTransactionCreateManyInput | GroupTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupTransaction createManyAndReturn
   */
  export type GroupTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupTransaction
     */
    select?: GroupTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GroupTransactions.
     */
    data: GroupTransactionCreateManyInput | GroupTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupTransaction update
   */
  export type GroupTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupTransaction
     */
    select?: GroupTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupTransaction.
     */
    data: XOR<GroupTransactionUpdateInput, GroupTransactionUncheckedUpdateInput>
    /**
     * Choose, which GroupTransaction to update.
     */
    where: GroupTransactionWhereUniqueInput
  }

  /**
   * GroupTransaction updateMany
   */
  export type GroupTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupTransactions.
     */
    data: XOR<GroupTransactionUpdateManyMutationInput, GroupTransactionUncheckedUpdateManyInput>
    /**
     * Filter which GroupTransactions to update
     */
    where?: GroupTransactionWhereInput
  }

  /**
   * GroupTransaction upsert
   */
  export type GroupTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupTransaction
     */
    select?: GroupTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupTransaction to update in case it exists.
     */
    where: GroupTransactionWhereUniqueInput
    /**
     * In case the GroupTransaction found by the `where` argument doesn't exist, create a new GroupTransaction with this data.
     */
    create: XOR<GroupTransactionCreateInput, GroupTransactionUncheckedCreateInput>
    /**
     * In case the GroupTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupTransactionUpdateInput, GroupTransactionUncheckedUpdateInput>
  }

  /**
   * GroupTransaction delete
   */
  export type GroupTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupTransaction
     */
    select?: GroupTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupTransactionInclude<ExtArgs> | null
    /**
     * Filter which GroupTransaction to delete.
     */
    where: GroupTransactionWhereUniqueInput
  }

  /**
   * GroupTransaction deleteMany
   */
  export type GroupTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupTransactions to delete
     */
    where?: GroupTransactionWhereInput
  }

  /**
   * GroupTransaction without action
   */
  export type GroupTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupTransaction
     */
    select?: GroupTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupTransactionInclude<ExtArgs> | null
  }


  /**
   * Model AuditFlow
   */

  export type AggregateAuditFlow = {
    _count: AuditFlowCountAggregateOutputType | null
    _avg: AuditFlowAvgAggregateOutputType | null
    _sum: AuditFlowSumAggregateOutputType | null
    _min: AuditFlowMinAggregateOutputType | null
    _max: AuditFlowMaxAggregateOutputType | null
  }

  export type AuditFlowAvgAggregateOutputType = {
    id: number | null
  }

  export type AuditFlowSumAggregateOutputType = {
    id: number | null
  }

  export type AuditFlowMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type AuditFlowMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type AuditFlowCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type AuditFlowAvgAggregateInputType = {
    id?: true
  }

  export type AuditFlowSumAggregateInputType = {
    id?: true
  }

  export type AuditFlowMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type AuditFlowMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type AuditFlowCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type AuditFlowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditFlow to aggregate.
     */
    where?: AuditFlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditFlows to fetch.
     */
    orderBy?: AuditFlowOrderByWithRelationInput | AuditFlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditFlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditFlows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditFlows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditFlows
    **/
    _count?: true | AuditFlowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditFlowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditFlowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditFlowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditFlowMaxAggregateInputType
  }

  export type GetAuditFlowAggregateType<T extends AuditFlowAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditFlow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditFlow[P]>
      : GetScalarType<T[P], AggregateAuditFlow[P]>
  }




  export type AuditFlowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditFlowWhereInput
    orderBy?: AuditFlowOrderByWithAggregationInput | AuditFlowOrderByWithAggregationInput[]
    by: AuditFlowScalarFieldEnum[] | AuditFlowScalarFieldEnum
    having?: AuditFlowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditFlowCountAggregateInputType | true
    _avg?: AuditFlowAvgAggregateInputType
    _sum?: AuditFlowSumAggregateInputType
    _min?: AuditFlowMinAggregateInputType
    _max?: AuditFlowMaxAggregateInputType
  }

  export type AuditFlowGroupByOutputType = {
    id: number
    name: string
    description: string | null
    _count: AuditFlowCountAggregateOutputType | null
    _avg: AuditFlowAvgAggregateOutputType | null
    _sum: AuditFlowSumAggregateOutputType | null
    _min: AuditFlowMinAggregateOutputType | null
    _max: AuditFlowMaxAggregateOutputType | null
  }

  type GetAuditFlowGroupByPayload<T extends AuditFlowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditFlowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditFlowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditFlowGroupByOutputType[P]>
            : GetScalarType<T[P], AuditFlowGroupByOutputType[P]>
        }
      >
    >


  export type AuditFlowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    AuditStage?: boolean | AuditFlow$AuditStageArgs<ExtArgs>
    _count?: boolean | AuditFlowCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditFlow"]>

  export type AuditFlowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["auditFlow"]>

  export type AuditFlowSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type AuditFlowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AuditStage?: boolean | AuditFlow$AuditStageArgs<ExtArgs>
    _count?: boolean | AuditFlowCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AuditFlowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AuditFlowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditFlow"
    objects: {
      AuditStage: Prisma.$AuditStagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
    }, ExtArgs["result"]["auditFlow"]>
    composites: {}
  }

  type AuditFlowGetPayload<S extends boolean | null | undefined | AuditFlowDefaultArgs> = $Result.GetResult<Prisma.$AuditFlowPayload, S>

  type AuditFlowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditFlowFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditFlowCountAggregateInputType | true
    }

  export interface AuditFlowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditFlow'], meta: { name: 'AuditFlow' } }
    /**
     * Find zero or one AuditFlow that matches the filter.
     * @param {AuditFlowFindUniqueArgs} args - Arguments to find a AuditFlow
     * @example
     * // Get one AuditFlow
     * const auditFlow = await prisma.auditFlow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditFlowFindUniqueArgs>(args: SelectSubset<T, AuditFlowFindUniqueArgs<ExtArgs>>): Prisma__AuditFlowClient<$Result.GetResult<Prisma.$AuditFlowPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditFlow that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditFlowFindUniqueOrThrowArgs} args - Arguments to find a AuditFlow
     * @example
     * // Get one AuditFlow
     * const auditFlow = await prisma.auditFlow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditFlowFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditFlowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditFlowClient<$Result.GetResult<Prisma.$AuditFlowPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditFlow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditFlowFindFirstArgs} args - Arguments to find a AuditFlow
     * @example
     * // Get one AuditFlow
     * const auditFlow = await prisma.auditFlow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditFlowFindFirstArgs>(args?: SelectSubset<T, AuditFlowFindFirstArgs<ExtArgs>>): Prisma__AuditFlowClient<$Result.GetResult<Prisma.$AuditFlowPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditFlow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditFlowFindFirstOrThrowArgs} args - Arguments to find a AuditFlow
     * @example
     * // Get one AuditFlow
     * const auditFlow = await prisma.auditFlow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditFlowFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditFlowFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditFlowClient<$Result.GetResult<Prisma.$AuditFlowPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditFlows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditFlowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditFlows
     * const auditFlows = await prisma.auditFlow.findMany()
     * 
     * // Get first 10 AuditFlows
     * const auditFlows = await prisma.auditFlow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditFlowWithIdOnly = await prisma.auditFlow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditFlowFindManyArgs>(args?: SelectSubset<T, AuditFlowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditFlowPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditFlow.
     * @param {AuditFlowCreateArgs} args - Arguments to create a AuditFlow.
     * @example
     * // Create one AuditFlow
     * const AuditFlow = await prisma.auditFlow.create({
     *   data: {
     *     // ... data to create a AuditFlow
     *   }
     * })
     * 
     */
    create<T extends AuditFlowCreateArgs>(args: SelectSubset<T, AuditFlowCreateArgs<ExtArgs>>): Prisma__AuditFlowClient<$Result.GetResult<Prisma.$AuditFlowPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditFlows.
     * @param {AuditFlowCreateManyArgs} args - Arguments to create many AuditFlows.
     * @example
     * // Create many AuditFlows
     * const auditFlow = await prisma.auditFlow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditFlowCreateManyArgs>(args?: SelectSubset<T, AuditFlowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditFlows and returns the data saved in the database.
     * @param {AuditFlowCreateManyAndReturnArgs} args - Arguments to create many AuditFlows.
     * @example
     * // Create many AuditFlows
     * const auditFlow = await prisma.auditFlow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditFlows and only return the `id`
     * const auditFlowWithIdOnly = await prisma.auditFlow.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditFlowCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditFlowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditFlowPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditFlow.
     * @param {AuditFlowDeleteArgs} args - Arguments to delete one AuditFlow.
     * @example
     * // Delete one AuditFlow
     * const AuditFlow = await prisma.auditFlow.delete({
     *   where: {
     *     // ... filter to delete one AuditFlow
     *   }
     * })
     * 
     */
    delete<T extends AuditFlowDeleteArgs>(args: SelectSubset<T, AuditFlowDeleteArgs<ExtArgs>>): Prisma__AuditFlowClient<$Result.GetResult<Prisma.$AuditFlowPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditFlow.
     * @param {AuditFlowUpdateArgs} args - Arguments to update one AuditFlow.
     * @example
     * // Update one AuditFlow
     * const auditFlow = await prisma.auditFlow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditFlowUpdateArgs>(args: SelectSubset<T, AuditFlowUpdateArgs<ExtArgs>>): Prisma__AuditFlowClient<$Result.GetResult<Prisma.$AuditFlowPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditFlows.
     * @param {AuditFlowDeleteManyArgs} args - Arguments to filter AuditFlows to delete.
     * @example
     * // Delete a few AuditFlows
     * const { count } = await prisma.auditFlow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditFlowDeleteManyArgs>(args?: SelectSubset<T, AuditFlowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditFlows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditFlowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditFlows
     * const auditFlow = await prisma.auditFlow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditFlowUpdateManyArgs>(args: SelectSubset<T, AuditFlowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditFlow.
     * @param {AuditFlowUpsertArgs} args - Arguments to update or create a AuditFlow.
     * @example
     * // Update or create a AuditFlow
     * const auditFlow = await prisma.auditFlow.upsert({
     *   create: {
     *     // ... data to create a AuditFlow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditFlow we want to update
     *   }
     * })
     */
    upsert<T extends AuditFlowUpsertArgs>(args: SelectSubset<T, AuditFlowUpsertArgs<ExtArgs>>): Prisma__AuditFlowClient<$Result.GetResult<Prisma.$AuditFlowPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditFlows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditFlowCountArgs} args - Arguments to filter AuditFlows to count.
     * @example
     * // Count the number of AuditFlows
     * const count = await prisma.auditFlow.count({
     *   where: {
     *     // ... the filter for the AuditFlows we want to count
     *   }
     * })
    **/
    count<T extends AuditFlowCountArgs>(
      args?: Subset<T, AuditFlowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditFlowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditFlow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditFlowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditFlowAggregateArgs>(args: Subset<T, AuditFlowAggregateArgs>): Prisma.PrismaPromise<GetAuditFlowAggregateType<T>>

    /**
     * Group by AuditFlow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditFlowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditFlowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditFlowGroupByArgs['orderBy'] }
        : { orderBy?: AuditFlowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditFlowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditFlowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditFlow model
   */
  readonly fields: AuditFlowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditFlow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditFlowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AuditStage<T extends AuditFlow$AuditStageArgs<ExtArgs> = {}>(args?: Subset<T, AuditFlow$AuditStageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditStagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditFlow model
   */ 
  interface AuditFlowFieldRefs {
    readonly id: FieldRef<"AuditFlow", 'Int'>
    readonly name: FieldRef<"AuditFlow", 'String'>
    readonly description: FieldRef<"AuditFlow", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AuditFlow findUnique
   */
  export type AuditFlowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditFlow
     */
    select?: AuditFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditFlowInclude<ExtArgs> | null
    /**
     * Filter, which AuditFlow to fetch.
     */
    where: AuditFlowWhereUniqueInput
  }

  /**
   * AuditFlow findUniqueOrThrow
   */
  export type AuditFlowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditFlow
     */
    select?: AuditFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditFlowInclude<ExtArgs> | null
    /**
     * Filter, which AuditFlow to fetch.
     */
    where: AuditFlowWhereUniqueInput
  }

  /**
   * AuditFlow findFirst
   */
  export type AuditFlowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditFlow
     */
    select?: AuditFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditFlowInclude<ExtArgs> | null
    /**
     * Filter, which AuditFlow to fetch.
     */
    where?: AuditFlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditFlows to fetch.
     */
    orderBy?: AuditFlowOrderByWithRelationInput | AuditFlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditFlows.
     */
    cursor?: AuditFlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditFlows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditFlows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditFlows.
     */
    distinct?: AuditFlowScalarFieldEnum | AuditFlowScalarFieldEnum[]
  }

  /**
   * AuditFlow findFirstOrThrow
   */
  export type AuditFlowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditFlow
     */
    select?: AuditFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditFlowInclude<ExtArgs> | null
    /**
     * Filter, which AuditFlow to fetch.
     */
    where?: AuditFlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditFlows to fetch.
     */
    orderBy?: AuditFlowOrderByWithRelationInput | AuditFlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditFlows.
     */
    cursor?: AuditFlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditFlows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditFlows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditFlows.
     */
    distinct?: AuditFlowScalarFieldEnum | AuditFlowScalarFieldEnum[]
  }

  /**
   * AuditFlow findMany
   */
  export type AuditFlowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditFlow
     */
    select?: AuditFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditFlowInclude<ExtArgs> | null
    /**
     * Filter, which AuditFlows to fetch.
     */
    where?: AuditFlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditFlows to fetch.
     */
    orderBy?: AuditFlowOrderByWithRelationInput | AuditFlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditFlows.
     */
    cursor?: AuditFlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditFlows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditFlows.
     */
    skip?: number
    distinct?: AuditFlowScalarFieldEnum | AuditFlowScalarFieldEnum[]
  }

  /**
   * AuditFlow create
   */
  export type AuditFlowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditFlow
     */
    select?: AuditFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditFlowInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditFlow.
     */
    data: XOR<AuditFlowCreateInput, AuditFlowUncheckedCreateInput>
  }

  /**
   * AuditFlow createMany
   */
  export type AuditFlowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditFlows.
     */
    data: AuditFlowCreateManyInput | AuditFlowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditFlow createManyAndReturn
   */
  export type AuditFlowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditFlow
     */
    select?: AuditFlowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditFlows.
     */
    data: AuditFlowCreateManyInput | AuditFlowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditFlow update
   */
  export type AuditFlowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditFlow
     */
    select?: AuditFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditFlowInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditFlow.
     */
    data: XOR<AuditFlowUpdateInput, AuditFlowUncheckedUpdateInput>
    /**
     * Choose, which AuditFlow to update.
     */
    where: AuditFlowWhereUniqueInput
  }

  /**
   * AuditFlow updateMany
   */
  export type AuditFlowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditFlows.
     */
    data: XOR<AuditFlowUpdateManyMutationInput, AuditFlowUncheckedUpdateManyInput>
    /**
     * Filter which AuditFlows to update
     */
    where?: AuditFlowWhereInput
  }

  /**
   * AuditFlow upsert
   */
  export type AuditFlowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditFlow
     */
    select?: AuditFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditFlowInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditFlow to update in case it exists.
     */
    where: AuditFlowWhereUniqueInput
    /**
     * In case the AuditFlow found by the `where` argument doesn't exist, create a new AuditFlow with this data.
     */
    create: XOR<AuditFlowCreateInput, AuditFlowUncheckedCreateInput>
    /**
     * In case the AuditFlow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditFlowUpdateInput, AuditFlowUncheckedUpdateInput>
  }

  /**
   * AuditFlow delete
   */
  export type AuditFlowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditFlow
     */
    select?: AuditFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditFlowInclude<ExtArgs> | null
    /**
     * Filter which AuditFlow to delete.
     */
    where: AuditFlowWhereUniqueInput
  }

  /**
   * AuditFlow deleteMany
   */
  export type AuditFlowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditFlows to delete
     */
    where?: AuditFlowWhereInput
  }

  /**
   * AuditFlow.AuditStage
   */
  export type AuditFlow$AuditStageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStage
     */
    select?: AuditStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStageInclude<ExtArgs> | null
    where?: AuditStageWhereInput
    orderBy?: AuditStageOrderByWithRelationInput | AuditStageOrderByWithRelationInput[]
    cursor?: AuditStageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditStageScalarFieldEnum | AuditStageScalarFieldEnum[]
  }

  /**
   * AuditFlow without action
   */
  export type AuditFlowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditFlow
     */
    select?: AuditFlowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditFlowInclude<ExtArgs> | null
  }


  /**
   * Model AuditStage
   */

  export type AggregateAuditStage = {
    _count: AuditStageCountAggregateOutputType | null
    _avg: AuditStageAvgAggregateOutputType | null
    _sum: AuditStageSumAggregateOutputType | null
    _min: AuditStageMinAggregateOutputType | null
    _max: AuditStageMaxAggregateOutputType | null
  }

  export type AuditStageAvgAggregateOutputType = {
    id: number | null
    flowId: number | null
    level: number | null
    pid: number | null
  }

  export type AuditStageSumAggregateOutputType = {
    id: number | null
    flowId: number | null
    level: number | null
    pid: number | null
  }

  export type AuditStageMinAggregateOutputType = {
    id: number | null
    flowId: number | null
    name: string | null
    level: number | null
    pid: number | null
  }

  export type AuditStageMaxAggregateOutputType = {
    id: number | null
    flowId: number | null
    name: string | null
    level: number | null
    pid: number | null
  }

  export type AuditStageCountAggregateOutputType = {
    id: number
    flowId: number
    name: number
    level: number
    pid: number
    _all: number
  }


  export type AuditStageAvgAggregateInputType = {
    id?: true
    flowId?: true
    level?: true
    pid?: true
  }

  export type AuditStageSumAggregateInputType = {
    id?: true
    flowId?: true
    level?: true
    pid?: true
  }

  export type AuditStageMinAggregateInputType = {
    id?: true
    flowId?: true
    name?: true
    level?: true
    pid?: true
  }

  export type AuditStageMaxAggregateInputType = {
    id?: true
    flowId?: true
    name?: true
    level?: true
    pid?: true
  }

  export type AuditStageCountAggregateInputType = {
    id?: true
    flowId?: true
    name?: true
    level?: true
    pid?: true
    _all?: true
  }

  export type AuditStageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditStage to aggregate.
     */
    where?: AuditStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditStages to fetch.
     */
    orderBy?: AuditStageOrderByWithRelationInput | AuditStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditStages
    **/
    _count?: true | AuditStageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditStageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditStageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditStageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditStageMaxAggregateInputType
  }

  export type GetAuditStageAggregateType<T extends AuditStageAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditStage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditStage[P]>
      : GetScalarType<T[P], AggregateAuditStage[P]>
  }




  export type AuditStageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditStageWhereInput
    orderBy?: AuditStageOrderByWithAggregationInput | AuditStageOrderByWithAggregationInput[]
    by: AuditStageScalarFieldEnum[] | AuditStageScalarFieldEnum
    having?: AuditStageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditStageCountAggregateInputType | true
    _avg?: AuditStageAvgAggregateInputType
    _sum?: AuditStageSumAggregateInputType
    _min?: AuditStageMinAggregateInputType
    _max?: AuditStageMaxAggregateInputType
  }

  export type AuditStageGroupByOutputType = {
    id: number
    flowId: number
    name: string
    level: number
    pid: number | null
    _count: AuditStageCountAggregateOutputType | null
    _avg: AuditStageAvgAggregateOutputType | null
    _sum: AuditStageSumAggregateOutputType | null
    _min: AuditStageMinAggregateOutputType | null
    _max: AuditStageMaxAggregateOutputType | null
  }

  type GetAuditStageGroupByPayload<T extends AuditStageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditStageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditStageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditStageGroupByOutputType[P]>
            : GetScalarType<T[P], AuditStageGroupByOutputType[P]>
        }
      >
    >


  export type AuditStageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    name?: boolean
    level?: boolean
    pid?: boolean
    Flow?: boolean | AuditFlowDefaultArgs<ExtArgs>
    parent?: boolean | AuditStage$parentArgs<ExtArgs>
    children?: boolean | AuditStage$childrenArgs<ExtArgs>
    AuditRecord?: boolean | AuditStage$AuditRecordArgs<ExtArgs>
    _count?: boolean | AuditStageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditStage"]>

  export type AuditStageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowId?: boolean
    name?: boolean
    level?: boolean
    pid?: boolean
    Flow?: boolean | AuditFlowDefaultArgs<ExtArgs>
    parent?: boolean | AuditStage$parentArgs<ExtArgs>
  }, ExtArgs["result"]["auditStage"]>

  export type AuditStageSelectScalar = {
    id?: boolean
    flowId?: boolean
    name?: boolean
    level?: boolean
    pid?: boolean
  }

  export type AuditStageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Flow?: boolean | AuditFlowDefaultArgs<ExtArgs>
    parent?: boolean | AuditStage$parentArgs<ExtArgs>
    children?: boolean | AuditStage$childrenArgs<ExtArgs>
    AuditRecord?: boolean | AuditStage$AuditRecordArgs<ExtArgs>
    _count?: boolean | AuditStageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AuditStageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Flow?: boolean | AuditFlowDefaultArgs<ExtArgs>
    parent?: boolean | AuditStage$parentArgs<ExtArgs>
  }

  export type $AuditStagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditStage"
    objects: {
      Flow: Prisma.$AuditFlowPayload<ExtArgs>
      parent: Prisma.$AuditStagePayload<ExtArgs> | null
      children: Prisma.$AuditStagePayload<ExtArgs>[]
      AuditRecord: Prisma.$AuditRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      flowId: number
      name: string
      level: number
      pid: number | null
    }, ExtArgs["result"]["auditStage"]>
    composites: {}
  }

  type AuditStageGetPayload<S extends boolean | null | undefined | AuditStageDefaultArgs> = $Result.GetResult<Prisma.$AuditStagePayload, S>

  type AuditStageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditStageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditStageCountAggregateInputType | true
    }

  export interface AuditStageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditStage'], meta: { name: 'AuditStage' } }
    /**
     * Find zero or one AuditStage that matches the filter.
     * @param {AuditStageFindUniqueArgs} args - Arguments to find a AuditStage
     * @example
     * // Get one AuditStage
     * const auditStage = await prisma.auditStage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditStageFindUniqueArgs>(args: SelectSubset<T, AuditStageFindUniqueArgs<ExtArgs>>): Prisma__AuditStageClient<$Result.GetResult<Prisma.$AuditStagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditStage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditStageFindUniqueOrThrowArgs} args - Arguments to find a AuditStage
     * @example
     * // Get one AuditStage
     * const auditStage = await prisma.auditStage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditStageFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditStageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditStageClient<$Result.GetResult<Prisma.$AuditStagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditStage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditStageFindFirstArgs} args - Arguments to find a AuditStage
     * @example
     * // Get one AuditStage
     * const auditStage = await prisma.auditStage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditStageFindFirstArgs>(args?: SelectSubset<T, AuditStageFindFirstArgs<ExtArgs>>): Prisma__AuditStageClient<$Result.GetResult<Prisma.$AuditStagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditStage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditStageFindFirstOrThrowArgs} args - Arguments to find a AuditStage
     * @example
     * // Get one AuditStage
     * const auditStage = await prisma.auditStage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditStageFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditStageFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditStageClient<$Result.GetResult<Prisma.$AuditStagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditStages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditStageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditStages
     * const auditStages = await prisma.auditStage.findMany()
     * 
     * // Get first 10 AuditStages
     * const auditStages = await prisma.auditStage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditStageWithIdOnly = await prisma.auditStage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditStageFindManyArgs>(args?: SelectSubset<T, AuditStageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditStagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditStage.
     * @param {AuditStageCreateArgs} args - Arguments to create a AuditStage.
     * @example
     * // Create one AuditStage
     * const AuditStage = await prisma.auditStage.create({
     *   data: {
     *     // ... data to create a AuditStage
     *   }
     * })
     * 
     */
    create<T extends AuditStageCreateArgs>(args: SelectSubset<T, AuditStageCreateArgs<ExtArgs>>): Prisma__AuditStageClient<$Result.GetResult<Prisma.$AuditStagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditStages.
     * @param {AuditStageCreateManyArgs} args - Arguments to create many AuditStages.
     * @example
     * // Create many AuditStages
     * const auditStage = await prisma.auditStage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditStageCreateManyArgs>(args?: SelectSubset<T, AuditStageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditStages and returns the data saved in the database.
     * @param {AuditStageCreateManyAndReturnArgs} args - Arguments to create many AuditStages.
     * @example
     * // Create many AuditStages
     * const auditStage = await prisma.auditStage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditStages and only return the `id`
     * const auditStageWithIdOnly = await prisma.auditStage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditStageCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditStageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditStagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditStage.
     * @param {AuditStageDeleteArgs} args - Arguments to delete one AuditStage.
     * @example
     * // Delete one AuditStage
     * const AuditStage = await prisma.auditStage.delete({
     *   where: {
     *     // ... filter to delete one AuditStage
     *   }
     * })
     * 
     */
    delete<T extends AuditStageDeleteArgs>(args: SelectSubset<T, AuditStageDeleteArgs<ExtArgs>>): Prisma__AuditStageClient<$Result.GetResult<Prisma.$AuditStagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditStage.
     * @param {AuditStageUpdateArgs} args - Arguments to update one AuditStage.
     * @example
     * // Update one AuditStage
     * const auditStage = await prisma.auditStage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditStageUpdateArgs>(args: SelectSubset<T, AuditStageUpdateArgs<ExtArgs>>): Prisma__AuditStageClient<$Result.GetResult<Prisma.$AuditStagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditStages.
     * @param {AuditStageDeleteManyArgs} args - Arguments to filter AuditStages to delete.
     * @example
     * // Delete a few AuditStages
     * const { count } = await prisma.auditStage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditStageDeleteManyArgs>(args?: SelectSubset<T, AuditStageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditStages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditStageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditStages
     * const auditStage = await prisma.auditStage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditStageUpdateManyArgs>(args: SelectSubset<T, AuditStageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditStage.
     * @param {AuditStageUpsertArgs} args - Arguments to update or create a AuditStage.
     * @example
     * // Update or create a AuditStage
     * const auditStage = await prisma.auditStage.upsert({
     *   create: {
     *     // ... data to create a AuditStage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditStage we want to update
     *   }
     * })
     */
    upsert<T extends AuditStageUpsertArgs>(args: SelectSubset<T, AuditStageUpsertArgs<ExtArgs>>): Prisma__AuditStageClient<$Result.GetResult<Prisma.$AuditStagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditStages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditStageCountArgs} args - Arguments to filter AuditStages to count.
     * @example
     * // Count the number of AuditStages
     * const count = await prisma.auditStage.count({
     *   where: {
     *     // ... the filter for the AuditStages we want to count
     *   }
     * })
    **/
    count<T extends AuditStageCountArgs>(
      args?: Subset<T, AuditStageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditStageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditStage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditStageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditStageAggregateArgs>(args: Subset<T, AuditStageAggregateArgs>): Prisma.PrismaPromise<GetAuditStageAggregateType<T>>

    /**
     * Group by AuditStage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditStageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditStageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditStageGroupByArgs['orderBy'] }
        : { orderBy?: AuditStageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditStageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditStageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditStage model
   */
  readonly fields: AuditStageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditStage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditStageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Flow<T extends AuditFlowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuditFlowDefaultArgs<ExtArgs>>): Prisma__AuditFlowClient<$Result.GetResult<Prisma.$AuditFlowPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parent<T extends AuditStage$parentArgs<ExtArgs> = {}>(args?: Subset<T, AuditStage$parentArgs<ExtArgs>>): Prisma__AuditStageClient<$Result.GetResult<Prisma.$AuditStagePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    children<T extends AuditStage$childrenArgs<ExtArgs> = {}>(args?: Subset<T, AuditStage$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditStagePayload<ExtArgs>, T, "findMany"> | Null>
    AuditRecord<T extends AuditStage$AuditRecordArgs<ExtArgs> = {}>(args?: Subset<T, AuditStage$AuditRecordArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditStage model
   */ 
  interface AuditStageFieldRefs {
    readonly id: FieldRef<"AuditStage", 'Int'>
    readonly flowId: FieldRef<"AuditStage", 'Int'>
    readonly name: FieldRef<"AuditStage", 'String'>
    readonly level: FieldRef<"AuditStage", 'Int'>
    readonly pid: FieldRef<"AuditStage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AuditStage findUnique
   */
  export type AuditStageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStage
     */
    select?: AuditStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStageInclude<ExtArgs> | null
    /**
     * Filter, which AuditStage to fetch.
     */
    where: AuditStageWhereUniqueInput
  }

  /**
   * AuditStage findUniqueOrThrow
   */
  export type AuditStageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStage
     */
    select?: AuditStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStageInclude<ExtArgs> | null
    /**
     * Filter, which AuditStage to fetch.
     */
    where: AuditStageWhereUniqueInput
  }

  /**
   * AuditStage findFirst
   */
  export type AuditStageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStage
     */
    select?: AuditStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStageInclude<ExtArgs> | null
    /**
     * Filter, which AuditStage to fetch.
     */
    where?: AuditStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditStages to fetch.
     */
    orderBy?: AuditStageOrderByWithRelationInput | AuditStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditStages.
     */
    cursor?: AuditStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditStages.
     */
    distinct?: AuditStageScalarFieldEnum | AuditStageScalarFieldEnum[]
  }

  /**
   * AuditStage findFirstOrThrow
   */
  export type AuditStageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStage
     */
    select?: AuditStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStageInclude<ExtArgs> | null
    /**
     * Filter, which AuditStage to fetch.
     */
    where?: AuditStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditStages to fetch.
     */
    orderBy?: AuditStageOrderByWithRelationInput | AuditStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditStages.
     */
    cursor?: AuditStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditStages.
     */
    distinct?: AuditStageScalarFieldEnum | AuditStageScalarFieldEnum[]
  }

  /**
   * AuditStage findMany
   */
  export type AuditStageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStage
     */
    select?: AuditStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStageInclude<ExtArgs> | null
    /**
     * Filter, which AuditStages to fetch.
     */
    where?: AuditStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditStages to fetch.
     */
    orderBy?: AuditStageOrderByWithRelationInput | AuditStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditStages.
     */
    cursor?: AuditStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditStages.
     */
    skip?: number
    distinct?: AuditStageScalarFieldEnum | AuditStageScalarFieldEnum[]
  }

  /**
   * AuditStage create
   */
  export type AuditStageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStage
     */
    select?: AuditStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStageInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditStage.
     */
    data: XOR<AuditStageCreateInput, AuditStageUncheckedCreateInput>
  }

  /**
   * AuditStage createMany
   */
  export type AuditStageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditStages.
     */
    data: AuditStageCreateManyInput | AuditStageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditStage createManyAndReturn
   */
  export type AuditStageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStage
     */
    select?: AuditStageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditStages.
     */
    data: AuditStageCreateManyInput | AuditStageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditStage update
   */
  export type AuditStageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStage
     */
    select?: AuditStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStageInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditStage.
     */
    data: XOR<AuditStageUpdateInput, AuditStageUncheckedUpdateInput>
    /**
     * Choose, which AuditStage to update.
     */
    where: AuditStageWhereUniqueInput
  }

  /**
   * AuditStage updateMany
   */
  export type AuditStageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditStages.
     */
    data: XOR<AuditStageUpdateManyMutationInput, AuditStageUncheckedUpdateManyInput>
    /**
     * Filter which AuditStages to update
     */
    where?: AuditStageWhereInput
  }

  /**
   * AuditStage upsert
   */
  export type AuditStageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStage
     */
    select?: AuditStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStageInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditStage to update in case it exists.
     */
    where: AuditStageWhereUniqueInput
    /**
     * In case the AuditStage found by the `where` argument doesn't exist, create a new AuditStage with this data.
     */
    create: XOR<AuditStageCreateInput, AuditStageUncheckedCreateInput>
    /**
     * In case the AuditStage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditStageUpdateInput, AuditStageUncheckedUpdateInput>
  }

  /**
   * AuditStage delete
   */
  export type AuditStageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStage
     */
    select?: AuditStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStageInclude<ExtArgs> | null
    /**
     * Filter which AuditStage to delete.
     */
    where: AuditStageWhereUniqueInput
  }

  /**
   * AuditStage deleteMany
   */
  export type AuditStageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditStages to delete
     */
    where?: AuditStageWhereInput
  }

  /**
   * AuditStage.parent
   */
  export type AuditStage$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStage
     */
    select?: AuditStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStageInclude<ExtArgs> | null
    where?: AuditStageWhereInput
  }

  /**
   * AuditStage.children
   */
  export type AuditStage$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStage
     */
    select?: AuditStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStageInclude<ExtArgs> | null
    where?: AuditStageWhereInput
    orderBy?: AuditStageOrderByWithRelationInput | AuditStageOrderByWithRelationInput[]
    cursor?: AuditStageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditStageScalarFieldEnum | AuditStageScalarFieldEnum[]
  }

  /**
   * AuditStage.AuditRecord
   */
  export type AuditStage$AuditRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    where?: AuditRecordWhereInput
    orderBy?: AuditRecordOrderByWithRelationInput | AuditRecordOrderByWithRelationInput[]
    cursor?: AuditRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditRecordScalarFieldEnum | AuditRecordScalarFieldEnum[]
  }

  /**
   * AuditStage without action
   */
  export type AuditStageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditStage
     */
    select?: AuditStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditStageInclude<ExtArgs> | null
  }


  /**
   * Model AuditRecord
   */

  export type AggregateAuditRecord = {
    _count: AuditRecordCountAggregateOutputType | null
    _avg: AuditRecordAvgAggregateOutputType | null
    _sum: AuditRecordSumAggregateOutputType | null
    _min: AuditRecordMinAggregateOutputType | null
    _max: AuditRecordMaxAggregateOutputType | null
  }

  export type AuditRecordAvgAggregateOutputType = {
    id: number | null
    entityId: number | null
    stageId: number | null
    reviewerId: number | null
  }

  export type AuditRecordSumAggregateOutputType = {
    id: number | null
    entityId: number | null
    stageId: number | null
    reviewerId: number | null
  }

  export type AuditRecordMinAggregateOutputType = {
    id: number | null
    entityId: number | null
    entityType: string | null
    stageId: number | null
    status: string | null
    reviewerId: number | null
    createdAt: Date | null
    notes: string | null
  }

  export type AuditRecordMaxAggregateOutputType = {
    id: number | null
    entityId: number | null
    entityType: string | null
    stageId: number | null
    status: string | null
    reviewerId: number | null
    createdAt: Date | null
    notes: string | null
  }

  export type AuditRecordCountAggregateOutputType = {
    id: number
    entityId: number
    entityType: number
    stageId: number
    status: number
    reviewerId: number
    createdAt: number
    notes: number
    _all: number
  }


  export type AuditRecordAvgAggregateInputType = {
    id?: true
    entityId?: true
    stageId?: true
    reviewerId?: true
  }

  export type AuditRecordSumAggregateInputType = {
    id?: true
    entityId?: true
    stageId?: true
    reviewerId?: true
  }

  export type AuditRecordMinAggregateInputType = {
    id?: true
    entityId?: true
    entityType?: true
    stageId?: true
    status?: true
    reviewerId?: true
    createdAt?: true
    notes?: true
  }

  export type AuditRecordMaxAggregateInputType = {
    id?: true
    entityId?: true
    entityType?: true
    stageId?: true
    status?: true
    reviewerId?: true
    createdAt?: true
    notes?: true
  }

  export type AuditRecordCountAggregateInputType = {
    id?: true
    entityId?: true
    entityType?: true
    stageId?: true
    status?: true
    reviewerId?: true
    createdAt?: true
    notes?: true
    _all?: true
  }

  export type AuditRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditRecord to aggregate.
     */
    where?: AuditRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditRecords to fetch.
     */
    orderBy?: AuditRecordOrderByWithRelationInput | AuditRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditRecords
    **/
    _count?: true | AuditRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditRecordMaxAggregateInputType
  }

  export type GetAuditRecordAggregateType<T extends AuditRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditRecord[P]>
      : GetScalarType<T[P], AggregateAuditRecord[P]>
  }




  export type AuditRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditRecordWhereInput
    orderBy?: AuditRecordOrderByWithAggregationInput | AuditRecordOrderByWithAggregationInput[]
    by: AuditRecordScalarFieldEnum[] | AuditRecordScalarFieldEnum
    having?: AuditRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditRecordCountAggregateInputType | true
    _avg?: AuditRecordAvgAggregateInputType
    _sum?: AuditRecordSumAggregateInputType
    _min?: AuditRecordMinAggregateInputType
    _max?: AuditRecordMaxAggregateInputType
  }

  export type AuditRecordGroupByOutputType = {
    id: number
    entityId: number
    entityType: string
    stageId: number
    status: string | null
    reviewerId: number
    createdAt: Date
    notes: string | null
    _count: AuditRecordCountAggregateOutputType | null
    _avg: AuditRecordAvgAggregateOutputType | null
    _sum: AuditRecordSumAggregateOutputType | null
    _min: AuditRecordMinAggregateOutputType | null
    _max: AuditRecordMaxAggregateOutputType | null
  }

  type GetAuditRecordGroupByPayload<T extends AuditRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditRecordGroupByOutputType[P]>
            : GetScalarType<T[P], AuditRecordGroupByOutputType[P]>
        }
      >
    >


  export type AuditRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityId?: boolean
    entityType?: boolean
    stageId?: boolean
    status?: boolean
    reviewerId?: boolean
    createdAt?: boolean
    notes?: boolean
    Stage?: boolean | AuditStageDefaultArgs<ExtArgs>
    Reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditRecord"]>

  export type AuditRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityId?: boolean
    entityType?: boolean
    stageId?: boolean
    status?: boolean
    reviewerId?: boolean
    createdAt?: boolean
    notes?: boolean
    Stage?: boolean | AuditStageDefaultArgs<ExtArgs>
    Reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditRecord"]>

  export type AuditRecordSelectScalar = {
    id?: boolean
    entityId?: boolean
    entityType?: boolean
    stageId?: boolean
    status?: boolean
    reviewerId?: boolean
    createdAt?: boolean
    notes?: boolean
  }

  export type AuditRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Stage?: boolean | AuditStageDefaultArgs<ExtArgs>
    Reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Stage?: boolean | AuditStageDefaultArgs<ExtArgs>
    Reviewer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditRecord"
    objects: {
      Stage: Prisma.$AuditStagePayload<ExtArgs>
      Reviewer: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      entityId: number
      entityType: string
      stageId: number
      status: string | null
      reviewerId: number
      createdAt: Date
      notes: string | null
    }, ExtArgs["result"]["auditRecord"]>
    composites: {}
  }

  type AuditRecordGetPayload<S extends boolean | null | undefined | AuditRecordDefaultArgs> = $Result.GetResult<Prisma.$AuditRecordPayload, S>

  type AuditRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditRecordCountAggregateInputType | true
    }

  export interface AuditRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditRecord'], meta: { name: 'AuditRecord' } }
    /**
     * Find zero or one AuditRecord that matches the filter.
     * @param {AuditRecordFindUniqueArgs} args - Arguments to find a AuditRecord
     * @example
     * // Get one AuditRecord
     * const auditRecord = await prisma.auditRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditRecordFindUniqueArgs>(args: SelectSubset<T, AuditRecordFindUniqueArgs<ExtArgs>>): Prisma__AuditRecordClient<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditRecordFindUniqueOrThrowArgs} args - Arguments to find a AuditRecord
     * @example
     * // Get one AuditRecord
     * const auditRecord = await prisma.auditRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditRecordClient<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditRecordFindFirstArgs} args - Arguments to find a AuditRecord
     * @example
     * // Get one AuditRecord
     * const auditRecord = await prisma.auditRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditRecordFindFirstArgs>(args?: SelectSubset<T, AuditRecordFindFirstArgs<ExtArgs>>): Prisma__AuditRecordClient<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditRecordFindFirstOrThrowArgs} args - Arguments to find a AuditRecord
     * @example
     * // Get one AuditRecord
     * const auditRecord = await prisma.auditRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditRecordClient<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditRecords
     * const auditRecords = await prisma.auditRecord.findMany()
     * 
     * // Get first 10 AuditRecords
     * const auditRecords = await prisma.auditRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditRecordWithIdOnly = await prisma.auditRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditRecordFindManyArgs>(args?: SelectSubset<T, AuditRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditRecord.
     * @param {AuditRecordCreateArgs} args - Arguments to create a AuditRecord.
     * @example
     * // Create one AuditRecord
     * const AuditRecord = await prisma.auditRecord.create({
     *   data: {
     *     // ... data to create a AuditRecord
     *   }
     * })
     * 
     */
    create<T extends AuditRecordCreateArgs>(args: SelectSubset<T, AuditRecordCreateArgs<ExtArgs>>): Prisma__AuditRecordClient<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditRecords.
     * @param {AuditRecordCreateManyArgs} args - Arguments to create many AuditRecords.
     * @example
     * // Create many AuditRecords
     * const auditRecord = await prisma.auditRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditRecordCreateManyArgs>(args?: SelectSubset<T, AuditRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditRecords and returns the data saved in the database.
     * @param {AuditRecordCreateManyAndReturnArgs} args - Arguments to create many AuditRecords.
     * @example
     * // Create many AuditRecords
     * const auditRecord = await prisma.auditRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditRecords and only return the `id`
     * const auditRecordWithIdOnly = await prisma.auditRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditRecord.
     * @param {AuditRecordDeleteArgs} args - Arguments to delete one AuditRecord.
     * @example
     * // Delete one AuditRecord
     * const AuditRecord = await prisma.auditRecord.delete({
     *   where: {
     *     // ... filter to delete one AuditRecord
     *   }
     * })
     * 
     */
    delete<T extends AuditRecordDeleteArgs>(args: SelectSubset<T, AuditRecordDeleteArgs<ExtArgs>>): Prisma__AuditRecordClient<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditRecord.
     * @param {AuditRecordUpdateArgs} args - Arguments to update one AuditRecord.
     * @example
     * // Update one AuditRecord
     * const auditRecord = await prisma.auditRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditRecordUpdateArgs>(args: SelectSubset<T, AuditRecordUpdateArgs<ExtArgs>>): Prisma__AuditRecordClient<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditRecords.
     * @param {AuditRecordDeleteManyArgs} args - Arguments to filter AuditRecords to delete.
     * @example
     * // Delete a few AuditRecords
     * const { count } = await prisma.auditRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditRecordDeleteManyArgs>(args?: SelectSubset<T, AuditRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditRecords
     * const auditRecord = await prisma.auditRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditRecordUpdateManyArgs>(args: SelectSubset<T, AuditRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditRecord.
     * @param {AuditRecordUpsertArgs} args - Arguments to update or create a AuditRecord.
     * @example
     * // Update or create a AuditRecord
     * const auditRecord = await prisma.auditRecord.upsert({
     *   create: {
     *     // ... data to create a AuditRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditRecord we want to update
     *   }
     * })
     */
    upsert<T extends AuditRecordUpsertArgs>(args: SelectSubset<T, AuditRecordUpsertArgs<ExtArgs>>): Prisma__AuditRecordClient<$Result.GetResult<Prisma.$AuditRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditRecordCountArgs} args - Arguments to filter AuditRecords to count.
     * @example
     * // Count the number of AuditRecords
     * const count = await prisma.auditRecord.count({
     *   where: {
     *     // ... the filter for the AuditRecords we want to count
     *   }
     * })
    **/
    count<T extends AuditRecordCountArgs>(
      args?: Subset<T, AuditRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditRecordAggregateArgs>(args: Subset<T, AuditRecordAggregateArgs>): Prisma.PrismaPromise<GetAuditRecordAggregateType<T>>

    /**
     * Group by AuditRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditRecordGroupByArgs['orderBy'] }
        : { orderBy?: AuditRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditRecord model
   */
  readonly fields: AuditRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Stage<T extends AuditStageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuditStageDefaultArgs<ExtArgs>>): Prisma__AuditStageClient<$Result.GetResult<Prisma.$AuditStagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Reviewer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditRecord model
   */ 
  interface AuditRecordFieldRefs {
    readonly id: FieldRef<"AuditRecord", 'Int'>
    readonly entityId: FieldRef<"AuditRecord", 'Int'>
    readonly entityType: FieldRef<"AuditRecord", 'String'>
    readonly stageId: FieldRef<"AuditRecord", 'Int'>
    readonly status: FieldRef<"AuditRecord", 'String'>
    readonly reviewerId: FieldRef<"AuditRecord", 'Int'>
    readonly createdAt: FieldRef<"AuditRecord", 'DateTime'>
    readonly notes: FieldRef<"AuditRecord", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AuditRecord findUnique
   */
  export type AuditRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * Filter, which AuditRecord to fetch.
     */
    where: AuditRecordWhereUniqueInput
  }

  /**
   * AuditRecord findUniqueOrThrow
   */
  export type AuditRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * Filter, which AuditRecord to fetch.
     */
    where: AuditRecordWhereUniqueInput
  }

  /**
   * AuditRecord findFirst
   */
  export type AuditRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * Filter, which AuditRecord to fetch.
     */
    where?: AuditRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditRecords to fetch.
     */
    orderBy?: AuditRecordOrderByWithRelationInput | AuditRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditRecords.
     */
    cursor?: AuditRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditRecords.
     */
    distinct?: AuditRecordScalarFieldEnum | AuditRecordScalarFieldEnum[]
  }

  /**
   * AuditRecord findFirstOrThrow
   */
  export type AuditRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * Filter, which AuditRecord to fetch.
     */
    where?: AuditRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditRecords to fetch.
     */
    orderBy?: AuditRecordOrderByWithRelationInput | AuditRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditRecords.
     */
    cursor?: AuditRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditRecords.
     */
    distinct?: AuditRecordScalarFieldEnum | AuditRecordScalarFieldEnum[]
  }

  /**
   * AuditRecord findMany
   */
  export type AuditRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * Filter, which AuditRecords to fetch.
     */
    where?: AuditRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditRecords to fetch.
     */
    orderBy?: AuditRecordOrderByWithRelationInput | AuditRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditRecords.
     */
    cursor?: AuditRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditRecords.
     */
    skip?: number
    distinct?: AuditRecordScalarFieldEnum | AuditRecordScalarFieldEnum[]
  }

  /**
   * AuditRecord create
   */
  export type AuditRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditRecord.
     */
    data: XOR<AuditRecordCreateInput, AuditRecordUncheckedCreateInput>
  }

  /**
   * AuditRecord createMany
   */
  export type AuditRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditRecords.
     */
    data: AuditRecordCreateManyInput | AuditRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditRecord createManyAndReturn
   */
  export type AuditRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditRecords.
     */
    data: AuditRecordCreateManyInput | AuditRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditRecord update
   */
  export type AuditRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditRecord.
     */
    data: XOR<AuditRecordUpdateInput, AuditRecordUncheckedUpdateInput>
    /**
     * Choose, which AuditRecord to update.
     */
    where: AuditRecordWhereUniqueInput
  }

  /**
   * AuditRecord updateMany
   */
  export type AuditRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditRecords.
     */
    data: XOR<AuditRecordUpdateManyMutationInput, AuditRecordUncheckedUpdateManyInput>
    /**
     * Filter which AuditRecords to update
     */
    where?: AuditRecordWhereInput
  }

  /**
   * AuditRecord upsert
   */
  export type AuditRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditRecord to update in case it exists.
     */
    where: AuditRecordWhereUniqueInput
    /**
     * In case the AuditRecord found by the `where` argument doesn't exist, create a new AuditRecord with this data.
     */
    create: XOR<AuditRecordCreateInput, AuditRecordUncheckedCreateInput>
    /**
     * In case the AuditRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditRecordUpdateInput, AuditRecordUncheckedUpdateInput>
  }

  /**
   * AuditRecord delete
   */
  export type AuditRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
    /**
     * Filter which AuditRecord to delete.
     */
    where: AuditRecordWhereUniqueInput
  }

  /**
   * AuditRecord deleteMany
   */
  export type AuditRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditRecords to delete
     */
    where?: AuditRecordWhereInput
  }

  /**
   * AuditRecord without action
   */
  export type AuditRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditRecord
     */
    select?: AuditRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditRecordInclude<ExtArgs> | null
  }


  /**
   * Model DictCouponType
   */

  export type AggregateDictCouponType = {
    _count: DictCouponTypeCountAggregateOutputType | null
    _avg: DictCouponTypeAvgAggregateOutputType | null
    _sum: DictCouponTypeSumAggregateOutputType | null
    _min: DictCouponTypeMinAggregateOutputType | null
    _max: DictCouponTypeMaxAggregateOutputType | null
  }

  export type DictCouponTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type DictCouponTypeSumAggregateOutputType = {
    id: number | null
  }

  export type DictCouponTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    desc: string | null
  }

  export type DictCouponTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    desc: string | null
  }

  export type DictCouponTypeCountAggregateOutputType = {
    id: number
    name: number
    desc: number
    _all: number
  }


  export type DictCouponTypeAvgAggregateInputType = {
    id?: true
  }

  export type DictCouponTypeSumAggregateInputType = {
    id?: true
  }

  export type DictCouponTypeMinAggregateInputType = {
    id?: true
    name?: true
    desc?: true
  }

  export type DictCouponTypeMaxAggregateInputType = {
    id?: true
    name?: true
    desc?: true
  }

  export type DictCouponTypeCountAggregateInputType = {
    id?: true
    name?: true
    desc?: true
    _all?: true
  }

  export type DictCouponTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DictCouponType to aggregate.
     */
    where?: DictCouponTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DictCouponTypes to fetch.
     */
    orderBy?: DictCouponTypeOrderByWithRelationInput | DictCouponTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DictCouponTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DictCouponTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DictCouponTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DictCouponTypes
    **/
    _count?: true | DictCouponTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DictCouponTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DictCouponTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DictCouponTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DictCouponTypeMaxAggregateInputType
  }

  export type GetDictCouponTypeAggregateType<T extends DictCouponTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateDictCouponType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDictCouponType[P]>
      : GetScalarType<T[P], AggregateDictCouponType[P]>
  }




  export type DictCouponTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DictCouponTypeWhereInput
    orderBy?: DictCouponTypeOrderByWithAggregationInput | DictCouponTypeOrderByWithAggregationInput[]
    by: DictCouponTypeScalarFieldEnum[] | DictCouponTypeScalarFieldEnum
    having?: DictCouponTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DictCouponTypeCountAggregateInputType | true
    _avg?: DictCouponTypeAvgAggregateInputType
    _sum?: DictCouponTypeSumAggregateInputType
    _min?: DictCouponTypeMinAggregateInputType
    _max?: DictCouponTypeMaxAggregateInputType
  }

  export type DictCouponTypeGroupByOutputType = {
    id: number
    name: string
    desc: string | null
    _count: DictCouponTypeCountAggregateOutputType | null
    _avg: DictCouponTypeAvgAggregateOutputType | null
    _sum: DictCouponTypeSumAggregateOutputType | null
    _min: DictCouponTypeMinAggregateOutputType | null
    _max: DictCouponTypeMaxAggregateOutputType | null
  }

  type GetDictCouponTypeGroupByPayload<T extends DictCouponTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DictCouponTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DictCouponTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DictCouponTypeGroupByOutputType[P]>
            : GetScalarType<T[P], DictCouponTypeGroupByOutputType[P]>
        }
      >
    >


  export type DictCouponTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    desc?: boolean
    Coupon?: boolean | DictCouponType$CouponArgs<ExtArgs>
    _count?: boolean | DictCouponTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dictCouponType"]>

  export type DictCouponTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    desc?: boolean
  }, ExtArgs["result"]["dictCouponType"]>

  export type DictCouponTypeSelectScalar = {
    id?: boolean
    name?: boolean
    desc?: boolean
  }

  export type DictCouponTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Coupon?: boolean | DictCouponType$CouponArgs<ExtArgs>
    _count?: boolean | DictCouponTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DictCouponTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DictCouponTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DictCouponType"
    objects: {
      Coupon: Prisma.$CouponPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      desc: string | null
    }, ExtArgs["result"]["dictCouponType"]>
    composites: {}
  }

  type DictCouponTypeGetPayload<S extends boolean | null | undefined | DictCouponTypeDefaultArgs> = $Result.GetResult<Prisma.$DictCouponTypePayload, S>

  type DictCouponTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DictCouponTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DictCouponTypeCountAggregateInputType | true
    }

  export interface DictCouponTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DictCouponType'], meta: { name: 'DictCouponType' } }
    /**
     * Find zero or one DictCouponType that matches the filter.
     * @param {DictCouponTypeFindUniqueArgs} args - Arguments to find a DictCouponType
     * @example
     * // Get one DictCouponType
     * const dictCouponType = await prisma.dictCouponType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DictCouponTypeFindUniqueArgs>(args: SelectSubset<T, DictCouponTypeFindUniqueArgs<ExtArgs>>): Prisma__DictCouponTypeClient<$Result.GetResult<Prisma.$DictCouponTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DictCouponType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DictCouponTypeFindUniqueOrThrowArgs} args - Arguments to find a DictCouponType
     * @example
     * // Get one DictCouponType
     * const dictCouponType = await prisma.dictCouponType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DictCouponTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, DictCouponTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DictCouponTypeClient<$Result.GetResult<Prisma.$DictCouponTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DictCouponType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictCouponTypeFindFirstArgs} args - Arguments to find a DictCouponType
     * @example
     * // Get one DictCouponType
     * const dictCouponType = await prisma.dictCouponType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DictCouponTypeFindFirstArgs>(args?: SelectSubset<T, DictCouponTypeFindFirstArgs<ExtArgs>>): Prisma__DictCouponTypeClient<$Result.GetResult<Prisma.$DictCouponTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DictCouponType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictCouponTypeFindFirstOrThrowArgs} args - Arguments to find a DictCouponType
     * @example
     * // Get one DictCouponType
     * const dictCouponType = await prisma.dictCouponType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DictCouponTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, DictCouponTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DictCouponTypeClient<$Result.GetResult<Prisma.$DictCouponTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DictCouponTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictCouponTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DictCouponTypes
     * const dictCouponTypes = await prisma.dictCouponType.findMany()
     * 
     * // Get first 10 DictCouponTypes
     * const dictCouponTypes = await prisma.dictCouponType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dictCouponTypeWithIdOnly = await prisma.dictCouponType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DictCouponTypeFindManyArgs>(args?: SelectSubset<T, DictCouponTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DictCouponTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DictCouponType.
     * @param {DictCouponTypeCreateArgs} args - Arguments to create a DictCouponType.
     * @example
     * // Create one DictCouponType
     * const DictCouponType = await prisma.dictCouponType.create({
     *   data: {
     *     // ... data to create a DictCouponType
     *   }
     * })
     * 
     */
    create<T extends DictCouponTypeCreateArgs>(args: SelectSubset<T, DictCouponTypeCreateArgs<ExtArgs>>): Prisma__DictCouponTypeClient<$Result.GetResult<Prisma.$DictCouponTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DictCouponTypes.
     * @param {DictCouponTypeCreateManyArgs} args - Arguments to create many DictCouponTypes.
     * @example
     * // Create many DictCouponTypes
     * const dictCouponType = await prisma.dictCouponType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DictCouponTypeCreateManyArgs>(args?: SelectSubset<T, DictCouponTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DictCouponTypes and returns the data saved in the database.
     * @param {DictCouponTypeCreateManyAndReturnArgs} args - Arguments to create many DictCouponTypes.
     * @example
     * // Create many DictCouponTypes
     * const dictCouponType = await prisma.dictCouponType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DictCouponTypes and only return the `id`
     * const dictCouponTypeWithIdOnly = await prisma.dictCouponType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DictCouponTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, DictCouponTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DictCouponTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DictCouponType.
     * @param {DictCouponTypeDeleteArgs} args - Arguments to delete one DictCouponType.
     * @example
     * // Delete one DictCouponType
     * const DictCouponType = await prisma.dictCouponType.delete({
     *   where: {
     *     // ... filter to delete one DictCouponType
     *   }
     * })
     * 
     */
    delete<T extends DictCouponTypeDeleteArgs>(args: SelectSubset<T, DictCouponTypeDeleteArgs<ExtArgs>>): Prisma__DictCouponTypeClient<$Result.GetResult<Prisma.$DictCouponTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DictCouponType.
     * @param {DictCouponTypeUpdateArgs} args - Arguments to update one DictCouponType.
     * @example
     * // Update one DictCouponType
     * const dictCouponType = await prisma.dictCouponType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DictCouponTypeUpdateArgs>(args: SelectSubset<T, DictCouponTypeUpdateArgs<ExtArgs>>): Prisma__DictCouponTypeClient<$Result.GetResult<Prisma.$DictCouponTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DictCouponTypes.
     * @param {DictCouponTypeDeleteManyArgs} args - Arguments to filter DictCouponTypes to delete.
     * @example
     * // Delete a few DictCouponTypes
     * const { count } = await prisma.dictCouponType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DictCouponTypeDeleteManyArgs>(args?: SelectSubset<T, DictCouponTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DictCouponTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictCouponTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DictCouponTypes
     * const dictCouponType = await prisma.dictCouponType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DictCouponTypeUpdateManyArgs>(args: SelectSubset<T, DictCouponTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DictCouponType.
     * @param {DictCouponTypeUpsertArgs} args - Arguments to update or create a DictCouponType.
     * @example
     * // Update or create a DictCouponType
     * const dictCouponType = await prisma.dictCouponType.upsert({
     *   create: {
     *     // ... data to create a DictCouponType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DictCouponType we want to update
     *   }
     * })
     */
    upsert<T extends DictCouponTypeUpsertArgs>(args: SelectSubset<T, DictCouponTypeUpsertArgs<ExtArgs>>): Prisma__DictCouponTypeClient<$Result.GetResult<Prisma.$DictCouponTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DictCouponTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictCouponTypeCountArgs} args - Arguments to filter DictCouponTypes to count.
     * @example
     * // Count the number of DictCouponTypes
     * const count = await prisma.dictCouponType.count({
     *   where: {
     *     // ... the filter for the DictCouponTypes we want to count
     *   }
     * })
    **/
    count<T extends DictCouponTypeCountArgs>(
      args?: Subset<T, DictCouponTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DictCouponTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DictCouponType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictCouponTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DictCouponTypeAggregateArgs>(args: Subset<T, DictCouponTypeAggregateArgs>): Prisma.PrismaPromise<GetDictCouponTypeAggregateType<T>>

    /**
     * Group by DictCouponType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DictCouponTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DictCouponTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DictCouponTypeGroupByArgs['orderBy'] }
        : { orderBy?: DictCouponTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DictCouponTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDictCouponTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DictCouponType model
   */
  readonly fields: DictCouponTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DictCouponType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DictCouponTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Coupon<T extends DictCouponType$CouponArgs<ExtArgs> = {}>(args?: Subset<T, DictCouponType$CouponArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DictCouponType model
   */ 
  interface DictCouponTypeFieldRefs {
    readonly id: FieldRef<"DictCouponType", 'Int'>
    readonly name: FieldRef<"DictCouponType", 'String'>
    readonly desc: FieldRef<"DictCouponType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DictCouponType findUnique
   */
  export type DictCouponTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCouponType
     */
    select?: DictCouponTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCouponTypeInclude<ExtArgs> | null
    /**
     * Filter, which DictCouponType to fetch.
     */
    where: DictCouponTypeWhereUniqueInput
  }

  /**
   * DictCouponType findUniqueOrThrow
   */
  export type DictCouponTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCouponType
     */
    select?: DictCouponTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCouponTypeInclude<ExtArgs> | null
    /**
     * Filter, which DictCouponType to fetch.
     */
    where: DictCouponTypeWhereUniqueInput
  }

  /**
   * DictCouponType findFirst
   */
  export type DictCouponTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCouponType
     */
    select?: DictCouponTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCouponTypeInclude<ExtArgs> | null
    /**
     * Filter, which DictCouponType to fetch.
     */
    where?: DictCouponTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DictCouponTypes to fetch.
     */
    orderBy?: DictCouponTypeOrderByWithRelationInput | DictCouponTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DictCouponTypes.
     */
    cursor?: DictCouponTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DictCouponTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DictCouponTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DictCouponTypes.
     */
    distinct?: DictCouponTypeScalarFieldEnum | DictCouponTypeScalarFieldEnum[]
  }

  /**
   * DictCouponType findFirstOrThrow
   */
  export type DictCouponTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCouponType
     */
    select?: DictCouponTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCouponTypeInclude<ExtArgs> | null
    /**
     * Filter, which DictCouponType to fetch.
     */
    where?: DictCouponTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DictCouponTypes to fetch.
     */
    orderBy?: DictCouponTypeOrderByWithRelationInput | DictCouponTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DictCouponTypes.
     */
    cursor?: DictCouponTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DictCouponTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DictCouponTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DictCouponTypes.
     */
    distinct?: DictCouponTypeScalarFieldEnum | DictCouponTypeScalarFieldEnum[]
  }

  /**
   * DictCouponType findMany
   */
  export type DictCouponTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCouponType
     */
    select?: DictCouponTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCouponTypeInclude<ExtArgs> | null
    /**
     * Filter, which DictCouponTypes to fetch.
     */
    where?: DictCouponTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DictCouponTypes to fetch.
     */
    orderBy?: DictCouponTypeOrderByWithRelationInput | DictCouponTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DictCouponTypes.
     */
    cursor?: DictCouponTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DictCouponTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DictCouponTypes.
     */
    skip?: number
    distinct?: DictCouponTypeScalarFieldEnum | DictCouponTypeScalarFieldEnum[]
  }

  /**
   * DictCouponType create
   */
  export type DictCouponTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCouponType
     */
    select?: DictCouponTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCouponTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a DictCouponType.
     */
    data: XOR<DictCouponTypeCreateInput, DictCouponTypeUncheckedCreateInput>
  }

  /**
   * DictCouponType createMany
   */
  export type DictCouponTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DictCouponTypes.
     */
    data: DictCouponTypeCreateManyInput | DictCouponTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DictCouponType createManyAndReturn
   */
  export type DictCouponTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCouponType
     */
    select?: DictCouponTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DictCouponTypes.
     */
    data: DictCouponTypeCreateManyInput | DictCouponTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DictCouponType update
   */
  export type DictCouponTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCouponType
     */
    select?: DictCouponTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCouponTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a DictCouponType.
     */
    data: XOR<DictCouponTypeUpdateInput, DictCouponTypeUncheckedUpdateInput>
    /**
     * Choose, which DictCouponType to update.
     */
    where: DictCouponTypeWhereUniqueInput
  }

  /**
   * DictCouponType updateMany
   */
  export type DictCouponTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DictCouponTypes.
     */
    data: XOR<DictCouponTypeUpdateManyMutationInput, DictCouponTypeUncheckedUpdateManyInput>
    /**
     * Filter which DictCouponTypes to update
     */
    where?: DictCouponTypeWhereInput
  }

  /**
   * DictCouponType upsert
   */
  export type DictCouponTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCouponType
     */
    select?: DictCouponTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCouponTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the DictCouponType to update in case it exists.
     */
    where: DictCouponTypeWhereUniqueInput
    /**
     * In case the DictCouponType found by the `where` argument doesn't exist, create a new DictCouponType with this data.
     */
    create: XOR<DictCouponTypeCreateInput, DictCouponTypeUncheckedCreateInput>
    /**
     * In case the DictCouponType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DictCouponTypeUpdateInput, DictCouponTypeUncheckedUpdateInput>
  }

  /**
   * DictCouponType delete
   */
  export type DictCouponTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCouponType
     */
    select?: DictCouponTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCouponTypeInclude<ExtArgs> | null
    /**
     * Filter which DictCouponType to delete.
     */
    where: DictCouponTypeWhereUniqueInput
  }

  /**
   * DictCouponType deleteMany
   */
  export type DictCouponTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DictCouponTypes to delete
     */
    where?: DictCouponTypeWhereInput
  }

  /**
   * DictCouponType.Coupon
   */
  export type DictCouponType$CouponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    where?: CouponWhereInput
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    cursor?: CouponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * DictCouponType without action
   */
  export type DictCouponTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DictCouponType
     */
    select?: DictCouponTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DictCouponTypeInclude<ExtArgs> | null
  }


  /**
   * Model Coupon
   */

  export type AggregateCoupon = {
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  export type CouponAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    typeId: number | null
    threshold: number | null
    discount: number | null
  }

  export type CouponSumAggregateOutputType = {
    id: number | null
    productId: number | null
    typeId: number | null
    threshold: number | null
    discount: number | null
  }

  export type CouponMinAggregateOutputType = {
    id: number | null
    productId: number | null
    typeId: number | null
    threshold: number | null
    discount: number | null
    validUntil: Date | null
    universal: boolean | null
  }

  export type CouponMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    typeId: number | null
    threshold: number | null
    discount: number | null
    validUntil: Date | null
    universal: boolean | null
  }

  export type CouponCountAggregateOutputType = {
    id: number
    productId: number
    typeId: number
    threshold: number
    discount: number
    validUntil: number
    universal: number
    _all: number
  }


  export type CouponAvgAggregateInputType = {
    id?: true
    productId?: true
    typeId?: true
    threshold?: true
    discount?: true
  }

  export type CouponSumAggregateInputType = {
    id?: true
    productId?: true
    typeId?: true
    threshold?: true
    discount?: true
  }

  export type CouponMinAggregateInputType = {
    id?: true
    productId?: true
    typeId?: true
    threshold?: true
    discount?: true
    validUntil?: true
    universal?: true
  }

  export type CouponMaxAggregateInputType = {
    id?: true
    productId?: true
    typeId?: true
    threshold?: true
    discount?: true
    validUntil?: true
    universal?: true
  }

  export type CouponCountAggregateInputType = {
    id?: true
    productId?: true
    typeId?: true
    threshold?: true
    discount?: true
    validUntil?: true
    universal?: true
    _all?: true
  }

  export type CouponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupon to aggregate.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Coupons
    **/
    _count?: true | CouponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CouponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CouponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponMaxAggregateInputType
  }

  export type GetCouponAggregateType<T extends CouponAggregateArgs> = {
        [P in keyof T & keyof AggregateCoupon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoupon[P]>
      : GetScalarType<T[P], AggregateCoupon[P]>
  }




  export type CouponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponWhereInput
    orderBy?: CouponOrderByWithAggregationInput | CouponOrderByWithAggregationInput[]
    by: CouponScalarFieldEnum[] | CouponScalarFieldEnum
    having?: CouponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponCountAggregateInputType | true
    _avg?: CouponAvgAggregateInputType
    _sum?: CouponSumAggregateInputType
    _min?: CouponMinAggregateInputType
    _max?: CouponMaxAggregateInputType
  }

  export type CouponGroupByOutputType = {
    id: number
    productId: number | null
    typeId: number
    threshold: number | null
    discount: number
    validUntil: Date
    universal: boolean
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  type GetCouponGroupByPayload<T extends CouponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CouponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponGroupByOutputType[P]>
            : GetScalarType<T[P], CouponGroupByOutputType[P]>
        }
      >
    >


  export type CouponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    typeId?: boolean
    threshold?: boolean
    discount?: boolean
    validUntil?: boolean
    universal?: boolean
    CouponType?: boolean | DictCouponTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    typeId?: boolean
    threshold?: boolean
    discount?: boolean
    validUntil?: boolean
    universal?: boolean
    CouponType?: boolean | DictCouponTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectScalar = {
    id?: boolean
    productId?: boolean
    typeId?: boolean
    threshold?: boolean
    discount?: boolean
    validUntil?: boolean
    universal?: boolean
  }

  export type CouponInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CouponType?: boolean | DictCouponTypeDefaultArgs<ExtArgs>
  }
  export type CouponIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CouponType?: boolean | DictCouponTypeDefaultArgs<ExtArgs>
  }

  export type $CouponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Coupon"
    objects: {
      CouponType: Prisma.$DictCouponTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number | null
      typeId: number
      threshold: number | null
      discount: number
      validUntil: Date
      universal: boolean
    }, ExtArgs["result"]["coupon"]>
    composites: {}
  }

  type CouponGetPayload<S extends boolean | null | undefined | CouponDefaultArgs> = $Result.GetResult<Prisma.$CouponPayload, S>

  type CouponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CouponFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CouponCountAggregateInputType | true
    }

  export interface CouponDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Coupon'], meta: { name: 'Coupon' } }
    /**
     * Find zero or one Coupon that matches the filter.
     * @param {CouponFindUniqueArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CouponFindUniqueArgs>(args: SelectSubset<T, CouponFindUniqueArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Coupon that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CouponFindUniqueOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CouponFindUniqueOrThrowArgs>(args: SelectSubset<T, CouponFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Coupon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CouponFindFirstArgs>(args?: SelectSubset<T, CouponFindFirstArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Coupon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CouponFindFirstOrThrowArgs>(args?: SelectSubset<T, CouponFindFirstOrThrowArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coupons
     * const coupons = await prisma.coupon.findMany()
     * 
     * // Get first 10 Coupons
     * const coupons = await prisma.coupon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponWithIdOnly = await prisma.coupon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CouponFindManyArgs>(args?: SelectSubset<T, CouponFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Coupon.
     * @param {CouponCreateArgs} args - Arguments to create a Coupon.
     * @example
     * // Create one Coupon
     * const Coupon = await prisma.coupon.create({
     *   data: {
     *     // ... data to create a Coupon
     *   }
     * })
     * 
     */
    create<T extends CouponCreateArgs>(args: SelectSubset<T, CouponCreateArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Coupons.
     * @param {CouponCreateManyArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CouponCreateManyArgs>(args?: SelectSubset<T, CouponCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Coupons and returns the data saved in the database.
     * @param {CouponCreateManyAndReturnArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Coupons and only return the `id`
     * const couponWithIdOnly = await prisma.coupon.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CouponCreateManyAndReturnArgs>(args?: SelectSubset<T, CouponCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Coupon.
     * @param {CouponDeleteArgs} args - Arguments to delete one Coupon.
     * @example
     * // Delete one Coupon
     * const Coupon = await prisma.coupon.delete({
     *   where: {
     *     // ... filter to delete one Coupon
     *   }
     * })
     * 
     */
    delete<T extends CouponDeleteArgs>(args: SelectSubset<T, CouponDeleteArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Coupon.
     * @param {CouponUpdateArgs} args - Arguments to update one Coupon.
     * @example
     * // Update one Coupon
     * const coupon = await prisma.coupon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CouponUpdateArgs>(args: SelectSubset<T, CouponUpdateArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Coupons.
     * @param {CouponDeleteManyArgs} args - Arguments to filter Coupons to delete.
     * @example
     * // Delete a few Coupons
     * const { count } = await prisma.coupon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CouponDeleteManyArgs>(args?: SelectSubset<T, CouponDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CouponUpdateManyArgs>(args: SelectSubset<T, CouponUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Coupon.
     * @param {CouponUpsertArgs} args - Arguments to update or create a Coupon.
     * @example
     * // Update or create a Coupon
     * const coupon = await prisma.coupon.upsert({
     *   create: {
     *     // ... data to create a Coupon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coupon we want to update
     *   }
     * })
     */
    upsert<T extends CouponUpsertArgs>(args: SelectSubset<T, CouponUpsertArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponCountArgs} args - Arguments to filter Coupons to count.
     * @example
     * // Count the number of Coupons
     * const count = await prisma.coupon.count({
     *   where: {
     *     // ... the filter for the Coupons we want to count
     *   }
     * })
    **/
    count<T extends CouponCountArgs>(
      args?: Subset<T, CouponCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponAggregateArgs>(args: Subset<T, CouponAggregateArgs>): Prisma.PrismaPromise<GetCouponAggregateType<T>>

    /**
     * Group by Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CouponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouponGroupByArgs['orderBy'] }
        : { orderBy?: CouponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CouponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Coupon model
   */
  readonly fields: CouponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Coupon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CouponClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CouponType<T extends DictCouponTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DictCouponTypeDefaultArgs<ExtArgs>>): Prisma__DictCouponTypeClient<$Result.GetResult<Prisma.$DictCouponTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Coupon model
   */ 
  interface CouponFieldRefs {
    readonly id: FieldRef<"Coupon", 'Int'>
    readonly productId: FieldRef<"Coupon", 'Int'>
    readonly typeId: FieldRef<"Coupon", 'Int'>
    readonly threshold: FieldRef<"Coupon", 'Float'>
    readonly discount: FieldRef<"Coupon", 'Float'>
    readonly validUntil: FieldRef<"Coupon", 'DateTime'>
    readonly universal: FieldRef<"Coupon", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Coupon findUnique
   */
  export type CouponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon findUniqueOrThrow
   */
  export type CouponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon findFirst
   */
  export type CouponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon findFirstOrThrow
   */
  export type CouponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon findMany
   */
  export type CouponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupons to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon create
   */
  export type CouponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The data needed to create a Coupon.
     */
    data: XOR<CouponCreateInput, CouponUncheckedCreateInput>
  }

  /**
   * Coupon createMany
   */
  export type CouponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Coupon createManyAndReturn
   */
  export type CouponCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Coupon update
   */
  export type CouponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The data needed to update a Coupon.
     */
    data: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
    /**
     * Choose, which Coupon to update.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon updateMany
   */
  export type CouponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Coupons.
     */
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyInput>
    /**
     * Filter which Coupons to update
     */
    where?: CouponWhereInput
  }

  /**
   * Coupon upsert
   */
  export type CouponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The filter to search for the Coupon to update in case it exists.
     */
    where: CouponWhereUniqueInput
    /**
     * In case the Coupon found by the `where` argument doesn't exist, create a new Coupon with this data.
     */
    create: XOR<CouponCreateInput, CouponUncheckedCreateInput>
    /**
     * In case the Coupon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
  }

  /**
   * Coupon delete
   */
  export type CouponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter which Coupon to delete.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon deleteMany
   */
  export type CouponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupons to delete
     */
    where?: CouponWhereInput
  }

  /**
   * Coupon without action
   */
  export type CouponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
  }


  /**
   * Model BalanceRecord
   */

  export type AggregateBalanceRecord = {
    _count: BalanceRecordCountAggregateOutputType | null
    _avg: BalanceRecordAvgAggregateOutputType | null
    _sum: BalanceRecordSumAggregateOutputType | null
    _min: BalanceRecordMinAggregateOutputType | null
    _max: BalanceRecordMaxAggregateOutputType | null
  }

  export type BalanceRecordAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    transactionId: number | null
    amount: number | null
    type: number | null
  }

  export type BalanceRecordSumAggregateOutputType = {
    id: number | null
    userId: number | null
    transactionId: number | null
    amount: number | null
    type: number | null
  }

  export type BalanceRecordMinAggregateOutputType = {
    id: number | null
    userId: number | null
    transactionId: number | null
    amount: number | null
    type: number | null
    createdAt: Date | null
  }

  export type BalanceRecordMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    transactionId: number | null
    amount: number | null
    type: number | null
    createdAt: Date | null
  }

  export type BalanceRecordCountAggregateOutputType = {
    id: number
    userId: number
    transactionId: number
    amount: number
    type: number
    createdAt: number
    _all: number
  }


  export type BalanceRecordAvgAggregateInputType = {
    id?: true
    userId?: true
    transactionId?: true
    amount?: true
    type?: true
  }

  export type BalanceRecordSumAggregateInputType = {
    id?: true
    userId?: true
    transactionId?: true
    amount?: true
    type?: true
  }

  export type BalanceRecordMinAggregateInputType = {
    id?: true
    userId?: true
    transactionId?: true
    amount?: true
    type?: true
    createdAt?: true
  }

  export type BalanceRecordMaxAggregateInputType = {
    id?: true
    userId?: true
    transactionId?: true
    amount?: true
    type?: true
    createdAt?: true
  }

  export type BalanceRecordCountAggregateInputType = {
    id?: true
    userId?: true
    transactionId?: true
    amount?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type BalanceRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BalanceRecord to aggregate.
     */
    where?: BalanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BalanceRecords to fetch.
     */
    orderBy?: BalanceRecordOrderByWithRelationInput | BalanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BalanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BalanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BalanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BalanceRecords
    **/
    _count?: true | BalanceRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BalanceRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BalanceRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BalanceRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BalanceRecordMaxAggregateInputType
  }

  export type GetBalanceRecordAggregateType<T extends BalanceRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateBalanceRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBalanceRecord[P]>
      : GetScalarType<T[P], AggregateBalanceRecord[P]>
  }




  export type BalanceRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalanceRecordWhereInput
    orderBy?: BalanceRecordOrderByWithAggregationInput | BalanceRecordOrderByWithAggregationInput[]
    by: BalanceRecordScalarFieldEnum[] | BalanceRecordScalarFieldEnum
    having?: BalanceRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BalanceRecordCountAggregateInputType | true
    _avg?: BalanceRecordAvgAggregateInputType
    _sum?: BalanceRecordSumAggregateInputType
    _min?: BalanceRecordMinAggregateInputType
    _max?: BalanceRecordMaxAggregateInputType
  }

  export type BalanceRecordGroupByOutputType = {
    id: number
    userId: number
    transactionId: number | null
    amount: number
    type: number
    createdAt: Date
    _count: BalanceRecordCountAggregateOutputType | null
    _avg: BalanceRecordAvgAggregateOutputType | null
    _sum: BalanceRecordSumAggregateOutputType | null
    _min: BalanceRecordMinAggregateOutputType | null
    _max: BalanceRecordMaxAggregateOutputType | null
  }

  type GetBalanceRecordGroupByPayload<T extends BalanceRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BalanceRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BalanceRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BalanceRecordGroupByOutputType[P]>
            : GetScalarType<T[P], BalanceRecordGroupByOutputType[P]>
        }
      >
    >


  export type BalanceRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    transactionId?: boolean
    amount?: boolean
    type?: boolean
    createdAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Transaction?: boolean | BalanceRecord$TransactionArgs<ExtArgs>
  }, ExtArgs["result"]["balanceRecord"]>

  export type BalanceRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    transactionId?: boolean
    amount?: boolean
    type?: boolean
    createdAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Transaction?: boolean | BalanceRecord$TransactionArgs<ExtArgs>
  }, ExtArgs["result"]["balanceRecord"]>

  export type BalanceRecordSelectScalar = {
    id?: boolean
    userId?: boolean
    transactionId?: boolean
    amount?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type BalanceRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Transaction?: boolean | BalanceRecord$TransactionArgs<ExtArgs>
  }
  export type BalanceRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Transaction?: boolean | BalanceRecord$TransactionArgs<ExtArgs>
  }

  export type $BalanceRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BalanceRecord"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      Transaction: Prisma.$TransactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      transactionId: number | null
      amount: number
      type: number
      createdAt: Date
    }, ExtArgs["result"]["balanceRecord"]>
    composites: {}
  }

  type BalanceRecordGetPayload<S extends boolean | null | undefined | BalanceRecordDefaultArgs> = $Result.GetResult<Prisma.$BalanceRecordPayload, S>

  type BalanceRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BalanceRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BalanceRecordCountAggregateInputType | true
    }

  export interface BalanceRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BalanceRecord'], meta: { name: 'BalanceRecord' } }
    /**
     * Find zero or one BalanceRecord that matches the filter.
     * @param {BalanceRecordFindUniqueArgs} args - Arguments to find a BalanceRecord
     * @example
     * // Get one BalanceRecord
     * const balanceRecord = await prisma.balanceRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BalanceRecordFindUniqueArgs>(args: SelectSubset<T, BalanceRecordFindUniqueArgs<ExtArgs>>): Prisma__BalanceRecordClient<$Result.GetResult<Prisma.$BalanceRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BalanceRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BalanceRecordFindUniqueOrThrowArgs} args - Arguments to find a BalanceRecord
     * @example
     * // Get one BalanceRecord
     * const balanceRecord = await prisma.balanceRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BalanceRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, BalanceRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BalanceRecordClient<$Result.GetResult<Prisma.$BalanceRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BalanceRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceRecordFindFirstArgs} args - Arguments to find a BalanceRecord
     * @example
     * // Get one BalanceRecord
     * const balanceRecord = await prisma.balanceRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BalanceRecordFindFirstArgs>(args?: SelectSubset<T, BalanceRecordFindFirstArgs<ExtArgs>>): Prisma__BalanceRecordClient<$Result.GetResult<Prisma.$BalanceRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BalanceRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceRecordFindFirstOrThrowArgs} args - Arguments to find a BalanceRecord
     * @example
     * // Get one BalanceRecord
     * const balanceRecord = await prisma.balanceRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BalanceRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, BalanceRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__BalanceRecordClient<$Result.GetResult<Prisma.$BalanceRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BalanceRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BalanceRecords
     * const balanceRecords = await prisma.balanceRecord.findMany()
     * 
     * // Get first 10 BalanceRecords
     * const balanceRecords = await prisma.balanceRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const balanceRecordWithIdOnly = await prisma.balanceRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BalanceRecordFindManyArgs>(args?: SelectSubset<T, BalanceRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalanceRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BalanceRecord.
     * @param {BalanceRecordCreateArgs} args - Arguments to create a BalanceRecord.
     * @example
     * // Create one BalanceRecord
     * const BalanceRecord = await prisma.balanceRecord.create({
     *   data: {
     *     // ... data to create a BalanceRecord
     *   }
     * })
     * 
     */
    create<T extends BalanceRecordCreateArgs>(args: SelectSubset<T, BalanceRecordCreateArgs<ExtArgs>>): Prisma__BalanceRecordClient<$Result.GetResult<Prisma.$BalanceRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BalanceRecords.
     * @param {BalanceRecordCreateManyArgs} args - Arguments to create many BalanceRecords.
     * @example
     * // Create many BalanceRecords
     * const balanceRecord = await prisma.balanceRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BalanceRecordCreateManyArgs>(args?: SelectSubset<T, BalanceRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BalanceRecords and returns the data saved in the database.
     * @param {BalanceRecordCreateManyAndReturnArgs} args - Arguments to create many BalanceRecords.
     * @example
     * // Create many BalanceRecords
     * const balanceRecord = await prisma.balanceRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BalanceRecords and only return the `id`
     * const balanceRecordWithIdOnly = await prisma.balanceRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BalanceRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, BalanceRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalanceRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BalanceRecord.
     * @param {BalanceRecordDeleteArgs} args - Arguments to delete one BalanceRecord.
     * @example
     * // Delete one BalanceRecord
     * const BalanceRecord = await prisma.balanceRecord.delete({
     *   where: {
     *     // ... filter to delete one BalanceRecord
     *   }
     * })
     * 
     */
    delete<T extends BalanceRecordDeleteArgs>(args: SelectSubset<T, BalanceRecordDeleteArgs<ExtArgs>>): Prisma__BalanceRecordClient<$Result.GetResult<Prisma.$BalanceRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BalanceRecord.
     * @param {BalanceRecordUpdateArgs} args - Arguments to update one BalanceRecord.
     * @example
     * // Update one BalanceRecord
     * const balanceRecord = await prisma.balanceRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BalanceRecordUpdateArgs>(args: SelectSubset<T, BalanceRecordUpdateArgs<ExtArgs>>): Prisma__BalanceRecordClient<$Result.GetResult<Prisma.$BalanceRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BalanceRecords.
     * @param {BalanceRecordDeleteManyArgs} args - Arguments to filter BalanceRecords to delete.
     * @example
     * // Delete a few BalanceRecords
     * const { count } = await prisma.balanceRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BalanceRecordDeleteManyArgs>(args?: SelectSubset<T, BalanceRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BalanceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BalanceRecords
     * const balanceRecord = await prisma.balanceRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BalanceRecordUpdateManyArgs>(args: SelectSubset<T, BalanceRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BalanceRecord.
     * @param {BalanceRecordUpsertArgs} args - Arguments to update or create a BalanceRecord.
     * @example
     * // Update or create a BalanceRecord
     * const balanceRecord = await prisma.balanceRecord.upsert({
     *   create: {
     *     // ... data to create a BalanceRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BalanceRecord we want to update
     *   }
     * })
     */
    upsert<T extends BalanceRecordUpsertArgs>(args: SelectSubset<T, BalanceRecordUpsertArgs<ExtArgs>>): Prisma__BalanceRecordClient<$Result.GetResult<Prisma.$BalanceRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BalanceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceRecordCountArgs} args - Arguments to filter BalanceRecords to count.
     * @example
     * // Count the number of BalanceRecords
     * const count = await prisma.balanceRecord.count({
     *   where: {
     *     // ... the filter for the BalanceRecords we want to count
     *   }
     * })
    **/
    count<T extends BalanceRecordCountArgs>(
      args?: Subset<T, BalanceRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BalanceRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BalanceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BalanceRecordAggregateArgs>(args: Subset<T, BalanceRecordAggregateArgs>): Prisma.PrismaPromise<GetBalanceRecordAggregateType<T>>

    /**
     * Group by BalanceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BalanceRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BalanceRecordGroupByArgs['orderBy'] }
        : { orderBy?: BalanceRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BalanceRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBalanceRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BalanceRecord model
   */
  readonly fields: BalanceRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BalanceRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BalanceRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Transaction<T extends BalanceRecord$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, BalanceRecord$TransactionArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BalanceRecord model
   */ 
  interface BalanceRecordFieldRefs {
    readonly id: FieldRef<"BalanceRecord", 'Int'>
    readonly userId: FieldRef<"BalanceRecord", 'Int'>
    readonly transactionId: FieldRef<"BalanceRecord", 'Int'>
    readonly amount: FieldRef<"BalanceRecord", 'Float'>
    readonly type: FieldRef<"BalanceRecord", 'Int'>
    readonly createdAt: FieldRef<"BalanceRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BalanceRecord findUnique
   */
  export type BalanceRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceRecord
     */
    select?: BalanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which BalanceRecord to fetch.
     */
    where: BalanceRecordWhereUniqueInput
  }

  /**
   * BalanceRecord findUniqueOrThrow
   */
  export type BalanceRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceRecord
     */
    select?: BalanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which BalanceRecord to fetch.
     */
    where: BalanceRecordWhereUniqueInput
  }

  /**
   * BalanceRecord findFirst
   */
  export type BalanceRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceRecord
     */
    select?: BalanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which BalanceRecord to fetch.
     */
    where?: BalanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BalanceRecords to fetch.
     */
    orderBy?: BalanceRecordOrderByWithRelationInput | BalanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BalanceRecords.
     */
    cursor?: BalanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BalanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BalanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BalanceRecords.
     */
    distinct?: BalanceRecordScalarFieldEnum | BalanceRecordScalarFieldEnum[]
  }

  /**
   * BalanceRecord findFirstOrThrow
   */
  export type BalanceRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceRecord
     */
    select?: BalanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which BalanceRecord to fetch.
     */
    where?: BalanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BalanceRecords to fetch.
     */
    orderBy?: BalanceRecordOrderByWithRelationInput | BalanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BalanceRecords.
     */
    cursor?: BalanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BalanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BalanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BalanceRecords.
     */
    distinct?: BalanceRecordScalarFieldEnum | BalanceRecordScalarFieldEnum[]
  }

  /**
   * BalanceRecord findMany
   */
  export type BalanceRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceRecord
     */
    select?: BalanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which BalanceRecords to fetch.
     */
    where?: BalanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BalanceRecords to fetch.
     */
    orderBy?: BalanceRecordOrderByWithRelationInput | BalanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BalanceRecords.
     */
    cursor?: BalanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BalanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BalanceRecords.
     */
    skip?: number
    distinct?: BalanceRecordScalarFieldEnum | BalanceRecordScalarFieldEnum[]
  }

  /**
   * BalanceRecord create
   */
  export type BalanceRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceRecord
     */
    select?: BalanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a BalanceRecord.
     */
    data: XOR<BalanceRecordCreateInput, BalanceRecordUncheckedCreateInput>
  }

  /**
   * BalanceRecord createMany
   */
  export type BalanceRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BalanceRecords.
     */
    data: BalanceRecordCreateManyInput | BalanceRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BalanceRecord createManyAndReturn
   */
  export type BalanceRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceRecord
     */
    select?: BalanceRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BalanceRecords.
     */
    data: BalanceRecordCreateManyInput | BalanceRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BalanceRecord update
   */
  export type BalanceRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceRecord
     */
    select?: BalanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a BalanceRecord.
     */
    data: XOR<BalanceRecordUpdateInput, BalanceRecordUncheckedUpdateInput>
    /**
     * Choose, which BalanceRecord to update.
     */
    where: BalanceRecordWhereUniqueInput
  }

  /**
   * BalanceRecord updateMany
   */
  export type BalanceRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BalanceRecords.
     */
    data: XOR<BalanceRecordUpdateManyMutationInput, BalanceRecordUncheckedUpdateManyInput>
    /**
     * Filter which BalanceRecords to update
     */
    where?: BalanceRecordWhereInput
  }

  /**
   * BalanceRecord upsert
   */
  export type BalanceRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceRecord
     */
    select?: BalanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the BalanceRecord to update in case it exists.
     */
    where: BalanceRecordWhereUniqueInput
    /**
     * In case the BalanceRecord found by the `where` argument doesn't exist, create a new BalanceRecord with this data.
     */
    create: XOR<BalanceRecordCreateInput, BalanceRecordUncheckedCreateInput>
    /**
     * In case the BalanceRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BalanceRecordUpdateInput, BalanceRecordUncheckedUpdateInput>
  }

  /**
   * BalanceRecord delete
   */
  export type BalanceRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceRecord
     */
    select?: BalanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceRecordInclude<ExtArgs> | null
    /**
     * Filter which BalanceRecord to delete.
     */
    where: BalanceRecordWhereUniqueInput
  }

  /**
   * BalanceRecord deleteMany
   */
  export type BalanceRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BalanceRecords to delete
     */
    where?: BalanceRecordWhereInput
  }

  /**
   * BalanceRecord.Transaction
   */
  export type BalanceRecord$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
  }

  /**
   * BalanceRecord without action
   */
  export type BalanceRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceRecord
     */
    select?: BalanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceRecordInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    userId: 'userId',
    roleId: 'roleId'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    action: 'action',
    description: 'description'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const RolePermissionsScalarFieldEnum: {
    roleId: 'roleId',
    permissionId: 'permissionId'
  };

  export type RolePermissionsScalarFieldEnum = (typeof RolePermissionsScalarFieldEnum)[keyof typeof RolePermissionsScalarFieldEnum]


  export const PolicyScalarFieldEnum: {
    id: 'id',
    type: 'type',
    effect: 'effect',
    action: 'action',
    subject: 'subject',
    fields: 'fields',
    conditions: 'conditions',
    args: 'args',
    encode: 'encode'
  };

  export type PolicyScalarFieldEnum = (typeof PolicyScalarFieldEnum)[keyof typeof PolicyScalarFieldEnum]


  export const RolePolicyScalarFieldEnum: {
    roleId: 'roleId',
    policyId: 'policyId'
  };

  export type RolePolicyScalarFieldEnum = (typeof RolePolicyScalarFieldEnum)[keyof typeof RolePolicyScalarFieldEnum]


  export const PermissionPolicyScalarFieldEnum: {
    permissionId: 'permissionId',
    policyId: 'policyId'
  };

  export type PermissionPolicyScalarFieldEnum = (typeof PermissionPolicyScalarFieldEnum)[keyof typeof PermissionPolicyScalarFieldEnum]


  export const MenuScalarFieldEnum: {
    id: 'id',
    name: 'name',
    path: 'path',
    label: 'label',
    component: 'component',
    redirect: 'redirect',
    fullPath: 'fullPath',
    alias: 'alias',
    status: 'status',
    parentId: 'parentId',
    metaId: 'metaId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MenuScalarFieldEnum = (typeof MenuScalarFieldEnum)[keyof typeof MenuScalarFieldEnum]


  export const MenuMetaScalarFieldEnum: {
    id: 'id',
    title: 'title',
    layout: 'layout',
    order: 'order',
    hidden: 'hidden',
    disabled: 'disabled',
    icon: 'icon',
    status: 'status',
    menuId: 'menuId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MenuMetaScalarFieldEnum = (typeof MenuMetaScalarFieldEnum)[keyof typeof MenuMetaScalarFieldEnum]


  export const RoleMenuScalarFieldEnum: {
    roleId: 'roleId',
    menuId: 'menuId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleMenuScalarFieldEnum = (typeof RoleMenuScalarFieldEnum)[keyof typeof RoleMenuScalarFieldEnum]


  export const DictAttachmentAttributeScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    desc: 'desc'
  };

  export type DictAttachmentAttributeScalarFieldEnum = (typeof DictAttachmentAttributeScalarFieldEnum)[keyof typeof DictAttachmentAttributeScalarFieldEnum]


  export const AttachmentAttributeScalarFieldEnum: {
    attachmentId: 'attachmentId',
    attributeId: 'attributeId',
    value: 'value',
    desc: 'desc'
  };

  export type AttachmentAttributeScalarFieldEnum = (typeof AttachmentAttributeScalarFieldEnum)[keyof typeof AttachmentAttributeScalarFieldEnum]


  export const AttachmentScalarFieldEnum: {
    id: 'id',
    type: 'type',
    location: 'location',
    name: 'name',
    ossType: 'ossType',
    userId: 'userId',
    status: 'status',
    desc: 'desc',
    createdAt: 'createdAt'
  };

  export type AttachmentScalarFieldEnum = (typeof AttachmentScalarFieldEnum)[keyof typeof AttachmentScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    title: 'title',
    subTitle: 'subTitle',
    desc: 'desc',
    coverId: 'coverId',
    authorId: 'authorId',
    originPrice: 'originPrice',
    price: 'price',
    status: 'status',
    counts: 'counts',
    order: 'order',
    detail: 'detail',
    type: 'type'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const CourseContentScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    title: 'title',
    type: 'type',
    order: 'order',
    pid: 'pid',
    status: 'status',
    authorId: 'authorId'
  };

  export type CourseContentScalarFieldEnum = (typeof CourseContentScalarFieldEnum)[keyof typeof CourseContentScalarFieldEnum]


  export const ContentAttachmentScalarFieldEnum: {
    contentId: 'contentId',
    attachmentId: 'attachmentId'
  };

  export type ContentAttachmentScalarFieldEnum = (typeof ContentAttachmentScalarFieldEnum)[keyof typeof ContentAttachmentScalarFieldEnum]


  export const DictCourseTagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    typeId: 'typeId',
    order: 'order',
    status: 'status'
  };

  export type DictCourseTagScalarFieldEnum = (typeof DictCourseTagScalarFieldEnum)[keyof typeof DictCourseTagScalarFieldEnum]


  export const DictCourseTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    order: 'order',
    status: 'status'
  };

  export type DictCourseTypeScalarFieldEnum = (typeof DictCourseTypeScalarFieldEnum)[keyof typeof DictCourseTypeScalarFieldEnum]


  export const CourseTagScalarFieldEnum: {
    courseId: 'courseId',
    tagId: 'tagId'
  };

  export type CourseTagScalarFieldEnum = (typeof CourseTagScalarFieldEnum)[keyof typeof CourseTagScalarFieldEnum]


  export const ContentTagScalarFieldEnum: {
    contentId: 'contentId',
    tagId: 'tagId'
  };

  export type ContentTagScalarFieldEnum = (typeof ContentTagScalarFieldEnum)[keyof typeof ContentTagScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    pid: 'pid',
    userId: 'userId',
    created: 'created',
    hands: 'hands',
    status: 'status',
    isBest: 'isBest'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const CourseCommentScalarFieldEnum: {
    courseId: 'courseId',
    commentId: 'commentId'
  };

  export type CourseCommentScalarFieldEnum = (typeof CourseCommentScalarFieldEnum)[keyof typeof CourseCommentScalarFieldEnum]


  export const ContentCommentScalarFieldEnum: {
    contentId: 'contentId',
    commentId: 'commentId'
  };

  export type ContentCommentScalarFieldEnum = (typeof ContentCommentScalarFieldEnum)[keyof typeof ContentCommentScalarFieldEnum]


  export const NoteScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    content: 'content',
    createAt: 'createAt',
    updateAt: 'updateAt',
    status: 'status'
  };

  export type NoteScalarFieldEnum = (typeof NoteScalarFieldEnum)[keyof typeof NoteScalarFieldEnum]


  export const DictPlatformScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url'
  };

  export type DictPlatformScalarFieldEnum = (typeof DictPlatformScalarFieldEnum)[keyof typeof DictPlatformScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    userId: 'userId',
    amount: 'amount',
    platformId: 'platformId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const GroupTransactionScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    transactionId: 'transactionId'
  };

  export type GroupTransactionScalarFieldEnum = (typeof GroupTransactionScalarFieldEnum)[keyof typeof GroupTransactionScalarFieldEnum]


  export const AuditFlowScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type AuditFlowScalarFieldEnum = (typeof AuditFlowScalarFieldEnum)[keyof typeof AuditFlowScalarFieldEnum]


  export const AuditStageScalarFieldEnum: {
    id: 'id',
    flowId: 'flowId',
    name: 'name',
    level: 'level',
    pid: 'pid'
  };

  export type AuditStageScalarFieldEnum = (typeof AuditStageScalarFieldEnum)[keyof typeof AuditStageScalarFieldEnum]


  export const AuditRecordScalarFieldEnum: {
    id: 'id',
    entityId: 'entityId',
    entityType: 'entityType',
    stageId: 'stageId',
    status: 'status',
    reviewerId: 'reviewerId',
    createdAt: 'createdAt',
    notes: 'notes'
  };

  export type AuditRecordScalarFieldEnum = (typeof AuditRecordScalarFieldEnum)[keyof typeof AuditRecordScalarFieldEnum]


  export const DictCouponTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    desc: 'desc'
  };

  export type DictCouponTypeScalarFieldEnum = (typeof DictCouponTypeScalarFieldEnum)[keyof typeof DictCouponTypeScalarFieldEnum]


  export const CouponScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    typeId: 'typeId',
    threshold: 'threshold',
    discount: 'discount',
    validUntil: 'validUntil',
    universal: 'universal'
  };

  export type CouponScalarFieldEnum = (typeof CouponScalarFieldEnum)[keyof typeof CouponScalarFieldEnum]


  export const BalanceRecordScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    transactionId: 'transactionId',
    amount: 'amount',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type BalanceRecordScalarFieldEnum = (typeof BalanceRecordScalarFieldEnum)[keyof typeof BalanceRecordScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    UserRole?: UserRoleListRelationFilter
    Attachment?: AttachmentListRelationFilter
    Course?: CourseListRelationFilter
    CourseContent?: CourseContentListRelationFilter
    Comment?: CommentListRelationFilter
    Transaction?: TransactionListRelationFilter
    AuditRecord?: AuditRecordListRelationFilter
    BalanceRecord?: BalanceRecordListRelationFilter
    Note?: NoteListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    UserRole?: UserRoleOrderByRelationAggregateInput
    Attachment?: AttachmentOrderByRelationAggregateInput
    Course?: CourseOrderByRelationAggregateInput
    CourseContent?: CourseContentOrderByRelationAggregateInput
    Comment?: CommentOrderByRelationAggregateInput
    Transaction?: TransactionOrderByRelationAggregateInput
    AuditRecord?: AuditRecordOrderByRelationAggregateInput
    BalanceRecord?: BalanceRecordOrderByRelationAggregateInput
    Note?: NoteOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    UserRole?: UserRoleListRelationFilter
    Attachment?: AttachmentListRelationFilter
    Course?: CourseListRelationFilter
    CourseContent?: CourseContentListRelationFilter
    Comment?: CommentListRelationFilter
    Transaction?: TransactionListRelationFilter
    AuditRecord?: AuditRecordListRelationFilter
    BalanceRecord?: BalanceRecordListRelationFilter
    Note?: NoteListRelationFilter
  }, "id" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: IntFilter<"Role"> | number
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    users?: UserRoleListRelationFilter
    RolePermissions?: RolePermissionsListRelationFilter
    RolePolicy?: RolePolicyListRelationFilter
    RoleMenu?: RoleMenuListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    users?: UserRoleOrderByRelationAggregateInput
    RolePermissions?: RolePermissionsOrderByRelationAggregateInput
    RolePolicy?: RolePolicyOrderByRelationAggregateInput
    RoleMenu?: RoleMenuOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    users?: UserRoleListRelationFilter
    RolePermissions?: RolePermissionsListRelationFilter
    RolePolicy?: RolePolicyListRelationFilter
    RoleMenu?: RoleMenuListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Role"> | number
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: IntFilter<"UserRole"> | number
    roleId?: IntFilter<"UserRole"> | number
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    role?: RoleOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    userId_roleId?: UserRoleUserIdRoleIdCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: IntFilter<"UserRole"> | number
    roleId?: IntFilter<"UserRole"> | number
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "userId_roleId">

  export type UserRoleOrderByWithAggregationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _avg?: UserRoleAvgOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
    _sum?: UserRoleSumOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"UserRole"> | number
    roleId?: IntWithAggregatesFilter<"UserRole"> | number
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: IntFilter<"Permission"> | number
    name?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    RolePermissions?: RolePermissionsListRelationFilter
    PermissionPolicy?: PermissionPolicyListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    action?: SortOrder
    description?: SortOrderInput | SortOrder
    RolePermissions?: RolePermissionsOrderByRelationAggregateInput
    PermissionPolicy?: PermissionPolicyOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    action?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    RolePermissions?: RolePermissionsListRelationFilter
    PermissionPolicy?: PermissionPolicyListRelationFilter
  }, "id" | "name">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    action?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _avg?: PermissionAvgOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
    _sum?: PermissionSumOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Permission"> | number
    name?: StringWithAggregatesFilter<"Permission"> | string
    action?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
  }

  export type RolePermissionsWhereInput = {
    AND?: RolePermissionsWhereInput | RolePermissionsWhereInput[]
    OR?: RolePermissionsWhereInput[]
    NOT?: RolePermissionsWhereInput | RolePermissionsWhereInput[]
    roleId?: IntFilter<"RolePermissions"> | number
    permissionId?: IntFilter<"RolePermissions"> | number
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionRelationFilter, PermissionWhereInput>
  }

  export type RolePermissionsOrderByWithRelationInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
    role?: RoleOrderByWithRelationInput
    permission?: PermissionOrderByWithRelationInput
  }

  export type RolePermissionsWhereUniqueInput = Prisma.AtLeast<{
    roleId_permissionId?: RolePermissionsRoleIdPermissionIdCompoundUniqueInput
    AND?: RolePermissionsWhereInput | RolePermissionsWhereInput[]
    OR?: RolePermissionsWhereInput[]
    NOT?: RolePermissionsWhereInput | RolePermissionsWhereInput[]
    roleId?: IntFilter<"RolePermissions"> | number
    permissionId?: IntFilter<"RolePermissions"> | number
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionRelationFilter, PermissionWhereInput>
  }, "roleId_permissionId">

  export type RolePermissionsOrderByWithAggregationInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
    _count?: RolePermissionsCountOrderByAggregateInput
    _avg?: RolePermissionsAvgOrderByAggregateInput
    _max?: RolePermissionsMaxOrderByAggregateInput
    _min?: RolePermissionsMinOrderByAggregateInput
    _sum?: RolePermissionsSumOrderByAggregateInput
  }

  export type RolePermissionsScalarWhereWithAggregatesInput = {
    AND?: RolePermissionsScalarWhereWithAggregatesInput | RolePermissionsScalarWhereWithAggregatesInput[]
    OR?: RolePermissionsScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionsScalarWhereWithAggregatesInput | RolePermissionsScalarWhereWithAggregatesInput[]
    roleId?: IntWithAggregatesFilter<"RolePermissions"> | number
    permissionId?: IntWithAggregatesFilter<"RolePermissions"> | number
  }

  export type PolicyWhereInput = {
    AND?: PolicyWhereInput | PolicyWhereInput[]
    OR?: PolicyWhereInput[]
    NOT?: PolicyWhereInput | PolicyWhereInput[]
    id?: IntFilter<"Policy"> | number
    type?: IntFilter<"Policy"> | number
    effect?: StringFilter<"Policy"> | string
    action?: StringFilter<"Policy"> | string
    subject?: StringFilter<"Policy"> | string
    fields?: JsonNullableFilter<"Policy">
    conditions?: JsonNullableFilter<"Policy">
    args?: JsonNullableFilter<"Policy">
    encode?: StringFilter<"Policy"> | string
    RolePolicy?: RolePolicyListRelationFilter
    PermissionPolicy?: PermissionPolicyListRelationFilter
  }

  export type PolicyOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    effect?: SortOrder
    action?: SortOrder
    subject?: SortOrder
    fields?: SortOrderInput | SortOrder
    conditions?: SortOrderInput | SortOrder
    args?: SortOrderInput | SortOrder
    encode?: SortOrder
    RolePolicy?: RolePolicyOrderByRelationAggregateInput
    PermissionPolicy?: PermissionPolicyOrderByRelationAggregateInput
  }

  export type PolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    encode?: string
    AND?: PolicyWhereInput | PolicyWhereInput[]
    OR?: PolicyWhereInput[]
    NOT?: PolicyWhereInput | PolicyWhereInput[]
    type?: IntFilter<"Policy"> | number
    effect?: StringFilter<"Policy"> | string
    action?: StringFilter<"Policy"> | string
    subject?: StringFilter<"Policy"> | string
    fields?: JsonNullableFilter<"Policy">
    conditions?: JsonNullableFilter<"Policy">
    args?: JsonNullableFilter<"Policy">
    RolePolicy?: RolePolicyListRelationFilter
    PermissionPolicy?: PermissionPolicyListRelationFilter
  }, "id" | "encode">

  export type PolicyOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    effect?: SortOrder
    action?: SortOrder
    subject?: SortOrder
    fields?: SortOrderInput | SortOrder
    conditions?: SortOrderInput | SortOrder
    args?: SortOrderInput | SortOrder
    encode?: SortOrder
    _count?: PolicyCountOrderByAggregateInput
    _avg?: PolicyAvgOrderByAggregateInput
    _max?: PolicyMaxOrderByAggregateInput
    _min?: PolicyMinOrderByAggregateInput
    _sum?: PolicySumOrderByAggregateInput
  }

  export type PolicyScalarWhereWithAggregatesInput = {
    AND?: PolicyScalarWhereWithAggregatesInput | PolicyScalarWhereWithAggregatesInput[]
    OR?: PolicyScalarWhereWithAggregatesInput[]
    NOT?: PolicyScalarWhereWithAggregatesInput | PolicyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Policy"> | number
    type?: IntWithAggregatesFilter<"Policy"> | number
    effect?: StringWithAggregatesFilter<"Policy"> | string
    action?: StringWithAggregatesFilter<"Policy"> | string
    subject?: StringWithAggregatesFilter<"Policy"> | string
    fields?: JsonNullableWithAggregatesFilter<"Policy">
    conditions?: JsonNullableWithAggregatesFilter<"Policy">
    args?: JsonNullableWithAggregatesFilter<"Policy">
    encode?: StringWithAggregatesFilter<"Policy"> | string
  }

  export type RolePolicyWhereInput = {
    AND?: RolePolicyWhereInput | RolePolicyWhereInput[]
    OR?: RolePolicyWhereInput[]
    NOT?: RolePolicyWhereInput | RolePolicyWhereInput[]
    roleId?: IntFilter<"RolePolicy"> | number
    policyId?: IntFilter<"RolePolicy"> | number
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    policy?: XOR<PolicyRelationFilter, PolicyWhereInput>
  }

  export type RolePolicyOrderByWithRelationInput = {
    roleId?: SortOrder
    policyId?: SortOrder
    role?: RoleOrderByWithRelationInput
    policy?: PolicyOrderByWithRelationInput
  }

  export type RolePolicyWhereUniqueInput = Prisma.AtLeast<{
    roleId_policyId?: RolePolicyRoleIdPolicyIdCompoundUniqueInput
    AND?: RolePolicyWhereInput | RolePolicyWhereInput[]
    OR?: RolePolicyWhereInput[]
    NOT?: RolePolicyWhereInput | RolePolicyWhereInput[]
    roleId?: IntFilter<"RolePolicy"> | number
    policyId?: IntFilter<"RolePolicy"> | number
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    policy?: XOR<PolicyRelationFilter, PolicyWhereInput>
  }, "roleId_policyId">

  export type RolePolicyOrderByWithAggregationInput = {
    roleId?: SortOrder
    policyId?: SortOrder
    _count?: RolePolicyCountOrderByAggregateInput
    _avg?: RolePolicyAvgOrderByAggregateInput
    _max?: RolePolicyMaxOrderByAggregateInput
    _min?: RolePolicyMinOrderByAggregateInput
    _sum?: RolePolicySumOrderByAggregateInput
  }

  export type RolePolicyScalarWhereWithAggregatesInput = {
    AND?: RolePolicyScalarWhereWithAggregatesInput | RolePolicyScalarWhereWithAggregatesInput[]
    OR?: RolePolicyScalarWhereWithAggregatesInput[]
    NOT?: RolePolicyScalarWhereWithAggregatesInput | RolePolicyScalarWhereWithAggregatesInput[]
    roleId?: IntWithAggregatesFilter<"RolePolicy"> | number
    policyId?: IntWithAggregatesFilter<"RolePolicy"> | number
  }

  export type PermissionPolicyWhereInput = {
    AND?: PermissionPolicyWhereInput | PermissionPolicyWhereInput[]
    OR?: PermissionPolicyWhereInput[]
    NOT?: PermissionPolicyWhereInput | PermissionPolicyWhereInput[]
    permissionId?: IntFilter<"PermissionPolicy"> | number
    policyId?: IntFilter<"PermissionPolicy"> | number
    permission?: XOR<PermissionRelationFilter, PermissionWhereInput>
    policy?: XOR<PolicyRelationFilter, PolicyWhereInput>
  }

  export type PermissionPolicyOrderByWithRelationInput = {
    permissionId?: SortOrder
    policyId?: SortOrder
    permission?: PermissionOrderByWithRelationInput
    policy?: PolicyOrderByWithRelationInput
  }

  export type PermissionPolicyWhereUniqueInput = Prisma.AtLeast<{
    permissionId_policyId?: PermissionPolicyPermissionIdPolicyIdCompoundUniqueInput
    AND?: PermissionPolicyWhereInput | PermissionPolicyWhereInput[]
    OR?: PermissionPolicyWhereInput[]
    NOT?: PermissionPolicyWhereInput | PermissionPolicyWhereInput[]
    permissionId?: IntFilter<"PermissionPolicy"> | number
    policyId?: IntFilter<"PermissionPolicy"> | number
    permission?: XOR<PermissionRelationFilter, PermissionWhereInput>
    policy?: XOR<PolicyRelationFilter, PolicyWhereInput>
  }, "permissionId_policyId">

  export type PermissionPolicyOrderByWithAggregationInput = {
    permissionId?: SortOrder
    policyId?: SortOrder
    _count?: PermissionPolicyCountOrderByAggregateInput
    _avg?: PermissionPolicyAvgOrderByAggregateInput
    _max?: PermissionPolicyMaxOrderByAggregateInput
    _min?: PermissionPolicyMinOrderByAggregateInput
    _sum?: PermissionPolicySumOrderByAggregateInput
  }

  export type PermissionPolicyScalarWhereWithAggregatesInput = {
    AND?: PermissionPolicyScalarWhereWithAggregatesInput | PermissionPolicyScalarWhereWithAggregatesInput[]
    OR?: PermissionPolicyScalarWhereWithAggregatesInput[]
    NOT?: PermissionPolicyScalarWhereWithAggregatesInput | PermissionPolicyScalarWhereWithAggregatesInput[]
    permissionId?: IntWithAggregatesFilter<"PermissionPolicy"> | number
    policyId?: IntWithAggregatesFilter<"PermissionPolicy"> | number
  }

  export type MenuWhereInput = {
    AND?: MenuWhereInput | MenuWhereInput[]
    OR?: MenuWhereInput[]
    NOT?: MenuWhereInput | MenuWhereInput[]
    id?: IntFilter<"Menu"> | number
    name?: StringFilter<"Menu"> | string
    path?: StringFilter<"Menu"> | string
    label?: StringFilter<"Menu"> | string
    component?: StringNullableFilter<"Menu"> | string | null
    redirect?: StringNullableFilter<"Menu"> | string | null
    fullPath?: StringNullableFilter<"Menu"> | string | null
    alias?: StringNullableFilter<"Menu"> | string | null
    status?: IntFilter<"Menu"> | number
    parentId?: IntNullableFilter<"Menu"> | number | null
    metaId?: IntNullableFilter<"Menu"> | number | null
    createdAt?: DateTimeFilter<"Menu"> | Date | string
    updatedAt?: DateTimeFilter<"Menu"> | Date | string
    meta?: XOR<MenuMetaNullableRelationFilter, MenuMetaWhereInput> | null
    parent?: XOR<MenuNullableRelationFilter, MenuWhereInput> | null
    children?: MenuListRelationFilter
    roleMenus?: RoleMenuListRelationFilter
  }

  export type MenuOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    label?: SortOrder
    component?: SortOrderInput | SortOrder
    redirect?: SortOrderInput | SortOrder
    fullPath?: SortOrderInput | SortOrder
    alias?: SortOrderInput | SortOrder
    status?: SortOrder
    parentId?: SortOrderInput | SortOrder
    metaId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    meta?: MenuMetaOrderByWithRelationInput
    parent?: MenuOrderByWithRelationInput
    children?: MenuOrderByRelationAggregateInput
    roleMenus?: RoleMenuOrderByRelationAggregateInput
  }

  export type MenuWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    metaId?: number
    AND?: MenuWhereInput | MenuWhereInput[]
    OR?: MenuWhereInput[]
    NOT?: MenuWhereInput | MenuWhereInput[]
    path?: StringFilter<"Menu"> | string
    label?: StringFilter<"Menu"> | string
    component?: StringNullableFilter<"Menu"> | string | null
    redirect?: StringNullableFilter<"Menu"> | string | null
    fullPath?: StringNullableFilter<"Menu"> | string | null
    alias?: StringNullableFilter<"Menu"> | string | null
    status?: IntFilter<"Menu"> | number
    parentId?: IntNullableFilter<"Menu"> | number | null
    createdAt?: DateTimeFilter<"Menu"> | Date | string
    updatedAt?: DateTimeFilter<"Menu"> | Date | string
    meta?: XOR<MenuMetaNullableRelationFilter, MenuMetaWhereInput> | null
    parent?: XOR<MenuNullableRelationFilter, MenuWhereInput> | null
    children?: MenuListRelationFilter
    roleMenus?: RoleMenuListRelationFilter
  }, "id" | "name" | "metaId">

  export type MenuOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    label?: SortOrder
    component?: SortOrderInput | SortOrder
    redirect?: SortOrderInput | SortOrder
    fullPath?: SortOrderInput | SortOrder
    alias?: SortOrderInput | SortOrder
    status?: SortOrder
    parentId?: SortOrderInput | SortOrder
    metaId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MenuCountOrderByAggregateInput
    _avg?: MenuAvgOrderByAggregateInput
    _max?: MenuMaxOrderByAggregateInput
    _min?: MenuMinOrderByAggregateInput
    _sum?: MenuSumOrderByAggregateInput
  }

  export type MenuScalarWhereWithAggregatesInput = {
    AND?: MenuScalarWhereWithAggregatesInput | MenuScalarWhereWithAggregatesInput[]
    OR?: MenuScalarWhereWithAggregatesInput[]
    NOT?: MenuScalarWhereWithAggregatesInput | MenuScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Menu"> | number
    name?: StringWithAggregatesFilter<"Menu"> | string
    path?: StringWithAggregatesFilter<"Menu"> | string
    label?: StringWithAggregatesFilter<"Menu"> | string
    component?: StringNullableWithAggregatesFilter<"Menu"> | string | null
    redirect?: StringNullableWithAggregatesFilter<"Menu"> | string | null
    fullPath?: StringNullableWithAggregatesFilter<"Menu"> | string | null
    alias?: StringNullableWithAggregatesFilter<"Menu"> | string | null
    status?: IntWithAggregatesFilter<"Menu"> | number
    parentId?: IntNullableWithAggregatesFilter<"Menu"> | number | null
    metaId?: IntNullableWithAggregatesFilter<"Menu"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Menu"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Menu"> | Date | string
  }

  export type MenuMetaWhereInput = {
    AND?: MenuMetaWhereInput | MenuMetaWhereInput[]
    OR?: MenuMetaWhereInput[]
    NOT?: MenuMetaWhereInput | MenuMetaWhereInput[]
    id?: IntFilter<"MenuMeta"> | number
    title?: StringNullableFilter<"MenuMeta"> | string | null
    layout?: StringNullableFilter<"MenuMeta"> | string | null
    order?: IntNullableFilter<"MenuMeta"> | number | null
    hidden?: BoolFilter<"MenuMeta"> | boolean
    disabled?: BoolFilter<"MenuMeta"> | boolean
    icon?: StringNullableFilter<"MenuMeta"> | string | null
    status?: IntFilter<"MenuMeta"> | number
    menuId?: IntFilter<"MenuMeta"> | number
    createdAt?: DateTimeFilter<"MenuMeta"> | Date | string
    updatedAt?: DateTimeFilter<"MenuMeta"> | Date | string
    menu?: XOR<MenuRelationFilter, MenuWhereInput>
  }

  export type MenuMetaOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    layout?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    hidden?: SortOrder
    disabled?: SortOrder
    icon?: SortOrderInput | SortOrder
    status?: SortOrder
    menuId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    menu?: MenuOrderByWithRelationInput
  }

  export type MenuMetaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    menuId?: number
    AND?: MenuMetaWhereInput | MenuMetaWhereInput[]
    OR?: MenuMetaWhereInput[]
    NOT?: MenuMetaWhereInput | MenuMetaWhereInput[]
    title?: StringNullableFilter<"MenuMeta"> | string | null
    layout?: StringNullableFilter<"MenuMeta"> | string | null
    order?: IntNullableFilter<"MenuMeta"> | number | null
    hidden?: BoolFilter<"MenuMeta"> | boolean
    disabled?: BoolFilter<"MenuMeta"> | boolean
    icon?: StringNullableFilter<"MenuMeta"> | string | null
    status?: IntFilter<"MenuMeta"> | number
    createdAt?: DateTimeFilter<"MenuMeta"> | Date | string
    updatedAt?: DateTimeFilter<"MenuMeta"> | Date | string
    menu?: XOR<MenuRelationFilter, MenuWhereInput>
  }, "id" | "menuId">

  export type MenuMetaOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    layout?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    hidden?: SortOrder
    disabled?: SortOrder
    icon?: SortOrderInput | SortOrder
    status?: SortOrder
    menuId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MenuMetaCountOrderByAggregateInput
    _avg?: MenuMetaAvgOrderByAggregateInput
    _max?: MenuMetaMaxOrderByAggregateInput
    _min?: MenuMetaMinOrderByAggregateInput
    _sum?: MenuMetaSumOrderByAggregateInput
  }

  export type MenuMetaScalarWhereWithAggregatesInput = {
    AND?: MenuMetaScalarWhereWithAggregatesInput | MenuMetaScalarWhereWithAggregatesInput[]
    OR?: MenuMetaScalarWhereWithAggregatesInput[]
    NOT?: MenuMetaScalarWhereWithAggregatesInput | MenuMetaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MenuMeta"> | number
    title?: StringNullableWithAggregatesFilter<"MenuMeta"> | string | null
    layout?: StringNullableWithAggregatesFilter<"MenuMeta"> | string | null
    order?: IntNullableWithAggregatesFilter<"MenuMeta"> | number | null
    hidden?: BoolWithAggregatesFilter<"MenuMeta"> | boolean
    disabled?: BoolWithAggregatesFilter<"MenuMeta"> | boolean
    icon?: StringNullableWithAggregatesFilter<"MenuMeta"> | string | null
    status?: IntWithAggregatesFilter<"MenuMeta"> | number
    menuId?: IntWithAggregatesFilter<"MenuMeta"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MenuMeta"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MenuMeta"> | Date | string
  }

  export type RoleMenuWhereInput = {
    AND?: RoleMenuWhereInput | RoleMenuWhereInput[]
    OR?: RoleMenuWhereInput[]
    NOT?: RoleMenuWhereInput | RoleMenuWhereInput[]
    roleId?: IntFilter<"RoleMenu"> | number
    menuId?: IntFilter<"RoleMenu"> | number
    createdAt?: DateTimeFilter<"RoleMenu"> | Date | string
    updatedAt?: DateTimeFilter<"RoleMenu"> | Date | string
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    menu?: XOR<MenuRelationFilter, MenuWhereInput>
  }

  export type RoleMenuOrderByWithRelationInput = {
    roleId?: SortOrder
    menuId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: RoleOrderByWithRelationInput
    menu?: MenuOrderByWithRelationInput
  }

  export type RoleMenuWhereUniqueInput = Prisma.AtLeast<{
    roleId_menuId?: RoleMenuRoleIdMenuIdCompoundUniqueInput
    AND?: RoleMenuWhereInput | RoleMenuWhereInput[]
    OR?: RoleMenuWhereInput[]
    NOT?: RoleMenuWhereInput | RoleMenuWhereInput[]
    roleId?: IntFilter<"RoleMenu"> | number
    menuId?: IntFilter<"RoleMenu"> | number
    createdAt?: DateTimeFilter<"RoleMenu"> | Date | string
    updatedAt?: DateTimeFilter<"RoleMenu"> | Date | string
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    menu?: XOR<MenuRelationFilter, MenuWhereInput>
  }, "roleId_menuId">

  export type RoleMenuOrderByWithAggregationInput = {
    roleId?: SortOrder
    menuId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleMenuCountOrderByAggregateInput
    _avg?: RoleMenuAvgOrderByAggregateInput
    _max?: RoleMenuMaxOrderByAggregateInput
    _min?: RoleMenuMinOrderByAggregateInput
    _sum?: RoleMenuSumOrderByAggregateInput
  }

  export type RoleMenuScalarWhereWithAggregatesInput = {
    AND?: RoleMenuScalarWhereWithAggregatesInput | RoleMenuScalarWhereWithAggregatesInput[]
    OR?: RoleMenuScalarWhereWithAggregatesInput[]
    NOT?: RoleMenuScalarWhereWithAggregatesInput | RoleMenuScalarWhereWithAggregatesInput[]
    roleId?: IntWithAggregatesFilter<"RoleMenu"> | number
    menuId?: IntWithAggregatesFilter<"RoleMenu"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RoleMenu"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoleMenu"> | Date | string
  }

  export type DictAttachmentAttributeWhereInput = {
    AND?: DictAttachmentAttributeWhereInput | DictAttachmentAttributeWhereInput[]
    OR?: DictAttachmentAttributeWhereInput[]
    NOT?: DictAttachmentAttributeWhereInput | DictAttachmentAttributeWhereInput[]
    id?: IntFilter<"DictAttachmentAttribute"> | number
    type?: StringFilter<"DictAttachmentAttribute"> | string
    name?: StringFilter<"DictAttachmentAttribute"> | string
    desc?: StringNullableFilter<"DictAttachmentAttribute"> | string | null
    AttachmentAttribute?: AttachmentAttributeListRelationFilter
  }

  export type DictAttachmentAttributeOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    desc?: SortOrderInput | SortOrder
    AttachmentAttribute?: AttachmentAttributeOrderByRelationAggregateInput
  }

  export type DictAttachmentAttributeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    type_name?: DictAttachmentAttributeTypeNameCompoundUniqueInput
    AND?: DictAttachmentAttributeWhereInput | DictAttachmentAttributeWhereInput[]
    OR?: DictAttachmentAttributeWhereInput[]
    NOT?: DictAttachmentAttributeWhereInput | DictAttachmentAttributeWhereInput[]
    type?: StringFilter<"DictAttachmentAttribute"> | string
    name?: StringFilter<"DictAttachmentAttribute"> | string
    desc?: StringNullableFilter<"DictAttachmentAttribute"> | string | null
    AttachmentAttribute?: AttachmentAttributeListRelationFilter
  }, "id" | "type_name">

  export type DictAttachmentAttributeOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    desc?: SortOrderInput | SortOrder
    _count?: DictAttachmentAttributeCountOrderByAggregateInput
    _avg?: DictAttachmentAttributeAvgOrderByAggregateInput
    _max?: DictAttachmentAttributeMaxOrderByAggregateInput
    _min?: DictAttachmentAttributeMinOrderByAggregateInput
    _sum?: DictAttachmentAttributeSumOrderByAggregateInput
  }

  export type DictAttachmentAttributeScalarWhereWithAggregatesInput = {
    AND?: DictAttachmentAttributeScalarWhereWithAggregatesInput | DictAttachmentAttributeScalarWhereWithAggregatesInput[]
    OR?: DictAttachmentAttributeScalarWhereWithAggregatesInput[]
    NOT?: DictAttachmentAttributeScalarWhereWithAggregatesInput | DictAttachmentAttributeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DictAttachmentAttribute"> | number
    type?: StringWithAggregatesFilter<"DictAttachmentAttribute"> | string
    name?: StringWithAggregatesFilter<"DictAttachmentAttribute"> | string
    desc?: StringNullableWithAggregatesFilter<"DictAttachmentAttribute"> | string | null
  }

  export type AttachmentAttributeWhereInput = {
    AND?: AttachmentAttributeWhereInput | AttachmentAttributeWhereInput[]
    OR?: AttachmentAttributeWhereInput[]
    NOT?: AttachmentAttributeWhereInput | AttachmentAttributeWhereInput[]
    attachmentId?: IntFilter<"AttachmentAttribute"> | number
    attributeId?: IntFilter<"AttachmentAttribute"> | number
    value?: StringFilter<"AttachmentAttribute"> | string
    desc?: StringNullableFilter<"AttachmentAttribute"> | string | null
    Attachment?: XOR<AttachmentRelationFilter, AttachmentWhereInput>
    DictAttribute?: XOR<DictAttachmentAttributeRelationFilter, DictAttachmentAttributeWhereInput>
  }

  export type AttachmentAttributeOrderByWithRelationInput = {
    attachmentId?: SortOrder
    attributeId?: SortOrder
    value?: SortOrder
    desc?: SortOrderInput | SortOrder
    Attachment?: AttachmentOrderByWithRelationInput
    DictAttribute?: DictAttachmentAttributeOrderByWithRelationInput
  }

  export type AttachmentAttributeWhereUniqueInput = Prisma.AtLeast<{
    attachmentId_attributeId?: AttachmentAttributeAttachmentIdAttributeIdCompoundUniqueInput
    AND?: AttachmentAttributeWhereInput | AttachmentAttributeWhereInput[]
    OR?: AttachmentAttributeWhereInput[]
    NOT?: AttachmentAttributeWhereInput | AttachmentAttributeWhereInput[]
    attachmentId?: IntFilter<"AttachmentAttribute"> | number
    attributeId?: IntFilter<"AttachmentAttribute"> | number
    value?: StringFilter<"AttachmentAttribute"> | string
    desc?: StringNullableFilter<"AttachmentAttribute"> | string | null
    Attachment?: XOR<AttachmentRelationFilter, AttachmentWhereInput>
    DictAttribute?: XOR<DictAttachmentAttributeRelationFilter, DictAttachmentAttributeWhereInput>
  }, "attachmentId_attributeId">

  export type AttachmentAttributeOrderByWithAggregationInput = {
    attachmentId?: SortOrder
    attributeId?: SortOrder
    value?: SortOrder
    desc?: SortOrderInput | SortOrder
    _count?: AttachmentAttributeCountOrderByAggregateInput
    _avg?: AttachmentAttributeAvgOrderByAggregateInput
    _max?: AttachmentAttributeMaxOrderByAggregateInput
    _min?: AttachmentAttributeMinOrderByAggregateInput
    _sum?: AttachmentAttributeSumOrderByAggregateInput
  }

  export type AttachmentAttributeScalarWhereWithAggregatesInput = {
    AND?: AttachmentAttributeScalarWhereWithAggregatesInput | AttachmentAttributeScalarWhereWithAggregatesInput[]
    OR?: AttachmentAttributeScalarWhereWithAggregatesInput[]
    NOT?: AttachmentAttributeScalarWhereWithAggregatesInput | AttachmentAttributeScalarWhereWithAggregatesInput[]
    attachmentId?: IntWithAggregatesFilter<"AttachmentAttribute"> | number
    attributeId?: IntWithAggregatesFilter<"AttachmentAttribute"> | number
    value?: StringWithAggregatesFilter<"AttachmentAttribute"> | string
    desc?: StringNullableWithAggregatesFilter<"AttachmentAttribute"> | string | null
  }

  export type AttachmentWhereInput = {
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    id?: IntFilter<"Attachment"> | number
    type?: StringFilter<"Attachment"> | string
    location?: StringFilter<"Attachment"> | string
    name?: StringNullableFilter<"Attachment"> | string | null
    ossType?: StringNullableFilter<"Attachment"> | string | null
    userId?: IntFilter<"Attachment"> | number
    status?: IntFilter<"Attachment"> | number
    desc?: StringNullableFilter<"Attachment"> | string | null
    createdAt?: DateTimeNullableFilter<"Attachment"> | Date | string | null
    User?: XOR<UserRelationFilter, UserWhereInput>
    AttachmentAttribute?: AttachmentAttributeListRelationFilter
    Course?: CourseListRelationFilter
    ContentAttachment?: ContentAttachmentListRelationFilter
  }

  export type AttachmentOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    location?: SortOrder
    name?: SortOrderInput | SortOrder
    ossType?: SortOrderInput | SortOrder
    userId?: SortOrder
    status?: SortOrder
    desc?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
    AttachmentAttribute?: AttachmentAttributeOrderByRelationAggregateInput
    Course?: CourseOrderByRelationAggregateInput
    ContentAttachment?: ContentAttachmentOrderByRelationAggregateInput
  }

  export type AttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    type?: StringFilter<"Attachment"> | string
    location?: StringFilter<"Attachment"> | string
    name?: StringNullableFilter<"Attachment"> | string | null
    ossType?: StringNullableFilter<"Attachment"> | string | null
    userId?: IntFilter<"Attachment"> | number
    status?: IntFilter<"Attachment"> | number
    desc?: StringNullableFilter<"Attachment"> | string | null
    createdAt?: DateTimeNullableFilter<"Attachment"> | Date | string | null
    User?: XOR<UserRelationFilter, UserWhereInput>
    AttachmentAttribute?: AttachmentAttributeListRelationFilter
    Course?: CourseListRelationFilter
    ContentAttachment?: ContentAttachmentListRelationFilter
  }, "id">

  export type AttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    location?: SortOrder
    name?: SortOrderInput | SortOrder
    ossType?: SortOrderInput | SortOrder
    userId?: SortOrder
    status?: SortOrder
    desc?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: AttachmentCountOrderByAggregateInput
    _avg?: AttachmentAvgOrderByAggregateInput
    _max?: AttachmentMaxOrderByAggregateInput
    _min?: AttachmentMinOrderByAggregateInput
    _sum?: AttachmentSumOrderByAggregateInput
  }

  export type AttachmentScalarWhereWithAggregatesInput = {
    AND?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    OR?: AttachmentScalarWhereWithAggregatesInput[]
    NOT?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Attachment"> | number
    type?: StringWithAggregatesFilter<"Attachment"> | string
    location?: StringWithAggregatesFilter<"Attachment"> | string
    name?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    ossType?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    userId?: IntWithAggregatesFilter<"Attachment"> | number
    status?: IntWithAggregatesFilter<"Attachment"> | number
    desc?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Attachment"> | Date | string | null
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: IntFilter<"Course"> | number
    title?: StringFilter<"Course"> | string
    subTitle?: StringNullableFilter<"Course"> | string | null
    desc?: StringNullableFilter<"Course"> | string | null
    coverId?: IntNullableFilter<"Course"> | number | null
    authorId?: IntFilter<"Course"> | number
    originPrice?: FloatNullableFilter<"Course"> | number | null
    price?: FloatNullableFilter<"Course"> | number | null
    status?: IntFilter<"Course"> | number
    counts?: IntFilter<"Course"> | number
    order?: IntFilter<"Course"> | number
    detail?: StringNullableFilter<"Course"> | string | null
    type?: StringNullableFilter<"Course"> | string | null
    Cover?: XOR<AttachmentNullableRelationFilter, AttachmentWhereInput> | null
    Author?: XOR<UserRelationFilter, UserWhereInput>
    Contents?: CourseContentListRelationFilter
    Tags?: CourseTagListRelationFilter
    CourseComment?: CourseCommentListRelationFilter
    Transaction?: TransactionListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    subTitle?: SortOrderInput | SortOrder
    desc?: SortOrderInput | SortOrder
    coverId?: SortOrderInput | SortOrder
    authorId?: SortOrder
    originPrice?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    status?: SortOrder
    counts?: SortOrder
    order?: SortOrder
    detail?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    Cover?: AttachmentOrderByWithRelationInput
    Author?: UserOrderByWithRelationInput
    Contents?: CourseContentOrderByRelationAggregateInput
    Tags?: CourseTagOrderByRelationAggregateInput
    CourseComment?: CourseCommentOrderByRelationAggregateInput
    Transaction?: TransactionOrderByRelationAggregateInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    title?: StringFilter<"Course"> | string
    subTitle?: StringNullableFilter<"Course"> | string | null
    desc?: StringNullableFilter<"Course"> | string | null
    coverId?: IntNullableFilter<"Course"> | number | null
    authorId?: IntFilter<"Course"> | number
    originPrice?: FloatNullableFilter<"Course"> | number | null
    price?: FloatNullableFilter<"Course"> | number | null
    status?: IntFilter<"Course"> | number
    counts?: IntFilter<"Course"> | number
    order?: IntFilter<"Course"> | number
    detail?: StringNullableFilter<"Course"> | string | null
    type?: StringNullableFilter<"Course"> | string | null
    Cover?: XOR<AttachmentNullableRelationFilter, AttachmentWhereInput> | null
    Author?: XOR<UserRelationFilter, UserWhereInput>
    Contents?: CourseContentListRelationFilter
    Tags?: CourseTagListRelationFilter
    CourseComment?: CourseCommentListRelationFilter
    Transaction?: TransactionListRelationFilter
  }, "id">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    subTitle?: SortOrderInput | SortOrder
    desc?: SortOrderInput | SortOrder
    coverId?: SortOrderInput | SortOrder
    authorId?: SortOrder
    originPrice?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    status?: SortOrder
    counts?: SortOrder
    order?: SortOrder
    detail?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Course"> | number
    title?: StringWithAggregatesFilter<"Course"> | string
    subTitle?: StringNullableWithAggregatesFilter<"Course"> | string | null
    desc?: StringNullableWithAggregatesFilter<"Course"> | string | null
    coverId?: IntNullableWithAggregatesFilter<"Course"> | number | null
    authorId?: IntWithAggregatesFilter<"Course"> | number
    originPrice?: FloatNullableWithAggregatesFilter<"Course"> | number | null
    price?: FloatNullableWithAggregatesFilter<"Course"> | number | null
    status?: IntWithAggregatesFilter<"Course"> | number
    counts?: IntWithAggregatesFilter<"Course"> | number
    order?: IntWithAggregatesFilter<"Course"> | number
    detail?: StringNullableWithAggregatesFilter<"Course"> | string | null
    type?: StringNullableWithAggregatesFilter<"Course"> | string | null
  }

  export type CourseContentWhereInput = {
    AND?: CourseContentWhereInput | CourseContentWhereInput[]
    OR?: CourseContentWhereInput[]
    NOT?: CourseContentWhereInput | CourseContentWhereInput[]
    id?: IntFilter<"CourseContent"> | number
    courseId?: IntFilter<"CourseContent"> | number
    title?: StringFilter<"CourseContent"> | string
    type?: StringNullableFilter<"CourseContent"> | string | null
    order?: IntFilter<"CourseContent"> | number
    pid?: IntNullableFilter<"CourseContent"> | number | null
    status?: IntFilter<"CourseContent"> | number
    authorId?: IntFilter<"CourseContent"> | number
    Course?: XOR<CourseRelationFilter, CourseWhereInput>
    Author?: XOR<UserRelationFilter, UserWhereInput>
    Attachments?: ContentAttachmentListRelationFilter
    Tags?: ContentTagListRelationFilter
    ContentComment?: ContentCommentListRelationFilter
  }

  export type CourseContentOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    type?: SortOrderInput | SortOrder
    order?: SortOrder
    pid?: SortOrderInput | SortOrder
    status?: SortOrder
    authorId?: SortOrder
    Course?: CourseOrderByWithRelationInput
    Author?: UserOrderByWithRelationInput
    Attachments?: ContentAttachmentOrderByRelationAggregateInput
    Tags?: ContentTagOrderByRelationAggregateInput
    ContentComment?: ContentCommentOrderByRelationAggregateInput
  }

  export type CourseContentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CourseContentWhereInput | CourseContentWhereInput[]
    OR?: CourseContentWhereInput[]
    NOT?: CourseContentWhereInput | CourseContentWhereInput[]
    courseId?: IntFilter<"CourseContent"> | number
    title?: StringFilter<"CourseContent"> | string
    type?: StringNullableFilter<"CourseContent"> | string | null
    order?: IntFilter<"CourseContent"> | number
    pid?: IntNullableFilter<"CourseContent"> | number | null
    status?: IntFilter<"CourseContent"> | number
    authorId?: IntFilter<"CourseContent"> | number
    Course?: XOR<CourseRelationFilter, CourseWhereInput>
    Author?: XOR<UserRelationFilter, UserWhereInput>
    Attachments?: ContentAttachmentListRelationFilter
    Tags?: ContentTagListRelationFilter
    ContentComment?: ContentCommentListRelationFilter
  }, "id">

  export type CourseContentOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    type?: SortOrderInput | SortOrder
    order?: SortOrder
    pid?: SortOrderInput | SortOrder
    status?: SortOrder
    authorId?: SortOrder
    _count?: CourseContentCountOrderByAggregateInput
    _avg?: CourseContentAvgOrderByAggregateInput
    _max?: CourseContentMaxOrderByAggregateInput
    _min?: CourseContentMinOrderByAggregateInput
    _sum?: CourseContentSumOrderByAggregateInput
  }

  export type CourseContentScalarWhereWithAggregatesInput = {
    AND?: CourseContentScalarWhereWithAggregatesInput | CourseContentScalarWhereWithAggregatesInput[]
    OR?: CourseContentScalarWhereWithAggregatesInput[]
    NOT?: CourseContentScalarWhereWithAggregatesInput | CourseContentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CourseContent"> | number
    courseId?: IntWithAggregatesFilter<"CourseContent"> | number
    title?: StringWithAggregatesFilter<"CourseContent"> | string
    type?: StringNullableWithAggregatesFilter<"CourseContent"> | string | null
    order?: IntWithAggregatesFilter<"CourseContent"> | number
    pid?: IntNullableWithAggregatesFilter<"CourseContent"> | number | null
    status?: IntWithAggregatesFilter<"CourseContent"> | number
    authorId?: IntWithAggregatesFilter<"CourseContent"> | number
  }

  export type ContentAttachmentWhereInput = {
    AND?: ContentAttachmentWhereInput | ContentAttachmentWhereInput[]
    OR?: ContentAttachmentWhereInput[]
    NOT?: ContentAttachmentWhereInput | ContentAttachmentWhereInput[]
    contentId?: IntFilter<"ContentAttachment"> | number
    attachmentId?: IntFilter<"ContentAttachment"> | number
    Content?: XOR<CourseContentRelationFilter, CourseContentWhereInput>
    Attachment?: XOR<AttachmentRelationFilter, AttachmentWhereInput>
  }

  export type ContentAttachmentOrderByWithRelationInput = {
    contentId?: SortOrder
    attachmentId?: SortOrder
    Content?: CourseContentOrderByWithRelationInput
    Attachment?: AttachmentOrderByWithRelationInput
  }

  export type ContentAttachmentWhereUniqueInput = Prisma.AtLeast<{
    contentId_attachmentId?: ContentAttachmentContentIdAttachmentIdCompoundUniqueInput
    AND?: ContentAttachmentWhereInput | ContentAttachmentWhereInput[]
    OR?: ContentAttachmentWhereInput[]
    NOT?: ContentAttachmentWhereInput | ContentAttachmentWhereInput[]
    contentId?: IntFilter<"ContentAttachment"> | number
    attachmentId?: IntFilter<"ContentAttachment"> | number
    Content?: XOR<CourseContentRelationFilter, CourseContentWhereInput>
    Attachment?: XOR<AttachmentRelationFilter, AttachmentWhereInput>
  }, "contentId_attachmentId">

  export type ContentAttachmentOrderByWithAggregationInput = {
    contentId?: SortOrder
    attachmentId?: SortOrder
    _count?: ContentAttachmentCountOrderByAggregateInput
    _avg?: ContentAttachmentAvgOrderByAggregateInput
    _max?: ContentAttachmentMaxOrderByAggregateInput
    _min?: ContentAttachmentMinOrderByAggregateInput
    _sum?: ContentAttachmentSumOrderByAggregateInput
  }

  export type ContentAttachmentScalarWhereWithAggregatesInput = {
    AND?: ContentAttachmentScalarWhereWithAggregatesInput | ContentAttachmentScalarWhereWithAggregatesInput[]
    OR?: ContentAttachmentScalarWhereWithAggregatesInput[]
    NOT?: ContentAttachmentScalarWhereWithAggregatesInput | ContentAttachmentScalarWhereWithAggregatesInput[]
    contentId?: IntWithAggregatesFilter<"ContentAttachment"> | number
    attachmentId?: IntWithAggregatesFilter<"ContentAttachment"> | number
  }

  export type DictCourseTagWhereInput = {
    AND?: DictCourseTagWhereInput | DictCourseTagWhereInput[]
    OR?: DictCourseTagWhereInput[]
    NOT?: DictCourseTagWhereInput | DictCourseTagWhereInput[]
    id?: IntFilter<"DictCourseTag"> | number
    name?: StringFilter<"DictCourseTag"> | string
    typeId?: IntNullableFilter<"DictCourseTag"> | number | null
    order?: IntFilter<"DictCourseTag"> | number
    status?: IntFilter<"DictCourseTag"> | number
    CourseType?: XOR<DictCourseTypeNullableRelationFilter, DictCourseTypeWhereInput> | null
    CourseTag?: CourseTagListRelationFilter
    ContentTag?: ContentTagListRelationFilter
  }

  export type DictCourseTagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    typeId?: SortOrderInput | SortOrder
    order?: SortOrder
    status?: SortOrder
    CourseType?: DictCourseTypeOrderByWithRelationInput
    CourseTag?: CourseTagOrderByRelationAggregateInput
    ContentTag?: ContentTagOrderByRelationAggregateInput
  }

  export type DictCourseTagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name_typeId?: DictCourseTagNameTypeIdCompoundUniqueInput
    AND?: DictCourseTagWhereInput | DictCourseTagWhereInput[]
    OR?: DictCourseTagWhereInput[]
    NOT?: DictCourseTagWhereInput | DictCourseTagWhereInput[]
    name?: StringFilter<"DictCourseTag"> | string
    typeId?: IntNullableFilter<"DictCourseTag"> | number | null
    order?: IntFilter<"DictCourseTag"> | number
    status?: IntFilter<"DictCourseTag"> | number
    CourseType?: XOR<DictCourseTypeNullableRelationFilter, DictCourseTypeWhereInput> | null
    CourseTag?: CourseTagListRelationFilter
    ContentTag?: ContentTagListRelationFilter
  }, "id" | "name_typeId">

  export type DictCourseTagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    typeId?: SortOrderInput | SortOrder
    order?: SortOrder
    status?: SortOrder
    _count?: DictCourseTagCountOrderByAggregateInput
    _avg?: DictCourseTagAvgOrderByAggregateInput
    _max?: DictCourseTagMaxOrderByAggregateInput
    _min?: DictCourseTagMinOrderByAggregateInput
    _sum?: DictCourseTagSumOrderByAggregateInput
  }

  export type DictCourseTagScalarWhereWithAggregatesInput = {
    AND?: DictCourseTagScalarWhereWithAggregatesInput | DictCourseTagScalarWhereWithAggregatesInput[]
    OR?: DictCourseTagScalarWhereWithAggregatesInput[]
    NOT?: DictCourseTagScalarWhereWithAggregatesInput | DictCourseTagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DictCourseTag"> | number
    name?: StringWithAggregatesFilter<"DictCourseTag"> | string
    typeId?: IntNullableWithAggregatesFilter<"DictCourseTag"> | number | null
    order?: IntWithAggregatesFilter<"DictCourseTag"> | number
    status?: IntWithAggregatesFilter<"DictCourseTag"> | number
  }

  export type DictCourseTypeWhereInput = {
    AND?: DictCourseTypeWhereInput | DictCourseTypeWhereInput[]
    OR?: DictCourseTypeWhereInput[]
    NOT?: DictCourseTypeWhereInput | DictCourseTypeWhereInput[]
    id?: IntFilter<"DictCourseType"> | number
    name?: StringFilter<"DictCourseType"> | string
    order?: IntFilter<"DictCourseType"> | number
    status?: IntFilter<"DictCourseType"> | number
    CourseTags?: DictCourseTagListRelationFilter
  }

  export type DictCourseTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    status?: SortOrder
    CourseTags?: DictCourseTagOrderByRelationAggregateInput
  }

  export type DictCourseTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: DictCourseTypeWhereInput | DictCourseTypeWhereInput[]
    OR?: DictCourseTypeWhereInput[]
    NOT?: DictCourseTypeWhereInput | DictCourseTypeWhereInput[]
    order?: IntFilter<"DictCourseType"> | number
    status?: IntFilter<"DictCourseType"> | number
    CourseTags?: DictCourseTagListRelationFilter
  }, "id" | "name">

  export type DictCourseTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    status?: SortOrder
    _count?: DictCourseTypeCountOrderByAggregateInput
    _avg?: DictCourseTypeAvgOrderByAggregateInput
    _max?: DictCourseTypeMaxOrderByAggregateInput
    _min?: DictCourseTypeMinOrderByAggregateInput
    _sum?: DictCourseTypeSumOrderByAggregateInput
  }

  export type DictCourseTypeScalarWhereWithAggregatesInput = {
    AND?: DictCourseTypeScalarWhereWithAggregatesInput | DictCourseTypeScalarWhereWithAggregatesInput[]
    OR?: DictCourseTypeScalarWhereWithAggregatesInput[]
    NOT?: DictCourseTypeScalarWhereWithAggregatesInput | DictCourseTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DictCourseType"> | number
    name?: StringWithAggregatesFilter<"DictCourseType"> | string
    order?: IntWithAggregatesFilter<"DictCourseType"> | number
    status?: IntWithAggregatesFilter<"DictCourseType"> | number
  }

  export type CourseTagWhereInput = {
    AND?: CourseTagWhereInput | CourseTagWhereInput[]
    OR?: CourseTagWhereInput[]
    NOT?: CourseTagWhereInput | CourseTagWhereInput[]
    courseId?: IntFilter<"CourseTag"> | number
    tagId?: IntFilter<"CourseTag"> | number
    Course?: XOR<CourseRelationFilter, CourseWhereInput>
    Tag?: XOR<DictCourseTagRelationFilter, DictCourseTagWhereInput>
  }

  export type CourseTagOrderByWithRelationInput = {
    courseId?: SortOrder
    tagId?: SortOrder
    Course?: CourseOrderByWithRelationInput
    Tag?: DictCourseTagOrderByWithRelationInput
  }

  export type CourseTagWhereUniqueInput = Prisma.AtLeast<{
    courseId_tagId?: CourseTagCourseIdTagIdCompoundUniqueInput
    AND?: CourseTagWhereInput | CourseTagWhereInput[]
    OR?: CourseTagWhereInput[]
    NOT?: CourseTagWhereInput | CourseTagWhereInput[]
    courseId?: IntFilter<"CourseTag"> | number
    tagId?: IntFilter<"CourseTag"> | number
    Course?: XOR<CourseRelationFilter, CourseWhereInput>
    Tag?: XOR<DictCourseTagRelationFilter, DictCourseTagWhereInput>
  }, "courseId_tagId">

  export type CourseTagOrderByWithAggregationInput = {
    courseId?: SortOrder
    tagId?: SortOrder
    _count?: CourseTagCountOrderByAggregateInput
    _avg?: CourseTagAvgOrderByAggregateInput
    _max?: CourseTagMaxOrderByAggregateInput
    _min?: CourseTagMinOrderByAggregateInput
    _sum?: CourseTagSumOrderByAggregateInput
  }

  export type CourseTagScalarWhereWithAggregatesInput = {
    AND?: CourseTagScalarWhereWithAggregatesInput | CourseTagScalarWhereWithAggregatesInput[]
    OR?: CourseTagScalarWhereWithAggregatesInput[]
    NOT?: CourseTagScalarWhereWithAggregatesInput | CourseTagScalarWhereWithAggregatesInput[]
    courseId?: IntWithAggregatesFilter<"CourseTag"> | number
    tagId?: IntWithAggregatesFilter<"CourseTag"> | number
  }

  export type ContentTagWhereInput = {
    AND?: ContentTagWhereInput | ContentTagWhereInput[]
    OR?: ContentTagWhereInput[]
    NOT?: ContentTagWhereInput | ContentTagWhereInput[]
    contentId?: IntFilter<"ContentTag"> | number
    tagId?: IntFilter<"ContentTag"> | number
    Content?: XOR<CourseContentRelationFilter, CourseContentWhereInput>
    Tag?: XOR<DictCourseTagRelationFilter, DictCourseTagWhereInput>
  }

  export type ContentTagOrderByWithRelationInput = {
    contentId?: SortOrder
    tagId?: SortOrder
    Content?: CourseContentOrderByWithRelationInput
    Tag?: DictCourseTagOrderByWithRelationInput
  }

  export type ContentTagWhereUniqueInput = Prisma.AtLeast<{
    contentId_tagId?: ContentTagContentIdTagIdCompoundUniqueInput
    AND?: ContentTagWhereInput | ContentTagWhereInput[]
    OR?: ContentTagWhereInput[]
    NOT?: ContentTagWhereInput | ContentTagWhereInput[]
    contentId?: IntFilter<"ContentTag"> | number
    tagId?: IntFilter<"ContentTag"> | number
    Content?: XOR<CourseContentRelationFilter, CourseContentWhereInput>
    Tag?: XOR<DictCourseTagRelationFilter, DictCourseTagWhereInput>
  }, "contentId_tagId">

  export type ContentTagOrderByWithAggregationInput = {
    contentId?: SortOrder
    tagId?: SortOrder
    _count?: ContentTagCountOrderByAggregateInput
    _avg?: ContentTagAvgOrderByAggregateInput
    _max?: ContentTagMaxOrderByAggregateInput
    _min?: ContentTagMinOrderByAggregateInput
    _sum?: ContentTagSumOrderByAggregateInput
  }

  export type ContentTagScalarWhereWithAggregatesInput = {
    AND?: ContentTagScalarWhereWithAggregatesInput | ContentTagScalarWhereWithAggregatesInput[]
    OR?: ContentTagScalarWhereWithAggregatesInput[]
    NOT?: ContentTagScalarWhereWithAggregatesInput | ContentTagScalarWhereWithAggregatesInput[]
    contentId?: IntWithAggregatesFilter<"ContentTag"> | number
    tagId?: IntWithAggregatesFilter<"ContentTag"> | number
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: IntFilter<"Comment"> | number
    pid?: IntNullableFilter<"Comment"> | number | null
    userId?: IntFilter<"Comment"> | number
    created?: DateTimeFilter<"Comment"> | Date | string
    hands?: BigIntFilter<"Comment"> | bigint | number
    status?: IntFilter<"Comment"> | number
    isBest?: IntFilter<"Comment"> | number
    User?: XOR<UserRelationFilter, UserWhereInput>
    parent?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
    children?: CommentListRelationFilter
    CourseComment?: CourseCommentListRelationFilter
    ContentComment?: ContentCommentListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    pid?: SortOrderInput | SortOrder
    userId?: SortOrder
    created?: SortOrder
    hands?: SortOrder
    status?: SortOrder
    isBest?: SortOrder
    User?: UserOrderByWithRelationInput
    parent?: CommentOrderByWithRelationInput
    children?: CommentOrderByRelationAggregateInput
    CourseComment?: CourseCommentOrderByRelationAggregateInput
    ContentComment?: ContentCommentOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    pid?: IntNullableFilter<"Comment"> | number | null
    userId?: IntFilter<"Comment"> | number
    created?: DateTimeFilter<"Comment"> | Date | string
    hands?: BigIntFilter<"Comment"> | bigint | number
    status?: IntFilter<"Comment"> | number
    isBest?: IntFilter<"Comment"> | number
    User?: XOR<UserRelationFilter, UserWhereInput>
    parent?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
    children?: CommentListRelationFilter
    CourseComment?: CourseCommentListRelationFilter
    ContentComment?: ContentCommentListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    pid?: SortOrderInput | SortOrder
    userId?: SortOrder
    created?: SortOrder
    hands?: SortOrder
    status?: SortOrder
    isBest?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comment"> | number
    pid?: IntNullableWithAggregatesFilter<"Comment"> | number | null
    userId?: IntWithAggregatesFilter<"Comment"> | number
    created?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    hands?: BigIntWithAggregatesFilter<"Comment"> | bigint | number
    status?: IntWithAggregatesFilter<"Comment"> | number
    isBest?: IntWithAggregatesFilter<"Comment"> | number
  }

  export type CourseCommentWhereInput = {
    AND?: CourseCommentWhereInput | CourseCommentWhereInput[]
    OR?: CourseCommentWhereInput[]
    NOT?: CourseCommentWhereInput | CourseCommentWhereInput[]
    courseId?: IntFilter<"CourseComment"> | number
    commentId?: IntFilter<"CourseComment"> | number
    Course?: XOR<CourseRelationFilter, CourseWhereInput>
    Comment?: XOR<CommentRelationFilter, CommentWhereInput>
  }

  export type CourseCommentOrderByWithRelationInput = {
    courseId?: SortOrder
    commentId?: SortOrder
    Course?: CourseOrderByWithRelationInput
    Comment?: CommentOrderByWithRelationInput
  }

  export type CourseCommentWhereUniqueInput = Prisma.AtLeast<{
    courseId_commentId?: CourseCommentCourseIdCommentIdCompoundUniqueInput
    AND?: CourseCommentWhereInput | CourseCommentWhereInput[]
    OR?: CourseCommentWhereInput[]
    NOT?: CourseCommentWhereInput | CourseCommentWhereInput[]
    courseId?: IntFilter<"CourseComment"> | number
    commentId?: IntFilter<"CourseComment"> | number
    Course?: XOR<CourseRelationFilter, CourseWhereInput>
    Comment?: XOR<CommentRelationFilter, CommentWhereInput>
  }, "courseId_commentId">

  export type CourseCommentOrderByWithAggregationInput = {
    courseId?: SortOrder
    commentId?: SortOrder
    _count?: CourseCommentCountOrderByAggregateInput
    _avg?: CourseCommentAvgOrderByAggregateInput
    _max?: CourseCommentMaxOrderByAggregateInput
    _min?: CourseCommentMinOrderByAggregateInput
    _sum?: CourseCommentSumOrderByAggregateInput
  }

  export type CourseCommentScalarWhereWithAggregatesInput = {
    AND?: CourseCommentScalarWhereWithAggregatesInput | CourseCommentScalarWhereWithAggregatesInput[]
    OR?: CourseCommentScalarWhereWithAggregatesInput[]
    NOT?: CourseCommentScalarWhereWithAggregatesInput | CourseCommentScalarWhereWithAggregatesInput[]
    courseId?: IntWithAggregatesFilter<"CourseComment"> | number
    commentId?: IntWithAggregatesFilter<"CourseComment"> | number
  }

  export type ContentCommentWhereInput = {
    AND?: ContentCommentWhereInput | ContentCommentWhereInput[]
    OR?: ContentCommentWhereInput[]
    NOT?: ContentCommentWhereInput | ContentCommentWhereInput[]
    contentId?: IntFilter<"ContentComment"> | number
    commentId?: IntFilter<"ContentComment"> | number
    Content?: XOR<CourseContentRelationFilter, CourseContentWhereInput>
    Comment?: XOR<CommentRelationFilter, CommentWhereInput>
  }

  export type ContentCommentOrderByWithRelationInput = {
    contentId?: SortOrder
    commentId?: SortOrder
    Content?: CourseContentOrderByWithRelationInput
    Comment?: CommentOrderByWithRelationInput
  }

  export type ContentCommentWhereUniqueInput = Prisma.AtLeast<{
    commentId_contentId?: ContentCommentCommentIdContentIdCompoundUniqueInput
    AND?: ContentCommentWhereInput | ContentCommentWhereInput[]
    OR?: ContentCommentWhereInput[]
    NOT?: ContentCommentWhereInput | ContentCommentWhereInput[]
    contentId?: IntFilter<"ContentComment"> | number
    commentId?: IntFilter<"ContentComment"> | number
    Content?: XOR<CourseContentRelationFilter, CourseContentWhereInput>
    Comment?: XOR<CommentRelationFilter, CommentWhereInput>
  }, "commentId_contentId">

  export type ContentCommentOrderByWithAggregationInput = {
    contentId?: SortOrder
    commentId?: SortOrder
    _count?: ContentCommentCountOrderByAggregateInput
    _avg?: ContentCommentAvgOrderByAggregateInput
    _max?: ContentCommentMaxOrderByAggregateInput
    _min?: ContentCommentMinOrderByAggregateInput
    _sum?: ContentCommentSumOrderByAggregateInput
  }

  export type ContentCommentScalarWhereWithAggregatesInput = {
    AND?: ContentCommentScalarWhereWithAggregatesInput | ContentCommentScalarWhereWithAggregatesInput[]
    OR?: ContentCommentScalarWhereWithAggregatesInput[]
    NOT?: ContentCommentScalarWhereWithAggregatesInput | ContentCommentScalarWhereWithAggregatesInput[]
    contentId?: IntWithAggregatesFilter<"ContentComment"> | number
    commentId?: IntWithAggregatesFilter<"ContentComment"> | number
  }

  export type NoteWhereInput = {
    AND?: NoteWhereInput | NoteWhereInput[]
    OR?: NoteWhereInput[]
    NOT?: NoteWhereInput | NoteWhereInput[]
    id?: IntFilter<"Note"> | number
    userId?: IntFilter<"Note"> | number
    content?: StringFilter<"Note"> | string
    createAt?: DateTimeFilter<"Note"> | Date | string
    updateAt?: DateTimeNullableFilter<"Note"> | Date | string | null
    status?: IntNullableFilter<"Note"> | number | null
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NoteOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type NoteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NoteWhereInput | NoteWhereInput[]
    OR?: NoteWhereInput[]
    NOT?: NoteWhereInput | NoteWhereInput[]
    userId?: IntFilter<"Note"> | number
    content?: StringFilter<"Note"> | string
    createAt?: DateTimeFilter<"Note"> | Date | string
    updateAt?: DateTimeNullableFilter<"Note"> | Date | string | null
    status?: IntNullableFilter<"Note"> | number | null
    User?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NoteOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: NoteCountOrderByAggregateInput
    _avg?: NoteAvgOrderByAggregateInput
    _max?: NoteMaxOrderByAggregateInput
    _min?: NoteMinOrderByAggregateInput
    _sum?: NoteSumOrderByAggregateInput
  }

  export type NoteScalarWhereWithAggregatesInput = {
    AND?: NoteScalarWhereWithAggregatesInput | NoteScalarWhereWithAggregatesInput[]
    OR?: NoteScalarWhereWithAggregatesInput[]
    NOT?: NoteScalarWhereWithAggregatesInput | NoteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Note"> | number
    userId?: IntWithAggregatesFilter<"Note"> | number
    content?: StringWithAggregatesFilter<"Note"> | string
    createAt?: DateTimeWithAggregatesFilter<"Note"> | Date | string
    updateAt?: DateTimeNullableWithAggregatesFilter<"Note"> | Date | string | null
    status?: IntNullableWithAggregatesFilter<"Note"> | number | null
  }

  export type DictPlatformWhereInput = {
    AND?: DictPlatformWhereInput | DictPlatformWhereInput[]
    OR?: DictPlatformWhereInput[]
    NOT?: DictPlatformWhereInput | DictPlatformWhereInput[]
    id?: IntFilter<"DictPlatform"> | number
    name?: StringFilter<"DictPlatform"> | string
    url?: StringNullableFilter<"DictPlatform"> | string | null
    Transaction?: TransactionListRelationFilter
  }

  export type DictPlatformOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrderInput | SortOrder
    Transaction?: TransactionOrderByRelationAggregateInput
  }

  export type DictPlatformWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DictPlatformWhereInput | DictPlatformWhereInput[]
    OR?: DictPlatformWhereInput[]
    NOT?: DictPlatformWhereInput | DictPlatformWhereInput[]
    name?: StringFilter<"DictPlatform"> | string
    url?: StringNullableFilter<"DictPlatform"> | string | null
    Transaction?: TransactionListRelationFilter
  }, "id">

  export type DictPlatformOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrderInput | SortOrder
    _count?: DictPlatformCountOrderByAggregateInput
    _avg?: DictPlatformAvgOrderByAggregateInput
    _max?: DictPlatformMaxOrderByAggregateInput
    _min?: DictPlatformMinOrderByAggregateInput
    _sum?: DictPlatformSumOrderByAggregateInput
  }

  export type DictPlatformScalarWhereWithAggregatesInput = {
    AND?: DictPlatformScalarWhereWithAggregatesInput | DictPlatformScalarWhereWithAggregatesInput[]
    OR?: DictPlatformScalarWhereWithAggregatesInput[]
    NOT?: DictPlatformScalarWhereWithAggregatesInput | DictPlatformScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DictPlatform"> | number
    name?: StringWithAggregatesFilter<"DictPlatform"> | string
    url?: StringNullableWithAggregatesFilter<"DictPlatform"> | string | null
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: IntFilter<"Transaction"> | number
    courseId?: IntFilter<"Transaction"> | number
    userId?: IntFilter<"Transaction"> | number
    amount?: FloatFilter<"Transaction"> | number
    platformId?: IntFilter<"Transaction"> | number
    status?: IntFilter<"Transaction"> | number
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    Course?: XOR<CourseRelationFilter, CourseWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput>
    Platform?: XOR<DictPlatformRelationFilter, DictPlatformWhereInput>
    GroupTransaction?: GroupTransactionListRelationFilter
    BalanceRecord?: BalanceRecordListRelationFilter
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    platformId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    Course?: CourseOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    Platform?: DictPlatformOrderByWithRelationInput
    GroupTransaction?: GroupTransactionOrderByRelationAggregateInput
    BalanceRecord?: BalanceRecordOrderByRelationAggregateInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    courseId?: IntFilter<"Transaction"> | number
    userId?: IntFilter<"Transaction"> | number
    amount?: FloatFilter<"Transaction"> | number
    platformId?: IntFilter<"Transaction"> | number
    status?: IntFilter<"Transaction"> | number
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    Course?: XOR<CourseRelationFilter, CourseWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput>
    Platform?: XOR<DictPlatformRelationFilter, DictPlatformWhereInput>
    GroupTransaction?: GroupTransactionListRelationFilter
    BalanceRecord?: BalanceRecordListRelationFilter
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    platformId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Transaction"> | number
    courseId?: IntWithAggregatesFilter<"Transaction"> | number
    userId?: IntWithAggregatesFilter<"Transaction"> | number
    amount?: FloatWithAggregatesFilter<"Transaction"> | number
    platformId?: IntWithAggregatesFilter<"Transaction"> | number
    status?: IntWithAggregatesFilter<"Transaction"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
  }

  export type GroupTransactionWhereInput = {
    AND?: GroupTransactionWhereInput | GroupTransactionWhereInput[]
    OR?: GroupTransactionWhereInput[]
    NOT?: GroupTransactionWhereInput | GroupTransactionWhereInput[]
    id?: IntFilter<"GroupTransaction"> | number
    groupId?: StringFilter<"GroupTransaction"> | string
    transactionId?: IntFilter<"GroupTransaction"> | number
    Transaction?: XOR<TransactionRelationFilter, TransactionWhereInput>
  }

  export type GroupTransactionOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    transactionId?: SortOrder
    Transaction?: TransactionOrderByWithRelationInput
  }

  export type GroupTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GroupTransactionWhereInput | GroupTransactionWhereInput[]
    OR?: GroupTransactionWhereInput[]
    NOT?: GroupTransactionWhereInput | GroupTransactionWhereInput[]
    groupId?: StringFilter<"GroupTransaction"> | string
    transactionId?: IntFilter<"GroupTransaction"> | number
    Transaction?: XOR<TransactionRelationFilter, TransactionWhereInput>
  }, "id">

  export type GroupTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    transactionId?: SortOrder
    _count?: GroupTransactionCountOrderByAggregateInput
    _avg?: GroupTransactionAvgOrderByAggregateInput
    _max?: GroupTransactionMaxOrderByAggregateInput
    _min?: GroupTransactionMinOrderByAggregateInput
    _sum?: GroupTransactionSumOrderByAggregateInput
  }

  export type GroupTransactionScalarWhereWithAggregatesInput = {
    AND?: GroupTransactionScalarWhereWithAggregatesInput | GroupTransactionScalarWhereWithAggregatesInput[]
    OR?: GroupTransactionScalarWhereWithAggregatesInput[]
    NOT?: GroupTransactionScalarWhereWithAggregatesInput | GroupTransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GroupTransaction"> | number
    groupId?: StringWithAggregatesFilter<"GroupTransaction"> | string
    transactionId?: IntWithAggregatesFilter<"GroupTransaction"> | number
  }

  export type AuditFlowWhereInput = {
    AND?: AuditFlowWhereInput | AuditFlowWhereInput[]
    OR?: AuditFlowWhereInput[]
    NOT?: AuditFlowWhereInput | AuditFlowWhereInput[]
    id?: IntFilter<"AuditFlow"> | number
    name?: StringFilter<"AuditFlow"> | string
    description?: StringNullableFilter<"AuditFlow"> | string | null
    AuditStage?: AuditStageListRelationFilter
  }

  export type AuditFlowOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    AuditStage?: AuditStageOrderByRelationAggregateInput
  }

  export type AuditFlowWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditFlowWhereInput | AuditFlowWhereInput[]
    OR?: AuditFlowWhereInput[]
    NOT?: AuditFlowWhereInput | AuditFlowWhereInput[]
    name?: StringFilter<"AuditFlow"> | string
    description?: StringNullableFilter<"AuditFlow"> | string | null
    AuditStage?: AuditStageListRelationFilter
  }, "id">

  export type AuditFlowOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: AuditFlowCountOrderByAggregateInput
    _avg?: AuditFlowAvgOrderByAggregateInput
    _max?: AuditFlowMaxOrderByAggregateInput
    _min?: AuditFlowMinOrderByAggregateInput
    _sum?: AuditFlowSumOrderByAggregateInput
  }

  export type AuditFlowScalarWhereWithAggregatesInput = {
    AND?: AuditFlowScalarWhereWithAggregatesInput | AuditFlowScalarWhereWithAggregatesInput[]
    OR?: AuditFlowScalarWhereWithAggregatesInput[]
    NOT?: AuditFlowScalarWhereWithAggregatesInput | AuditFlowScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditFlow"> | number
    name?: StringWithAggregatesFilter<"AuditFlow"> | string
    description?: StringNullableWithAggregatesFilter<"AuditFlow"> | string | null
  }

  export type AuditStageWhereInput = {
    AND?: AuditStageWhereInput | AuditStageWhereInput[]
    OR?: AuditStageWhereInput[]
    NOT?: AuditStageWhereInput | AuditStageWhereInput[]
    id?: IntFilter<"AuditStage"> | number
    flowId?: IntFilter<"AuditStage"> | number
    name?: StringFilter<"AuditStage"> | string
    level?: IntFilter<"AuditStage"> | number
    pid?: IntNullableFilter<"AuditStage"> | number | null
    Flow?: XOR<AuditFlowRelationFilter, AuditFlowWhereInput>
    parent?: XOR<AuditStageNullableRelationFilter, AuditStageWhereInput> | null
    children?: AuditStageListRelationFilter
    AuditRecord?: AuditRecordListRelationFilter
  }

  export type AuditStageOrderByWithRelationInput = {
    id?: SortOrder
    flowId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    pid?: SortOrderInput | SortOrder
    Flow?: AuditFlowOrderByWithRelationInput
    parent?: AuditStageOrderByWithRelationInput
    children?: AuditStageOrderByRelationAggregateInput
    AuditRecord?: AuditRecordOrderByRelationAggregateInput
  }

  export type AuditStageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditStageWhereInput | AuditStageWhereInput[]
    OR?: AuditStageWhereInput[]
    NOT?: AuditStageWhereInput | AuditStageWhereInput[]
    flowId?: IntFilter<"AuditStage"> | number
    name?: StringFilter<"AuditStage"> | string
    level?: IntFilter<"AuditStage"> | number
    pid?: IntNullableFilter<"AuditStage"> | number | null
    Flow?: XOR<AuditFlowRelationFilter, AuditFlowWhereInput>
    parent?: XOR<AuditStageNullableRelationFilter, AuditStageWhereInput> | null
    children?: AuditStageListRelationFilter
    AuditRecord?: AuditRecordListRelationFilter
  }, "id">

  export type AuditStageOrderByWithAggregationInput = {
    id?: SortOrder
    flowId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    pid?: SortOrderInput | SortOrder
    _count?: AuditStageCountOrderByAggregateInput
    _avg?: AuditStageAvgOrderByAggregateInput
    _max?: AuditStageMaxOrderByAggregateInput
    _min?: AuditStageMinOrderByAggregateInput
    _sum?: AuditStageSumOrderByAggregateInput
  }

  export type AuditStageScalarWhereWithAggregatesInput = {
    AND?: AuditStageScalarWhereWithAggregatesInput | AuditStageScalarWhereWithAggregatesInput[]
    OR?: AuditStageScalarWhereWithAggregatesInput[]
    NOT?: AuditStageScalarWhereWithAggregatesInput | AuditStageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditStage"> | number
    flowId?: IntWithAggregatesFilter<"AuditStage"> | number
    name?: StringWithAggregatesFilter<"AuditStage"> | string
    level?: IntWithAggregatesFilter<"AuditStage"> | number
    pid?: IntNullableWithAggregatesFilter<"AuditStage"> | number | null
  }

  export type AuditRecordWhereInput = {
    AND?: AuditRecordWhereInput | AuditRecordWhereInput[]
    OR?: AuditRecordWhereInput[]
    NOT?: AuditRecordWhereInput | AuditRecordWhereInput[]
    id?: IntFilter<"AuditRecord"> | number
    entityId?: IntFilter<"AuditRecord"> | number
    entityType?: StringFilter<"AuditRecord"> | string
    stageId?: IntFilter<"AuditRecord"> | number
    status?: StringNullableFilter<"AuditRecord"> | string | null
    reviewerId?: IntFilter<"AuditRecord"> | number
    createdAt?: DateTimeFilter<"AuditRecord"> | Date | string
    notes?: StringNullableFilter<"AuditRecord"> | string | null
    Stage?: XOR<AuditStageRelationFilter, AuditStageWhereInput>
    Reviewer?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AuditRecordOrderByWithRelationInput = {
    id?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    stageId?: SortOrder
    status?: SortOrderInput | SortOrder
    reviewerId?: SortOrder
    createdAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    Stage?: AuditStageOrderByWithRelationInput
    Reviewer?: UserOrderByWithRelationInput
  }

  export type AuditRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditRecordWhereInput | AuditRecordWhereInput[]
    OR?: AuditRecordWhereInput[]
    NOT?: AuditRecordWhereInput | AuditRecordWhereInput[]
    entityId?: IntFilter<"AuditRecord"> | number
    entityType?: StringFilter<"AuditRecord"> | string
    stageId?: IntFilter<"AuditRecord"> | number
    status?: StringNullableFilter<"AuditRecord"> | string | null
    reviewerId?: IntFilter<"AuditRecord"> | number
    createdAt?: DateTimeFilter<"AuditRecord"> | Date | string
    notes?: StringNullableFilter<"AuditRecord"> | string | null
    Stage?: XOR<AuditStageRelationFilter, AuditStageWhereInput>
    Reviewer?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AuditRecordOrderByWithAggregationInput = {
    id?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    stageId?: SortOrder
    status?: SortOrderInput | SortOrder
    reviewerId?: SortOrder
    createdAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: AuditRecordCountOrderByAggregateInput
    _avg?: AuditRecordAvgOrderByAggregateInput
    _max?: AuditRecordMaxOrderByAggregateInput
    _min?: AuditRecordMinOrderByAggregateInput
    _sum?: AuditRecordSumOrderByAggregateInput
  }

  export type AuditRecordScalarWhereWithAggregatesInput = {
    AND?: AuditRecordScalarWhereWithAggregatesInput | AuditRecordScalarWhereWithAggregatesInput[]
    OR?: AuditRecordScalarWhereWithAggregatesInput[]
    NOT?: AuditRecordScalarWhereWithAggregatesInput | AuditRecordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditRecord"> | number
    entityId?: IntWithAggregatesFilter<"AuditRecord"> | number
    entityType?: StringWithAggregatesFilter<"AuditRecord"> | string
    stageId?: IntWithAggregatesFilter<"AuditRecord"> | number
    status?: StringNullableWithAggregatesFilter<"AuditRecord"> | string | null
    reviewerId?: IntWithAggregatesFilter<"AuditRecord"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AuditRecord"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"AuditRecord"> | string | null
  }

  export type DictCouponTypeWhereInput = {
    AND?: DictCouponTypeWhereInput | DictCouponTypeWhereInput[]
    OR?: DictCouponTypeWhereInput[]
    NOT?: DictCouponTypeWhereInput | DictCouponTypeWhereInput[]
    id?: IntFilter<"DictCouponType"> | number
    name?: StringFilter<"DictCouponType"> | string
    desc?: StringNullableFilter<"DictCouponType"> | string | null
    Coupon?: CouponListRelationFilter
  }

  export type DictCouponTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    desc?: SortOrderInput | SortOrder
    Coupon?: CouponOrderByRelationAggregateInput
  }

  export type DictCouponTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DictCouponTypeWhereInput | DictCouponTypeWhereInput[]
    OR?: DictCouponTypeWhereInput[]
    NOT?: DictCouponTypeWhereInput | DictCouponTypeWhereInput[]
    name?: StringFilter<"DictCouponType"> | string
    desc?: StringNullableFilter<"DictCouponType"> | string | null
    Coupon?: CouponListRelationFilter
  }, "id">

  export type DictCouponTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    desc?: SortOrderInput | SortOrder
    _count?: DictCouponTypeCountOrderByAggregateInput
    _avg?: DictCouponTypeAvgOrderByAggregateInput
    _max?: DictCouponTypeMaxOrderByAggregateInput
    _min?: DictCouponTypeMinOrderByAggregateInput
    _sum?: DictCouponTypeSumOrderByAggregateInput
  }

  export type DictCouponTypeScalarWhereWithAggregatesInput = {
    AND?: DictCouponTypeScalarWhereWithAggregatesInput | DictCouponTypeScalarWhereWithAggregatesInput[]
    OR?: DictCouponTypeScalarWhereWithAggregatesInput[]
    NOT?: DictCouponTypeScalarWhereWithAggregatesInput | DictCouponTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DictCouponType"> | number
    name?: StringWithAggregatesFilter<"DictCouponType"> | string
    desc?: StringNullableWithAggregatesFilter<"DictCouponType"> | string | null
  }

  export type CouponWhereInput = {
    AND?: CouponWhereInput | CouponWhereInput[]
    OR?: CouponWhereInput[]
    NOT?: CouponWhereInput | CouponWhereInput[]
    id?: IntFilter<"Coupon"> | number
    productId?: IntNullableFilter<"Coupon"> | number | null
    typeId?: IntFilter<"Coupon"> | number
    threshold?: FloatNullableFilter<"Coupon"> | number | null
    discount?: FloatFilter<"Coupon"> | number
    validUntil?: DateTimeFilter<"Coupon"> | Date | string
    universal?: BoolFilter<"Coupon"> | boolean
    CouponType?: XOR<DictCouponTypeRelationFilter, DictCouponTypeWhereInput>
  }

  export type CouponOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrderInput | SortOrder
    typeId?: SortOrder
    threshold?: SortOrderInput | SortOrder
    discount?: SortOrder
    validUntil?: SortOrder
    universal?: SortOrder
    CouponType?: DictCouponTypeOrderByWithRelationInput
  }

  export type CouponWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CouponWhereInput | CouponWhereInput[]
    OR?: CouponWhereInput[]
    NOT?: CouponWhereInput | CouponWhereInput[]
    productId?: IntNullableFilter<"Coupon"> | number | null
    typeId?: IntFilter<"Coupon"> | number
    threshold?: FloatNullableFilter<"Coupon"> | number | null
    discount?: FloatFilter<"Coupon"> | number
    validUntil?: DateTimeFilter<"Coupon"> | Date | string
    universal?: BoolFilter<"Coupon"> | boolean
    CouponType?: XOR<DictCouponTypeRelationFilter, DictCouponTypeWhereInput>
  }, "id">

  export type CouponOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrderInput | SortOrder
    typeId?: SortOrder
    threshold?: SortOrderInput | SortOrder
    discount?: SortOrder
    validUntil?: SortOrder
    universal?: SortOrder
    _count?: CouponCountOrderByAggregateInput
    _avg?: CouponAvgOrderByAggregateInput
    _max?: CouponMaxOrderByAggregateInput
    _min?: CouponMinOrderByAggregateInput
    _sum?: CouponSumOrderByAggregateInput
  }

  export type CouponScalarWhereWithAggregatesInput = {
    AND?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[]
    OR?: CouponScalarWhereWithAggregatesInput[]
    NOT?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Coupon"> | number
    productId?: IntNullableWithAggregatesFilter<"Coupon"> | number | null
    typeId?: IntWithAggregatesFilter<"Coupon"> | number
    threshold?: FloatNullableWithAggregatesFilter<"Coupon"> | number | null
    discount?: FloatWithAggregatesFilter<"Coupon"> | number
    validUntil?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
    universal?: BoolWithAggregatesFilter<"Coupon"> | boolean
  }

  export type BalanceRecordWhereInput = {
    AND?: BalanceRecordWhereInput | BalanceRecordWhereInput[]
    OR?: BalanceRecordWhereInput[]
    NOT?: BalanceRecordWhereInput | BalanceRecordWhereInput[]
    id?: IntFilter<"BalanceRecord"> | number
    userId?: IntFilter<"BalanceRecord"> | number
    transactionId?: IntNullableFilter<"BalanceRecord"> | number | null
    amount?: FloatFilter<"BalanceRecord"> | number
    type?: IntFilter<"BalanceRecord"> | number
    createdAt?: DateTimeFilter<"BalanceRecord"> | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    Transaction?: XOR<TransactionNullableRelationFilter, TransactionWhereInput> | null
  }

  export type BalanceRecordOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    amount?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    User?: UserOrderByWithRelationInput
    Transaction?: TransactionOrderByWithRelationInput
  }

  export type BalanceRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BalanceRecordWhereInput | BalanceRecordWhereInput[]
    OR?: BalanceRecordWhereInput[]
    NOT?: BalanceRecordWhereInput | BalanceRecordWhereInput[]
    userId?: IntFilter<"BalanceRecord"> | number
    transactionId?: IntNullableFilter<"BalanceRecord"> | number | null
    amount?: FloatFilter<"BalanceRecord"> | number
    type?: IntFilter<"BalanceRecord"> | number
    createdAt?: DateTimeFilter<"BalanceRecord"> | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    Transaction?: XOR<TransactionNullableRelationFilter, TransactionWhereInput> | null
  }, "id">

  export type BalanceRecordOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    amount?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: BalanceRecordCountOrderByAggregateInput
    _avg?: BalanceRecordAvgOrderByAggregateInput
    _max?: BalanceRecordMaxOrderByAggregateInput
    _min?: BalanceRecordMinOrderByAggregateInput
    _sum?: BalanceRecordSumOrderByAggregateInput
  }

  export type BalanceRecordScalarWhereWithAggregatesInput = {
    AND?: BalanceRecordScalarWhereWithAggregatesInput | BalanceRecordScalarWhereWithAggregatesInput[]
    OR?: BalanceRecordScalarWhereWithAggregatesInput[]
    NOT?: BalanceRecordScalarWhereWithAggregatesInput | BalanceRecordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BalanceRecord"> | number
    userId?: IntWithAggregatesFilter<"BalanceRecord"> | number
    transactionId?: IntNullableWithAggregatesFilter<"BalanceRecord"> | number | null
    amount?: FloatWithAggregatesFilter<"BalanceRecord"> | number
    type?: IntWithAggregatesFilter<"BalanceRecord"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BalanceRecord"> | Date | string
  }

  export type UserCreateInput = {
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    Attachment?: AttachmentCreateNestedManyWithoutUserInput
    Course?: CourseCreateNestedManyWithoutAuthorInput
    CourseContent?: CourseContentCreateNestedManyWithoutAuthorInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    AuditRecord?: AuditRecordCreateNestedManyWithoutReviewerInput
    BalanceRecord?: BalanceRecordCreateNestedManyWithoutUserInput
    Note?: NoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    Attachment?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    Course?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    CourseContent?: CourseContentUncheckedCreateNestedManyWithoutAuthorInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    AuditRecord?: AuditRecordUncheckedCreateNestedManyWithoutReviewerInput
    BalanceRecord?: BalanceRecordUncheckedCreateNestedManyWithoutUserInput
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserRole?: UserRoleUpdateManyWithoutUserNestedInput
    Attachment?: AttachmentUpdateManyWithoutUserNestedInput
    Course?: CourseUpdateManyWithoutAuthorNestedInput
    CourseContent?: CourseContentUpdateManyWithoutAuthorNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    AuditRecord?: AuditRecordUpdateManyWithoutReviewerNestedInput
    BalanceRecord?: BalanceRecordUpdateManyWithoutUserNestedInput
    Note?: NoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    Attachment?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    Course?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    CourseContent?: CourseContentUncheckedUpdateManyWithoutAuthorNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    AuditRecord?: AuditRecordUncheckedUpdateManyWithoutReviewerNestedInput
    BalanceRecord?: BalanceRecordUncheckedUpdateManyWithoutUserNestedInput
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    name: string
    description?: string | null
    users?: UserRoleCreateNestedManyWithoutRoleInput
    RolePermissions?: RolePermissionsCreateNestedManyWithoutRoleInput
    RolePolicy?: RolePolicyCreateNestedManyWithoutRoleInput
    RoleMenu?: RoleMenuCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    users?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
    RolePermissions?: RolePermissionsUncheckedCreateNestedManyWithoutRoleInput
    RolePolicy?: RolePolicyUncheckedCreateNestedManyWithoutRoleInput
    RoleMenu?: RoleMenuUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserRoleUpdateManyWithoutRoleNestedInput
    RolePermissions?: RolePermissionsUpdateManyWithoutRoleNestedInput
    RolePolicy?: RolePolicyUpdateManyWithoutRoleNestedInput
    RoleMenu?: RoleMenuUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
    RolePermissions?: RolePermissionsUncheckedUpdateManyWithoutRoleNestedInput
    RolePolicy?: RolePolicyUncheckedUpdateManyWithoutRoleNestedInput
    RoleMenu?: RoleMenuUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type RoleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoleCreateInput = {
    role: RoleCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutUserRoleInput
  }

  export type UserRoleUncheckedCreateInput = {
    userId: number
    roleId: number
  }

  export type UserRoleUpdateInput = {
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutUserRoleNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type UserRoleCreateManyInput = {
    userId: number
    roleId: number
  }

  export type UserRoleUpdateManyMutationInput = {

  }

  export type UserRoleUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type PermissionCreateInput = {
    name: string
    action: string
    description?: string | null
    RolePermissions?: RolePermissionsCreateNestedManyWithoutPermissionInput
    PermissionPolicy?: PermissionPolicyCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: number
    name: string
    action: string
    description?: string | null
    RolePermissions?: RolePermissionsUncheckedCreateNestedManyWithoutPermissionInput
    PermissionPolicy?: PermissionPolicyUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    RolePermissions?: RolePermissionsUpdateManyWithoutPermissionNestedInput
    PermissionPolicy?: PermissionPolicyUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    RolePermissions?: RolePermissionsUncheckedUpdateManyWithoutPermissionNestedInput
    PermissionPolicy?: PermissionPolicyUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: number
    name: string
    action: string
    description?: string | null
  }

  export type PermissionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionsCreateInput = {
    role: RoleCreateNestedOneWithoutRolePermissionsInput
    permission: PermissionCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionsUncheckedCreateInput = {
    roleId: number
    permissionId: number
  }

  export type RolePermissionsUpdateInput = {
    role?: RoleUpdateOneRequiredWithoutRolePermissionsNestedInput
    permission?: PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionsUncheckedUpdateInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
  }

  export type RolePermissionsCreateManyInput = {
    roleId: number
    permissionId: number
  }

  export type RolePermissionsUpdateManyMutationInput = {

  }

  export type RolePermissionsUncheckedUpdateManyInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
  }

  export type PolicyCreateInput = {
    type: number
    effect: string
    action: string
    subject: string
    fields?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    args?: NullableJsonNullValueInput | InputJsonValue
    encode: string
    RolePolicy?: RolePolicyCreateNestedManyWithoutPolicyInput
    PermissionPolicy?: PermissionPolicyCreateNestedManyWithoutPolicyInput
  }

  export type PolicyUncheckedCreateInput = {
    id?: number
    type: number
    effect: string
    action: string
    subject: string
    fields?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    args?: NullableJsonNullValueInput | InputJsonValue
    encode: string
    RolePolicy?: RolePolicyUncheckedCreateNestedManyWithoutPolicyInput
    PermissionPolicy?: PermissionPolicyUncheckedCreateNestedManyWithoutPolicyInput
  }

  export type PolicyUpdateInput = {
    type?: IntFieldUpdateOperationsInput | number
    effect?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    fields?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    args?: NullableJsonNullValueInput | InputJsonValue
    encode?: StringFieldUpdateOperationsInput | string
    RolePolicy?: RolePolicyUpdateManyWithoutPolicyNestedInput
    PermissionPolicy?: PermissionPolicyUpdateManyWithoutPolicyNestedInput
  }

  export type PolicyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    effect?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    fields?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    args?: NullableJsonNullValueInput | InputJsonValue
    encode?: StringFieldUpdateOperationsInput | string
    RolePolicy?: RolePolicyUncheckedUpdateManyWithoutPolicyNestedInput
    PermissionPolicy?: PermissionPolicyUncheckedUpdateManyWithoutPolicyNestedInput
  }

  export type PolicyCreateManyInput = {
    id?: number
    type: number
    effect: string
    action: string
    subject: string
    fields?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    args?: NullableJsonNullValueInput | InputJsonValue
    encode: string
  }

  export type PolicyUpdateManyMutationInput = {
    type?: IntFieldUpdateOperationsInput | number
    effect?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    fields?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    args?: NullableJsonNullValueInput | InputJsonValue
    encode?: StringFieldUpdateOperationsInput | string
  }

  export type PolicyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    effect?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    fields?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    args?: NullableJsonNullValueInput | InputJsonValue
    encode?: StringFieldUpdateOperationsInput | string
  }

  export type RolePolicyCreateInput = {
    role: RoleCreateNestedOneWithoutRolePolicyInput
    policy: PolicyCreateNestedOneWithoutRolePolicyInput
  }

  export type RolePolicyUncheckedCreateInput = {
    roleId: number
    policyId: number
  }

  export type RolePolicyUpdateInput = {
    role?: RoleUpdateOneRequiredWithoutRolePolicyNestedInput
    policy?: PolicyUpdateOneRequiredWithoutRolePolicyNestedInput
  }

  export type RolePolicyUncheckedUpdateInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    policyId?: IntFieldUpdateOperationsInput | number
  }

  export type RolePolicyCreateManyInput = {
    roleId: number
    policyId: number
  }

  export type RolePolicyUpdateManyMutationInput = {

  }

  export type RolePolicyUncheckedUpdateManyInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    policyId?: IntFieldUpdateOperationsInput | number
  }

  export type PermissionPolicyCreateInput = {
    permission: PermissionCreateNestedOneWithoutPermissionPolicyInput
    policy: PolicyCreateNestedOneWithoutPermissionPolicyInput
  }

  export type PermissionPolicyUncheckedCreateInput = {
    permissionId: number
    policyId: number
  }

  export type PermissionPolicyUpdateInput = {
    permission?: PermissionUpdateOneRequiredWithoutPermissionPolicyNestedInput
    policy?: PolicyUpdateOneRequiredWithoutPermissionPolicyNestedInput
  }

  export type PermissionPolicyUncheckedUpdateInput = {
    permissionId?: IntFieldUpdateOperationsInput | number
    policyId?: IntFieldUpdateOperationsInput | number
  }

  export type PermissionPolicyCreateManyInput = {
    permissionId: number
    policyId: number
  }

  export type PermissionPolicyUpdateManyMutationInput = {

  }

  export type PermissionPolicyUncheckedUpdateManyInput = {
    permissionId?: IntFieldUpdateOperationsInput | number
    policyId?: IntFieldUpdateOperationsInput | number
  }

  export type MenuCreateInput = {
    name: string
    path: string
    label: string
    component?: string | null
    redirect?: string | null
    fullPath?: string | null
    alias?: string | null
    status?: number
    metaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meta?: MenuMetaCreateNestedOneWithoutMenuInput
    parent?: MenuCreateNestedOneWithoutChildrenInput
    children?: MenuCreateNestedManyWithoutParentInput
    roleMenus?: RoleMenuCreateNestedManyWithoutMenuInput
  }

  export type MenuUncheckedCreateInput = {
    id?: number
    name: string
    path: string
    label: string
    component?: string | null
    redirect?: string | null
    fullPath?: string | null
    alias?: string | null
    status?: number
    parentId?: number | null
    metaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meta?: MenuMetaUncheckedCreateNestedOneWithoutMenuInput
    children?: MenuUncheckedCreateNestedManyWithoutParentInput
    roleMenus?: RoleMenuUncheckedCreateNestedManyWithoutMenuInput
  }

  export type MenuUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    component?: NullableStringFieldUpdateOperationsInput | string | null
    redirect?: NullableStringFieldUpdateOperationsInput | string | null
    fullPath?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    metaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meta?: MenuMetaUpdateOneWithoutMenuNestedInput
    parent?: MenuUpdateOneWithoutChildrenNestedInput
    children?: MenuUpdateManyWithoutParentNestedInput
    roleMenus?: RoleMenuUpdateManyWithoutMenuNestedInput
  }

  export type MenuUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    component?: NullableStringFieldUpdateOperationsInput | string | null
    redirect?: NullableStringFieldUpdateOperationsInput | string | null
    fullPath?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    metaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meta?: MenuMetaUncheckedUpdateOneWithoutMenuNestedInput
    children?: MenuUncheckedUpdateManyWithoutParentNestedInput
    roleMenus?: RoleMenuUncheckedUpdateManyWithoutMenuNestedInput
  }

  export type MenuCreateManyInput = {
    id?: number
    name: string
    path: string
    label: string
    component?: string | null
    redirect?: string | null
    fullPath?: string | null
    alias?: string | null
    status?: number
    parentId?: number | null
    metaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    component?: NullableStringFieldUpdateOperationsInput | string | null
    redirect?: NullableStringFieldUpdateOperationsInput | string | null
    fullPath?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    metaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    component?: NullableStringFieldUpdateOperationsInput | string | null
    redirect?: NullableStringFieldUpdateOperationsInput | string | null
    fullPath?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    metaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuMetaCreateInput = {
    title?: string | null
    layout?: string | null
    order?: number | null
    hidden?: boolean
    disabled?: boolean
    icon?: string | null
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    menu: MenuCreateNestedOneWithoutMetaInput
  }

  export type MenuMetaUncheckedCreateInput = {
    id?: number
    title?: string | null
    layout?: string | null
    order?: number | null
    hidden?: boolean
    disabled?: boolean
    icon?: string | null
    status?: number
    menuId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuMetaUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    layout?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: MenuUpdateOneRequiredWithoutMetaNestedInput
  }

  export type MenuMetaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    layout?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuMetaCreateManyInput = {
    id?: number
    title?: string | null
    layout?: string | null
    order?: number | null
    hidden?: boolean
    disabled?: boolean
    icon?: string | null
    status?: number
    menuId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuMetaUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    layout?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuMetaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    layout?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleMenuCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutRoleMenuInput
    menu: MenuCreateNestedOneWithoutRoleMenusInput
  }

  export type RoleMenuUncheckedCreateInput = {
    roleId: number
    menuId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleMenuUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutRoleMenuNestedInput
    menu?: MenuUpdateOneRequiredWithoutRoleMenusNestedInput
  }

  export type RoleMenuUncheckedUpdateInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleMenuCreateManyInput = {
    roleId: number
    menuId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleMenuUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleMenuUncheckedUpdateManyInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DictAttachmentAttributeCreateInput = {
    type: string
    name: string
    desc?: string | null
    AttachmentAttribute?: AttachmentAttributeCreateNestedManyWithoutDictAttributeInput
  }

  export type DictAttachmentAttributeUncheckedCreateInput = {
    id?: number
    type: string
    name: string
    desc?: string | null
    AttachmentAttribute?: AttachmentAttributeUncheckedCreateNestedManyWithoutDictAttributeInput
  }

  export type DictAttachmentAttributeUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    AttachmentAttribute?: AttachmentAttributeUpdateManyWithoutDictAttributeNestedInput
  }

  export type DictAttachmentAttributeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    AttachmentAttribute?: AttachmentAttributeUncheckedUpdateManyWithoutDictAttributeNestedInput
  }

  export type DictAttachmentAttributeCreateManyInput = {
    id?: number
    type: string
    name: string
    desc?: string | null
  }

  export type DictAttachmentAttributeUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DictAttachmentAttributeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttachmentAttributeCreateInput = {
    value: string
    desc?: string | null
    Attachment: AttachmentCreateNestedOneWithoutAttachmentAttributeInput
    DictAttribute: DictAttachmentAttributeCreateNestedOneWithoutAttachmentAttributeInput
  }

  export type AttachmentAttributeUncheckedCreateInput = {
    attachmentId: number
    attributeId: number
    value: string
    desc?: string | null
  }

  export type AttachmentAttributeUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    Attachment?: AttachmentUpdateOneRequiredWithoutAttachmentAttributeNestedInput
    DictAttribute?: DictAttachmentAttributeUpdateOneRequiredWithoutAttachmentAttributeNestedInput
  }

  export type AttachmentAttributeUncheckedUpdateInput = {
    attachmentId?: IntFieldUpdateOperationsInput | number
    attributeId?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttachmentAttributeCreateManyInput = {
    attachmentId: number
    attributeId: number
    value: string
    desc?: string | null
  }

  export type AttachmentAttributeUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttachmentAttributeUncheckedUpdateManyInput = {
    attachmentId?: IntFieldUpdateOperationsInput | number
    attributeId?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttachmentCreateInput = {
    type: string
    location: string
    name?: string | null
    ossType?: string | null
    status?: number
    desc?: string | null
    createdAt?: Date | string | null
    User: UserCreateNestedOneWithoutAttachmentInput
    AttachmentAttribute?: AttachmentAttributeCreateNestedManyWithoutAttachmentInput
    Course?: CourseCreateNestedManyWithoutCoverInput
    ContentAttachment?: ContentAttachmentCreateNestedManyWithoutAttachmentInput
  }

  export type AttachmentUncheckedCreateInput = {
    id?: number
    type: string
    location: string
    name?: string | null
    ossType?: string | null
    userId: number
    status?: number
    desc?: string | null
    createdAt?: Date | string | null
    AttachmentAttribute?: AttachmentAttributeUncheckedCreateNestedManyWithoutAttachmentInput
    Course?: CourseUncheckedCreateNestedManyWithoutCoverInput
    ContentAttachment?: ContentAttachmentUncheckedCreateNestedManyWithoutAttachmentInput
  }

  export type AttachmentUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    ossType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneRequiredWithoutAttachmentNestedInput
    AttachmentAttribute?: AttachmentAttributeUpdateManyWithoutAttachmentNestedInput
    Course?: CourseUpdateManyWithoutCoverNestedInput
    ContentAttachment?: ContentAttachmentUpdateManyWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    ossType?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttachmentAttribute?: AttachmentAttributeUncheckedUpdateManyWithoutAttachmentNestedInput
    Course?: CourseUncheckedUpdateManyWithoutCoverNestedInput
    ContentAttachment?: ContentAttachmentUncheckedUpdateManyWithoutAttachmentNestedInput
  }

  export type AttachmentCreateManyInput = {
    id?: number
    type: string
    location: string
    name?: string | null
    ossType?: string | null
    userId: number
    status?: number
    desc?: string | null
    createdAt?: Date | string | null
  }

  export type AttachmentUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    ossType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttachmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    ossType?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourseCreateInput = {
    title: string
    subTitle?: string | null
    desc?: string | null
    originPrice?: number | null
    price?: number | null
    status?: number
    counts?: number
    order?: number
    detail?: string | null
    type?: string | null
    Cover?: AttachmentCreateNestedOneWithoutCourseInput
    Author: UserCreateNestedOneWithoutCourseInput
    Contents?: CourseContentCreateNestedManyWithoutCourseInput
    Tags?: CourseTagCreateNestedManyWithoutCourseInput
    CourseComment?: CourseCommentCreateNestedManyWithoutCourseInput
    Transaction?: TransactionCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: number
    title: string
    subTitle?: string | null
    desc?: string | null
    coverId?: number | null
    authorId: number
    originPrice?: number | null
    price?: number | null
    status?: number
    counts?: number
    order?: number
    detail?: string | null
    type?: string | null
    Contents?: CourseContentUncheckedCreateNestedManyWithoutCourseInput
    Tags?: CourseTagUncheckedCreateNestedManyWithoutCourseInput
    CourseComment?: CourseCommentUncheckedCreateNestedManyWithoutCourseInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    originPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    counts?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Cover?: AttachmentUpdateOneWithoutCourseNestedInput
    Author?: UserUpdateOneRequiredWithoutCourseNestedInput
    Contents?: CourseContentUpdateManyWithoutCourseNestedInput
    Tags?: CourseTagUpdateManyWithoutCourseNestedInput
    CourseComment?: CourseCommentUpdateManyWithoutCourseNestedInput
    Transaction?: TransactionUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    coverId?: NullableIntFieldUpdateOperationsInput | number | null
    authorId?: IntFieldUpdateOperationsInput | number
    originPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    counts?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Contents?: CourseContentUncheckedUpdateManyWithoutCourseNestedInput
    Tags?: CourseTagUncheckedUpdateManyWithoutCourseNestedInput
    CourseComment?: CourseCommentUncheckedUpdateManyWithoutCourseNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: number
    title: string
    subTitle?: string | null
    desc?: string | null
    coverId?: number | null
    authorId: number
    originPrice?: number | null
    price?: number | null
    status?: number
    counts?: number
    order?: number
    detail?: string | null
    type?: string | null
  }

  export type CourseUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    originPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    counts?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    coverId?: NullableIntFieldUpdateOperationsInput | number | null
    authorId?: IntFieldUpdateOperationsInput | number
    originPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    counts?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseContentCreateInput = {
    title: string
    type?: string | null
    order?: number
    pid?: number | null
    status?: number
    Course: CourseCreateNestedOneWithoutContentsInput
    Author: UserCreateNestedOneWithoutCourseContentInput
    Attachments?: ContentAttachmentCreateNestedManyWithoutContentInput
    Tags?: ContentTagCreateNestedManyWithoutContentInput
    ContentComment?: ContentCommentCreateNestedManyWithoutContentInput
  }

  export type CourseContentUncheckedCreateInput = {
    id?: number
    courseId: number
    title: string
    type?: string | null
    order?: number
    pid?: number | null
    status?: number
    authorId: number
    Attachments?: ContentAttachmentUncheckedCreateNestedManyWithoutContentInput
    Tags?: ContentTagUncheckedCreateNestedManyWithoutContentInput
    ContentComment?: ContentCommentUncheckedCreateNestedManyWithoutContentInput
  }

  export type CourseContentUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    Course?: CourseUpdateOneRequiredWithoutContentsNestedInput
    Author?: UserUpdateOneRequiredWithoutCourseContentNestedInput
    Attachments?: ContentAttachmentUpdateManyWithoutContentNestedInput
    Tags?: ContentTagUpdateManyWithoutContentNestedInput
    ContentComment?: ContentCommentUpdateManyWithoutContentNestedInput
  }

  export type CourseContentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    Attachments?: ContentAttachmentUncheckedUpdateManyWithoutContentNestedInput
    Tags?: ContentTagUncheckedUpdateManyWithoutContentNestedInput
    ContentComment?: ContentCommentUncheckedUpdateManyWithoutContentNestedInput
  }

  export type CourseContentCreateManyInput = {
    id?: number
    courseId: number
    title: string
    type?: string | null
    order?: number
    pid?: number | null
    status?: number
    authorId: number
  }

  export type CourseContentUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
  }

  export type CourseContentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentAttachmentCreateInput = {
    Content: CourseContentCreateNestedOneWithoutAttachmentsInput
    Attachment: AttachmentCreateNestedOneWithoutContentAttachmentInput
  }

  export type ContentAttachmentUncheckedCreateInput = {
    contentId: number
    attachmentId: number
  }

  export type ContentAttachmentUpdateInput = {
    Content?: CourseContentUpdateOneRequiredWithoutAttachmentsNestedInput
    Attachment?: AttachmentUpdateOneRequiredWithoutContentAttachmentNestedInput
  }

  export type ContentAttachmentUncheckedUpdateInput = {
    contentId?: IntFieldUpdateOperationsInput | number
    attachmentId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentAttachmentCreateManyInput = {
    contentId: number
    attachmentId: number
  }

  export type ContentAttachmentUpdateManyMutationInput = {

  }

  export type ContentAttachmentUncheckedUpdateManyInput = {
    contentId?: IntFieldUpdateOperationsInput | number
    attachmentId?: IntFieldUpdateOperationsInput | number
  }

  export type DictCourseTagCreateInput = {
    name: string
    order?: number
    status?: number
    CourseType?: DictCourseTypeCreateNestedOneWithoutCourseTagsInput
    CourseTag?: CourseTagCreateNestedManyWithoutTagInput
    ContentTag?: ContentTagCreateNestedManyWithoutTagInput
  }

  export type DictCourseTagUncheckedCreateInput = {
    id?: number
    name: string
    typeId?: number | null
    order?: number
    status?: number
    CourseTag?: CourseTagUncheckedCreateNestedManyWithoutTagInput
    ContentTag?: ContentTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type DictCourseTagUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    CourseType?: DictCourseTypeUpdateOneWithoutCourseTagsNestedInput
    CourseTag?: CourseTagUpdateManyWithoutTagNestedInput
    ContentTag?: ContentTagUpdateManyWithoutTagNestedInput
  }

  export type DictCourseTagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    CourseTag?: CourseTagUncheckedUpdateManyWithoutTagNestedInput
    ContentTag?: ContentTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type DictCourseTagCreateManyInput = {
    id?: number
    name: string
    typeId?: number | null
    order?: number
    status?: number
  }

  export type DictCourseTagUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
  }

  export type DictCourseTagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
  }

  export type DictCourseTypeCreateInput = {
    name: string
    order?: number
    status?: number
    CourseTags?: DictCourseTagCreateNestedManyWithoutCourseTypeInput
  }

  export type DictCourseTypeUncheckedCreateInput = {
    id?: number
    name: string
    order?: number
    status?: number
    CourseTags?: DictCourseTagUncheckedCreateNestedManyWithoutCourseTypeInput
  }

  export type DictCourseTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    CourseTags?: DictCourseTagUpdateManyWithoutCourseTypeNestedInput
  }

  export type DictCourseTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    CourseTags?: DictCourseTagUncheckedUpdateManyWithoutCourseTypeNestedInput
  }

  export type DictCourseTypeCreateManyInput = {
    id?: number
    name: string
    order?: number
    status?: number
  }

  export type DictCourseTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
  }

  export type DictCourseTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
  }

  export type CourseTagCreateInput = {
    Course: CourseCreateNestedOneWithoutTagsInput
    Tag: DictCourseTagCreateNestedOneWithoutCourseTagInput
  }

  export type CourseTagUncheckedCreateInput = {
    courseId: number
    tagId: number
  }

  export type CourseTagUpdateInput = {
    Course?: CourseUpdateOneRequiredWithoutTagsNestedInput
    Tag?: DictCourseTagUpdateOneRequiredWithoutCourseTagNestedInput
  }

  export type CourseTagUncheckedUpdateInput = {
    courseId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type CourseTagCreateManyInput = {
    courseId: number
    tagId: number
  }

  export type CourseTagUpdateManyMutationInput = {

  }

  export type CourseTagUncheckedUpdateManyInput = {
    courseId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentTagCreateInput = {
    Content: CourseContentCreateNestedOneWithoutTagsInput
    Tag: DictCourseTagCreateNestedOneWithoutContentTagInput
  }

  export type ContentTagUncheckedCreateInput = {
    contentId: number
    tagId: number
  }

  export type ContentTagUpdateInput = {
    Content?: CourseContentUpdateOneRequiredWithoutTagsNestedInput
    Tag?: DictCourseTagUpdateOneRequiredWithoutContentTagNestedInput
  }

  export type ContentTagUncheckedUpdateInput = {
    contentId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentTagCreateManyInput = {
    contentId: number
    tagId: number
  }

  export type ContentTagUpdateManyMutationInput = {

  }

  export type ContentTagUncheckedUpdateManyInput = {
    contentId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type CommentCreateInput = {
    created?: Date | string
    hands?: bigint | number
    status?: number
    isBest?: number
    User: UserCreateNestedOneWithoutCommentInput
    parent?: CommentCreateNestedOneWithoutChildrenInput
    children?: CommentCreateNestedManyWithoutParentInput
    CourseComment?: CourseCommentCreateNestedManyWithoutCommentInput
    ContentComment?: ContentCommentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: number
    pid?: number | null
    userId: number
    created?: Date | string
    hands?: bigint | number
    status?: number
    isBest?: number
    children?: CommentUncheckedCreateNestedManyWithoutParentInput
    CourseComment?: CourseCommentUncheckedCreateNestedManyWithoutCommentInput
    ContentComment?: ContentCommentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentUpdateInput = {
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    hands?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: IntFieldUpdateOperationsInput | number
    isBest?: IntFieldUpdateOperationsInput | number
    User?: UserUpdateOneRequiredWithoutCommentNestedInput
    parent?: CommentUpdateOneWithoutChildrenNestedInput
    children?: CommentUpdateManyWithoutParentNestedInput
    CourseComment?: CourseCommentUpdateManyWithoutCommentNestedInput
    ContentComment?: ContentCommentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    hands?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: IntFieldUpdateOperationsInput | number
    isBest?: IntFieldUpdateOperationsInput | number
    children?: CommentUncheckedUpdateManyWithoutParentNestedInput
    CourseComment?: CourseCommentUncheckedUpdateManyWithoutCommentNestedInput
    ContentComment?: ContentCommentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: number
    pid?: number | null
    userId: number
    created?: Date | string
    hands?: bigint | number
    status?: number
    isBest?: number
  }

  export type CommentUpdateManyMutationInput = {
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    hands?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: IntFieldUpdateOperationsInput | number
    isBest?: IntFieldUpdateOperationsInput | number
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    hands?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: IntFieldUpdateOperationsInput | number
    isBest?: IntFieldUpdateOperationsInput | number
  }

  export type CourseCommentCreateInput = {
    Course: CourseCreateNestedOneWithoutCourseCommentInput
    Comment: CommentCreateNestedOneWithoutCourseCommentInput
  }

  export type CourseCommentUncheckedCreateInput = {
    courseId: number
    commentId: number
  }

  export type CourseCommentUpdateInput = {
    Course?: CourseUpdateOneRequiredWithoutCourseCommentNestedInput
    Comment?: CommentUpdateOneRequiredWithoutCourseCommentNestedInput
  }

  export type CourseCommentUncheckedUpdateInput = {
    courseId?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
  }

  export type CourseCommentCreateManyInput = {
    courseId: number
    commentId: number
  }

  export type CourseCommentUpdateManyMutationInput = {

  }

  export type CourseCommentUncheckedUpdateManyInput = {
    courseId?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentCommentCreateInput = {
    Content: CourseContentCreateNestedOneWithoutContentCommentInput
    Comment: CommentCreateNestedOneWithoutContentCommentInput
  }

  export type ContentCommentUncheckedCreateInput = {
    contentId: number
    commentId: number
  }

  export type ContentCommentUpdateInput = {
    Content?: CourseContentUpdateOneRequiredWithoutContentCommentNestedInput
    Comment?: CommentUpdateOneRequiredWithoutContentCommentNestedInput
  }

  export type ContentCommentUncheckedUpdateInput = {
    contentId?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentCommentCreateManyInput = {
    contentId: number
    commentId: number
  }

  export type ContentCommentUpdateManyMutationInput = {

  }

  export type ContentCommentUncheckedUpdateManyInput = {
    contentId?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
  }

  export type NoteCreateInput = {
    content: string
    createAt?: Date | string
    updateAt?: Date | string | null
    status?: number | null
    User: UserCreateNestedOneWithoutNoteInput
  }

  export type NoteUncheckedCreateInput = {
    id?: number
    userId: number
    content: string
    createAt?: Date | string
    updateAt?: Date | string | null
    status?: number | null
  }

  export type NoteUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    User?: UserUpdateOneRequiredWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NoteCreateManyInput = {
    id?: number
    userId: number
    content: string
    createAt?: Date | string
    updateAt?: Date | string | null
    status?: number | null
  }

  export type NoteUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DictPlatformCreateInput = {
    name: string
    url?: string | null
    Transaction?: TransactionCreateNestedManyWithoutPlatformInput
  }

  export type DictPlatformUncheckedCreateInput = {
    id?: number
    name: string
    url?: string | null
    Transaction?: TransactionUncheckedCreateNestedManyWithoutPlatformInput
  }

  export type DictPlatformUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    Transaction?: TransactionUpdateManyWithoutPlatformNestedInput
  }

  export type DictPlatformUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    Transaction?: TransactionUncheckedUpdateManyWithoutPlatformNestedInput
  }

  export type DictPlatformCreateManyInput = {
    id?: number
    name: string
    url?: string | null
  }

  export type DictPlatformUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DictPlatformUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionCreateInput = {
    amount: number
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Course: CourseCreateNestedOneWithoutTransactionInput
    User: UserCreateNestedOneWithoutTransactionInput
    Platform: DictPlatformCreateNestedOneWithoutTransactionInput
    GroupTransaction?: GroupTransactionCreateNestedManyWithoutTransactionInput
    BalanceRecord?: BalanceRecordCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: number
    courseId: number
    userId: number
    amount: number
    platformId: number
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    GroupTransaction?: GroupTransactionUncheckedCreateNestedManyWithoutTransactionInput
    BalanceRecord?: BalanceRecordUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Course?: CourseUpdateOneRequiredWithoutTransactionNestedInput
    User?: UserUpdateOneRequiredWithoutTransactionNestedInput
    Platform?: DictPlatformUpdateOneRequiredWithoutTransactionNestedInput
    GroupTransaction?: GroupTransactionUpdateManyWithoutTransactionNestedInput
    BalanceRecord?: BalanceRecordUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    platformId?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GroupTransaction?: GroupTransactionUncheckedUpdateManyWithoutTransactionNestedInput
    BalanceRecord?: BalanceRecordUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionCreateManyInput = {
    id?: number
    courseId: number
    userId: number
    amount: number
    platformId: number
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type TransactionUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    platformId?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupTransactionCreateInput = {
    groupId: string
    Transaction: TransactionCreateNestedOneWithoutGroupTransactionInput
  }

  export type GroupTransactionUncheckedCreateInput = {
    id?: number
    groupId: string
    transactionId: number
  }

  export type GroupTransactionUpdateInput = {
    groupId?: StringFieldUpdateOperationsInput | string
    Transaction?: TransactionUpdateOneRequiredWithoutGroupTransactionNestedInput
  }

  export type GroupTransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: StringFieldUpdateOperationsInput | string
    transactionId?: IntFieldUpdateOperationsInput | number
  }

  export type GroupTransactionCreateManyInput = {
    id?: number
    groupId: string
    transactionId: number
  }

  export type GroupTransactionUpdateManyMutationInput = {
    groupId?: StringFieldUpdateOperationsInput | string
  }

  export type GroupTransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: StringFieldUpdateOperationsInput | string
    transactionId?: IntFieldUpdateOperationsInput | number
  }

  export type AuditFlowCreateInput = {
    name: string
    description?: string | null
    AuditStage?: AuditStageCreateNestedManyWithoutFlowInput
  }

  export type AuditFlowUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    AuditStage?: AuditStageUncheckedCreateNestedManyWithoutFlowInput
  }

  export type AuditFlowUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    AuditStage?: AuditStageUpdateManyWithoutFlowNestedInput
  }

  export type AuditFlowUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    AuditStage?: AuditStageUncheckedUpdateManyWithoutFlowNestedInput
  }

  export type AuditFlowCreateManyInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type AuditFlowUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditFlowUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditStageCreateInput = {
    name: string
    level: number
    Flow: AuditFlowCreateNestedOneWithoutAuditStageInput
    parent?: AuditStageCreateNestedOneWithoutChildrenInput
    children?: AuditStageCreateNestedManyWithoutParentInput
    AuditRecord?: AuditRecordCreateNestedManyWithoutStageInput
  }

  export type AuditStageUncheckedCreateInput = {
    id?: number
    flowId: number
    name: string
    level: number
    pid?: number | null
    children?: AuditStageUncheckedCreateNestedManyWithoutParentInput
    AuditRecord?: AuditRecordUncheckedCreateNestedManyWithoutStageInput
  }

  export type AuditStageUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    Flow?: AuditFlowUpdateOneRequiredWithoutAuditStageNestedInput
    parent?: AuditStageUpdateOneWithoutChildrenNestedInput
    children?: AuditStageUpdateManyWithoutParentNestedInput
    AuditRecord?: AuditRecordUpdateManyWithoutStageNestedInput
  }

  export type AuditStageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    flowId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    children?: AuditStageUncheckedUpdateManyWithoutParentNestedInput
    AuditRecord?: AuditRecordUncheckedUpdateManyWithoutStageNestedInput
  }

  export type AuditStageCreateManyInput = {
    id?: number
    flowId: number
    name: string
    level: number
    pid?: number | null
  }

  export type AuditStageUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type AuditStageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    flowId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AuditRecordCreateInput = {
    entityId: number
    entityType: string
    status?: string | null
    createdAt?: Date | string
    notes?: string | null
    Stage: AuditStageCreateNestedOneWithoutAuditRecordInput
    Reviewer: UserCreateNestedOneWithoutAuditRecordInput
  }

  export type AuditRecordUncheckedCreateInput = {
    id?: number
    entityId: number
    entityType: string
    stageId: number
    status?: string | null
    reviewerId: number
    createdAt?: Date | string
    notes?: string | null
  }

  export type AuditRecordUpdateInput = {
    entityId?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    Stage?: AuditStageUpdateOneRequiredWithoutAuditRecordNestedInput
    Reviewer?: UserUpdateOneRequiredWithoutAuditRecordNestedInput
  }

  export type AuditRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityId?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    stageId?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditRecordCreateManyInput = {
    id?: number
    entityId: number
    entityType: string
    stageId: number
    status?: string | null
    reviewerId: number
    createdAt?: Date | string
    notes?: string | null
  }

  export type AuditRecordUpdateManyMutationInput = {
    entityId?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityId?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    stageId?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DictCouponTypeCreateInput = {
    name: string
    desc?: string | null
    Coupon?: CouponCreateNestedManyWithoutCouponTypeInput
  }

  export type DictCouponTypeUncheckedCreateInput = {
    id?: number
    name: string
    desc?: string | null
    Coupon?: CouponUncheckedCreateNestedManyWithoutCouponTypeInput
  }

  export type DictCouponTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    Coupon?: CouponUpdateManyWithoutCouponTypeNestedInput
  }

  export type DictCouponTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    Coupon?: CouponUncheckedUpdateManyWithoutCouponTypeNestedInput
  }

  export type DictCouponTypeCreateManyInput = {
    id?: number
    name: string
    desc?: string | null
  }

  export type DictCouponTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DictCouponTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CouponCreateInput = {
    productId?: number | null
    threshold?: number | null
    discount: number
    validUntil: Date | string
    universal?: boolean
    CouponType: DictCouponTypeCreateNestedOneWithoutCouponInput
  }

  export type CouponUncheckedCreateInput = {
    id?: number
    productId?: number | null
    typeId: number
    threshold?: number | null
    discount: number
    validUntil: Date | string
    universal?: boolean
  }

  export type CouponUpdateInput = {
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: FloatFieldUpdateOperationsInput | number
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    universal?: BoolFieldUpdateOperationsInput | boolean
    CouponType?: DictCouponTypeUpdateOneRequiredWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    typeId?: IntFieldUpdateOperationsInput | number
    threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: FloatFieldUpdateOperationsInput | number
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    universal?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CouponCreateManyInput = {
    id?: number
    productId?: number | null
    typeId: number
    threshold?: number | null
    discount: number
    validUntil: Date | string
    universal?: boolean
  }

  export type CouponUpdateManyMutationInput = {
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: FloatFieldUpdateOperationsInput | number
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    universal?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CouponUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    typeId?: IntFieldUpdateOperationsInput | number
    threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: FloatFieldUpdateOperationsInput | number
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    universal?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BalanceRecordCreateInput = {
    amount: number
    type?: number
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutBalanceRecordInput
    Transaction?: TransactionCreateNestedOneWithoutBalanceRecordInput
  }

  export type BalanceRecordUncheckedCreateInput = {
    id?: number
    userId: number
    transactionId?: number | null
    amount: number
    type?: number
    createdAt?: Date | string
  }

  export type BalanceRecordUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutBalanceRecordNestedInput
    Transaction?: TransactionUpdateOneWithoutBalanceRecordNestedInput
  }

  export type BalanceRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceRecordCreateManyInput = {
    id?: number
    userId: number
    transactionId?: number | null
    amount: number
    type?: number
    createdAt?: Date | string
  }

  export type BalanceRecordUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type AttachmentListRelationFilter = {
    every?: AttachmentWhereInput
    some?: AttachmentWhereInput
    none?: AttachmentWhereInput
  }

  export type CourseListRelationFilter = {
    every?: CourseWhereInput
    some?: CourseWhereInput
    none?: CourseWhereInput
  }

  export type CourseContentListRelationFilter = {
    every?: CourseContentWhereInput
    some?: CourseContentWhereInput
    none?: CourseContentWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type AuditRecordListRelationFilter = {
    every?: AuditRecordWhereInput
    some?: AuditRecordWhereInput
    none?: AuditRecordWhereInput
  }

  export type BalanceRecordListRelationFilter = {
    every?: BalanceRecordWhereInput
    some?: BalanceRecordWhereInput
    none?: BalanceRecordWhereInput
  }

  export type NoteListRelationFilter = {
    every?: NoteWhereInput
    some?: NoteWhereInput
    none?: NoteWhereInput
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseContentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BalanceRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type RolePermissionsListRelationFilter = {
    every?: RolePermissionsWhereInput
    some?: RolePermissionsWhereInput
    none?: RolePermissionsWhereInput
  }

  export type RolePolicyListRelationFilter = {
    every?: RolePolicyWhereInput
    some?: RolePolicyWhereInput
    none?: RolePolicyWhereInput
  }

  export type RoleMenuListRelationFilter = {
    every?: RoleMenuWhereInput
    some?: RoleMenuWhereInput
    none?: RoleMenuWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RolePermissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RolePolicyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleMenuOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserRoleUserIdRoleIdCompoundUniqueInput = {
    userId: number
    roleId: number
  }

  export type UserRoleCountOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleAvgOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleSumOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type PermissionPolicyListRelationFilter = {
    every?: PermissionPolicyWhereInput
    some?: PermissionPolicyWhereInput
    none?: PermissionPolicyWhereInput
  }

  export type PermissionPolicyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    action?: SortOrder
    description?: SortOrder
  }

  export type PermissionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    action?: SortOrder
    description?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    action?: SortOrder
    description?: SortOrder
  }

  export type PermissionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PermissionRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RolePermissionsRoleIdPermissionIdCompoundUniqueInput = {
    roleId: number
    permissionId: number
  }

  export type RolePermissionsCountOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionsAvgOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionsMaxOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionsMinOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionsSumOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PolicyCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    effect?: SortOrder
    action?: SortOrder
    subject?: SortOrder
    fields?: SortOrder
    conditions?: SortOrder
    args?: SortOrder
    encode?: SortOrder
  }

  export type PolicyAvgOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type PolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    effect?: SortOrder
    action?: SortOrder
    subject?: SortOrder
    encode?: SortOrder
  }

  export type PolicyMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    effect?: SortOrder
    action?: SortOrder
    subject?: SortOrder
    encode?: SortOrder
  }

  export type PolicySumOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type PolicyRelationFilter = {
    is?: PolicyWhereInput
    isNot?: PolicyWhereInput
  }

  export type RolePolicyRoleIdPolicyIdCompoundUniqueInput = {
    roleId: number
    policyId: number
  }

  export type RolePolicyCountOrderByAggregateInput = {
    roleId?: SortOrder
    policyId?: SortOrder
  }

  export type RolePolicyAvgOrderByAggregateInput = {
    roleId?: SortOrder
    policyId?: SortOrder
  }

  export type RolePolicyMaxOrderByAggregateInput = {
    roleId?: SortOrder
    policyId?: SortOrder
  }

  export type RolePolicyMinOrderByAggregateInput = {
    roleId?: SortOrder
    policyId?: SortOrder
  }

  export type RolePolicySumOrderByAggregateInput = {
    roleId?: SortOrder
    policyId?: SortOrder
  }

  export type PermissionPolicyPermissionIdPolicyIdCompoundUniqueInput = {
    permissionId: number
    policyId: number
  }

  export type PermissionPolicyCountOrderByAggregateInput = {
    permissionId?: SortOrder
    policyId?: SortOrder
  }

  export type PermissionPolicyAvgOrderByAggregateInput = {
    permissionId?: SortOrder
    policyId?: SortOrder
  }

  export type PermissionPolicyMaxOrderByAggregateInput = {
    permissionId?: SortOrder
    policyId?: SortOrder
  }

  export type PermissionPolicyMinOrderByAggregateInput = {
    permissionId?: SortOrder
    policyId?: SortOrder
  }

  export type PermissionPolicySumOrderByAggregateInput = {
    permissionId?: SortOrder
    policyId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type MenuMetaNullableRelationFilter = {
    is?: MenuMetaWhereInput | null
    isNot?: MenuMetaWhereInput | null
  }

  export type MenuNullableRelationFilter = {
    is?: MenuWhereInput | null
    isNot?: MenuWhereInput | null
  }

  export type MenuListRelationFilter = {
    every?: MenuWhereInput
    some?: MenuWhereInput
    none?: MenuWhereInput
  }

  export type MenuOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MenuCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    label?: SortOrder
    component?: SortOrder
    redirect?: SortOrder
    fullPath?: SortOrder
    alias?: SortOrder
    status?: SortOrder
    parentId?: SortOrder
    metaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuAvgOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    parentId?: SortOrder
    metaId?: SortOrder
  }

  export type MenuMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    label?: SortOrder
    component?: SortOrder
    redirect?: SortOrder
    fullPath?: SortOrder
    alias?: SortOrder
    status?: SortOrder
    parentId?: SortOrder
    metaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    label?: SortOrder
    component?: SortOrder
    redirect?: SortOrder
    fullPath?: SortOrder
    alias?: SortOrder
    status?: SortOrder
    parentId?: SortOrder
    metaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuSumOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    parentId?: SortOrder
    metaId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type MenuRelationFilter = {
    is?: MenuWhereInput
    isNot?: MenuWhereInput
  }

  export type MenuMetaCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    layout?: SortOrder
    order?: SortOrder
    hidden?: SortOrder
    disabled?: SortOrder
    icon?: SortOrder
    status?: SortOrder
    menuId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuMetaAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    status?: SortOrder
    menuId?: SortOrder
  }

  export type MenuMetaMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    layout?: SortOrder
    order?: SortOrder
    hidden?: SortOrder
    disabled?: SortOrder
    icon?: SortOrder
    status?: SortOrder
    menuId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuMetaMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    layout?: SortOrder
    order?: SortOrder
    hidden?: SortOrder
    disabled?: SortOrder
    icon?: SortOrder
    status?: SortOrder
    menuId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuMetaSumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    status?: SortOrder
    menuId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type RoleMenuRoleIdMenuIdCompoundUniqueInput = {
    roleId: number
    menuId: number
  }

  export type RoleMenuCountOrderByAggregateInput = {
    roleId?: SortOrder
    menuId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMenuAvgOrderByAggregateInput = {
    roleId?: SortOrder
    menuId?: SortOrder
  }

  export type RoleMenuMaxOrderByAggregateInput = {
    roleId?: SortOrder
    menuId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMenuMinOrderByAggregateInput = {
    roleId?: SortOrder
    menuId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMenuSumOrderByAggregateInput = {
    roleId?: SortOrder
    menuId?: SortOrder
  }

  export type AttachmentAttributeListRelationFilter = {
    every?: AttachmentAttributeWhereInput
    some?: AttachmentAttributeWhereInput
    none?: AttachmentAttributeWhereInput
  }

  export type AttachmentAttributeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DictAttachmentAttributeTypeNameCompoundUniqueInput = {
    type: string
    name: string
  }

  export type DictAttachmentAttributeCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    desc?: SortOrder
  }

  export type DictAttachmentAttributeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DictAttachmentAttributeMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    desc?: SortOrder
  }

  export type DictAttachmentAttributeMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    desc?: SortOrder
  }

  export type DictAttachmentAttributeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AttachmentRelationFilter = {
    is?: AttachmentWhereInput
    isNot?: AttachmentWhereInput
  }

  export type DictAttachmentAttributeRelationFilter = {
    is?: DictAttachmentAttributeWhereInput
    isNot?: DictAttachmentAttributeWhereInput
  }

  export type AttachmentAttributeAttachmentIdAttributeIdCompoundUniqueInput = {
    attachmentId: number
    attributeId: number
  }

  export type AttachmentAttributeCountOrderByAggregateInput = {
    attachmentId?: SortOrder
    attributeId?: SortOrder
    value?: SortOrder
    desc?: SortOrder
  }

  export type AttachmentAttributeAvgOrderByAggregateInput = {
    attachmentId?: SortOrder
    attributeId?: SortOrder
  }

  export type AttachmentAttributeMaxOrderByAggregateInput = {
    attachmentId?: SortOrder
    attributeId?: SortOrder
    value?: SortOrder
    desc?: SortOrder
  }

  export type AttachmentAttributeMinOrderByAggregateInput = {
    attachmentId?: SortOrder
    attributeId?: SortOrder
    value?: SortOrder
    desc?: SortOrder
  }

  export type AttachmentAttributeSumOrderByAggregateInput = {
    attachmentId?: SortOrder
    attributeId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ContentAttachmentListRelationFilter = {
    every?: ContentAttachmentWhereInput
    some?: ContentAttachmentWhereInput
    none?: ContentAttachmentWhereInput
  }

  export type ContentAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    location?: SortOrder
    name?: SortOrder
    ossType?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    desc?: SortOrder
    createdAt?: SortOrder
  }

  export type AttachmentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
  }

  export type AttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    location?: SortOrder
    name?: SortOrder
    ossType?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    desc?: SortOrder
    createdAt?: SortOrder
  }

  export type AttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    location?: SortOrder
    name?: SortOrder
    ossType?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    desc?: SortOrder
    createdAt?: SortOrder
  }

  export type AttachmentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AttachmentNullableRelationFilter = {
    is?: AttachmentWhereInput | null
    isNot?: AttachmentWhereInput | null
  }

  export type CourseTagListRelationFilter = {
    every?: CourseTagWhereInput
    some?: CourseTagWhereInput
    none?: CourseTagWhereInput
  }

  export type CourseCommentListRelationFilter = {
    every?: CourseCommentWhereInput
    some?: CourseCommentWhereInput
    none?: CourseCommentWhereInput
  }

  export type CourseTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subTitle?: SortOrder
    desc?: SortOrder
    coverId?: SortOrder
    authorId?: SortOrder
    originPrice?: SortOrder
    price?: SortOrder
    status?: SortOrder
    counts?: SortOrder
    order?: SortOrder
    detail?: SortOrder
    type?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    id?: SortOrder
    coverId?: SortOrder
    authorId?: SortOrder
    originPrice?: SortOrder
    price?: SortOrder
    status?: SortOrder
    counts?: SortOrder
    order?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subTitle?: SortOrder
    desc?: SortOrder
    coverId?: SortOrder
    authorId?: SortOrder
    originPrice?: SortOrder
    price?: SortOrder
    status?: SortOrder
    counts?: SortOrder
    order?: SortOrder
    detail?: SortOrder
    type?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subTitle?: SortOrder
    desc?: SortOrder
    coverId?: SortOrder
    authorId?: SortOrder
    originPrice?: SortOrder
    price?: SortOrder
    status?: SortOrder
    counts?: SortOrder
    order?: SortOrder
    detail?: SortOrder
    type?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    id?: SortOrder
    coverId?: SortOrder
    authorId?: SortOrder
    originPrice?: SortOrder
    price?: SortOrder
    status?: SortOrder
    counts?: SortOrder
    order?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type CourseRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type ContentTagListRelationFilter = {
    every?: ContentTagWhereInput
    some?: ContentTagWhereInput
    none?: ContentTagWhereInput
  }

  export type ContentCommentListRelationFilter = {
    every?: ContentCommentWhereInput
    some?: ContentCommentWhereInput
    none?: ContentCommentWhereInput
  }

  export type ContentTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseContentCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    order?: SortOrder
    pid?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
  }

  export type CourseContentAvgOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    order?: SortOrder
    pid?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
  }

  export type CourseContentMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    order?: SortOrder
    pid?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
  }

  export type CourseContentMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    order?: SortOrder
    pid?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
  }

  export type CourseContentSumOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    order?: SortOrder
    pid?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
  }

  export type CourseContentRelationFilter = {
    is?: CourseContentWhereInput
    isNot?: CourseContentWhereInput
  }

  export type ContentAttachmentContentIdAttachmentIdCompoundUniqueInput = {
    contentId: number
    attachmentId: number
  }

  export type ContentAttachmentCountOrderByAggregateInput = {
    contentId?: SortOrder
    attachmentId?: SortOrder
  }

  export type ContentAttachmentAvgOrderByAggregateInput = {
    contentId?: SortOrder
    attachmentId?: SortOrder
  }

  export type ContentAttachmentMaxOrderByAggregateInput = {
    contentId?: SortOrder
    attachmentId?: SortOrder
  }

  export type ContentAttachmentMinOrderByAggregateInput = {
    contentId?: SortOrder
    attachmentId?: SortOrder
  }

  export type ContentAttachmentSumOrderByAggregateInput = {
    contentId?: SortOrder
    attachmentId?: SortOrder
  }

  export type DictCourseTypeNullableRelationFilter = {
    is?: DictCourseTypeWhereInput | null
    isNot?: DictCourseTypeWhereInput | null
  }

  export type DictCourseTagNameTypeIdCompoundUniqueInput = {
    name: string
    typeId: number
  }

  export type DictCourseTagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    typeId?: SortOrder
    order?: SortOrder
    status?: SortOrder
  }

  export type DictCourseTagAvgOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
    order?: SortOrder
    status?: SortOrder
  }

  export type DictCourseTagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    typeId?: SortOrder
    order?: SortOrder
    status?: SortOrder
  }

  export type DictCourseTagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    typeId?: SortOrder
    order?: SortOrder
    status?: SortOrder
  }

  export type DictCourseTagSumOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
    order?: SortOrder
    status?: SortOrder
  }

  export type DictCourseTagListRelationFilter = {
    every?: DictCourseTagWhereInput
    some?: DictCourseTagWhereInput
    none?: DictCourseTagWhereInput
  }

  export type DictCourseTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DictCourseTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    status?: SortOrder
  }

  export type DictCourseTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    status?: SortOrder
  }

  export type DictCourseTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    status?: SortOrder
  }

  export type DictCourseTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    status?: SortOrder
  }

  export type DictCourseTypeSumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    status?: SortOrder
  }

  export type DictCourseTagRelationFilter = {
    is?: DictCourseTagWhereInput
    isNot?: DictCourseTagWhereInput
  }

  export type CourseTagCourseIdTagIdCompoundUniqueInput = {
    courseId: number
    tagId: number
  }

  export type CourseTagCountOrderByAggregateInput = {
    courseId?: SortOrder
    tagId?: SortOrder
  }

  export type CourseTagAvgOrderByAggregateInput = {
    courseId?: SortOrder
    tagId?: SortOrder
  }

  export type CourseTagMaxOrderByAggregateInput = {
    courseId?: SortOrder
    tagId?: SortOrder
  }

  export type CourseTagMinOrderByAggregateInput = {
    courseId?: SortOrder
    tagId?: SortOrder
  }

  export type CourseTagSumOrderByAggregateInput = {
    courseId?: SortOrder
    tagId?: SortOrder
  }

  export type ContentTagContentIdTagIdCompoundUniqueInput = {
    contentId: number
    tagId: number
  }

  export type ContentTagCountOrderByAggregateInput = {
    contentId?: SortOrder
    tagId?: SortOrder
  }

  export type ContentTagAvgOrderByAggregateInput = {
    contentId?: SortOrder
    tagId?: SortOrder
  }

  export type ContentTagMaxOrderByAggregateInput = {
    contentId?: SortOrder
    tagId?: SortOrder
  }

  export type ContentTagMinOrderByAggregateInput = {
    contentId?: SortOrder
    tagId?: SortOrder
  }

  export type ContentTagSumOrderByAggregateInput = {
    contentId?: SortOrder
    tagId?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type CommentNullableRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    pid?: SortOrder
    userId?: SortOrder
    created?: SortOrder
    hands?: SortOrder
    status?: SortOrder
    isBest?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    id?: SortOrder
    pid?: SortOrder
    userId?: SortOrder
    hands?: SortOrder
    status?: SortOrder
    isBest?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    pid?: SortOrder
    userId?: SortOrder
    created?: SortOrder
    hands?: SortOrder
    status?: SortOrder
    isBest?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    pid?: SortOrder
    userId?: SortOrder
    created?: SortOrder
    hands?: SortOrder
    status?: SortOrder
    isBest?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    id?: SortOrder
    pid?: SortOrder
    userId?: SortOrder
    hands?: SortOrder
    status?: SortOrder
    isBest?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type CommentRelationFilter = {
    is?: CommentWhereInput
    isNot?: CommentWhereInput
  }

  export type CourseCommentCourseIdCommentIdCompoundUniqueInput = {
    courseId: number
    commentId: number
  }

  export type CourseCommentCountOrderByAggregateInput = {
    courseId?: SortOrder
    commentId?: SortOrder
  }

  export type CourseCommentAvgOrderByAggregateInput = {
    courseId?: SortOrder
    commentId?: SortOrder
  }

  export type CourseCommentMaxOrderByAggregateInput = {
    courseId?: SortOrder
    commentId?: SortOrder
  }

  export type CourseCommentMinOrderByAggregateInput = {
    courseId?: SortOrder
    commentId?: SortOrder
  }

  export type CourseCommentSumOrderByAggregateInput = {
    courseId?: SortOrder
    commentId?: SortOrder
  }

  export type ContentCommentCommentIdContentIdCompoundUniqueInput = {
    commentId: number
    contentId: number
  }

  export type ContentCommentCountOrderByAggregateInput = {
    contentId?: SortOrder
    commentId?: SortOrder
  }

  export type ContentCommentAvgOrderByAggregateInput = {
    contentId?: SortOrder
    commentId?: SortOrder
  }

  export type ContentCommentMaxOrderByAggregateInput = {
    contentId?: SortOrder
    commentId?: SortOrder
  }

  export type ContentCommentMinOrderByAggregateInput = {
    contentId?: SortOrder
    commentId?: SortOrder
  }

  export type ContentCommentSumOrderByAggregateInput = {
    contentId?: SortOrder
    commentId?: SortOrder
  }

  export type NoteCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    status?: SortOrder
  }

  export type NoteAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
  }

  export type NoteMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    status?: SortOrder
  }

  export type NoteMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    status?: SortOrder
  }

  export type NoteSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
  }

  export type DictPlatformCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
  }

  export type DictPlatformAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DictPlatformMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
  }

  export type DictPlatformMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
  }

  export type DictPlatformSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DictPlatformRelationFilter = {
    is?: DictPlatformWhereInput
    isNot?: DictPlatformWhereInput
  }

  export type GroupTransactionListRelationFilter = {
    every?: GroupTransactionWhereInput
    some?: GroupTransactionWhereInput
    none?: GroupTransactionWhereInput
  }

  export type GroupTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    platformId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    platformId?: SortOrder
    status?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    platformId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    platformId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    platformId?: SortOrder
    status?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type TransactionRelationFilter = {
    is?: TransactionWhereInput
    isNot?: TransactionWhereInput
  }

  export type GroupTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    transactionId?: SortOrder
  }

  export type GroupTransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
  }

  export type GroupTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    transactionId?: SortOrder
  }

  export type GroupTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    transactionId?: SortOrder
  }

  export type GroupTransactionSumOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
  }

  export type AuditStageListRelationFilter = {
    every?: AuditStageWhereInput
    some?: AuditStageWhereInput
    none?: AuditStageWhereInput
  }

  export type AuditStageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditFlowCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type AuditFlowAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AuditFlowMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type AuditFlowMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type AuditFlowSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AuditFlowRelationFilter = {
    is?: AuditFlowWhereInput
    isNot?: AuditFlowWhereInput
  }

  export type AuditStageNullableRelationFilter = {
    is?: AuditStageWhereInput | null
    isNot?: AuditStageWhereInput | null
  }

  export type AuditStageCountOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    pid?: SortOrder
  }

  export type AuditStageAvgOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    level?: SortOrder
    pid?: SortOrder
  }

  export type AuditStageMaxOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    pid?: SortOrder
  }

  export type AuditStageMinOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    pid?: SortOrder
  }

  export type AuditStageSumOrderByAggregateInput = {
    id?: SortOrder
    flowId?: SortOrder
    level?: SortOrder
    pid?: SortOrder
  }

  export type AuditStageRelationFilter = {
    is?: AuditStageWhereInput
    isNot?: AuditStageWhereInput
  }

  export type AuditRecordCountOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    stageId?: SortOrder
    status?: SortOrder
    reviewerId?: SortOrder
    createdAt?: SortOrder
    notes?: SortOrder
  }

  export type AuditRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
    stageId?: SortOrder
    reviewerId?: SortOrder
  }

  export type AuditRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    stageId?: SortOrder
    status?: SortOrder
    reviewerId?: SortOrder
    createdAt?: SortOrder
    notes?: SortOrder
  }

  export type AuditRecordMinOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    stageId?: SortOrder
    status?: SortOrder
    reviewerId?: SortOrder
    createdAt?: SortOrder
    notes?: SortOrder
  }

  export type AuditRecordSumOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
    stageId?: SortOrder
    reviewerId?: SortOrder
  }

  export type CouponListRelationFilter = {
    every?: CouponWhereInput
    some?: CouponWhereInput
    none?: CouponWhereInput
  }

  export type CouponOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DictCouponTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    desc?: SortOrder
  }

  export type DictCouponTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DictCouponTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    desc?: SortOrder
  }

  export type DictCouponTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    desc?: SortOrder
  }

  export type DictCouponTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DictCouponTypeRelationFilter = {
    is?: DictCouponTypeWhereInput
    isNot?: DictCouponTypeWhereInput
  }

  export type CouponCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    typeId?: SortOrder
    threshold?: SortOrder
    discount?: SortOrder
    validUntil?: SortOrder
    universal?: SortOrder
  }

  export type CouponAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    typeId?: SortOrder
    threshold?: SortOrder
    discount?: SortOrder
  }

  export type CouponMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    typeId?: SortOrder
    threshold?: SortOrder
    discount?: SortOrder
    validUntil?: SortOrder
    universal?: SortOrder
  }

  export type CouponMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    typeId?: SortOrder
    threshold?: SortOrder
    discount?: SortOrder
    validUntil?: SortOrder
    universal?: SortOrder
  }

  export type CouponSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    typeId?: SortOrder
    threshold?: SortOrder
    discount?: SortOrder
  }

  export type TransactionNullableRelationFilter = {
    is?: TransactionWhereInput | null
    isNot?: TransactionWhereInput | null
  }

  export type BalanceRecordCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type BalanceRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
  }

  export type BalanceRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type BalanceRecordMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type BalanceRecordSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type AttachmentCreateNestedManyWithoutUserInput = {
    create?: XOR<AttachmentCreateWithoutUserInput, AttachmentUncheckedCreateWithoutUserInput> | AttachmentCreateWithoutUserInput[] | AttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutUserInput | AttachmentCreateOrConnectWithoutUserInput[]
    createMany?: AttachmentCreateManyUserInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type CourseCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CourseCreateWithoutAuthorInput, CourseUncheckedCreateWithoutAuthorInput> | CourseCreateWithoutAuthorInput[] | CourseUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutAuthorInput | CourseCreateOrConnectWithoutAuthorInput[]
    createMany?: CourseCreateManyAuthorInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type CourseContentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CourseContentCreateWithoutAuthorInput, CourseContentUncheckedCreateWithoutAuthorInput> | CourseContentCreateWithoutAuthorInput[] | CourseContentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CourseContentCreateOrConnectWithoutAuthorInput | CourseContentCreateOrConnectWithoutAuthorInput[]
    createMany?: CourseContentCreateManyAuthorInputEnvelope
    connect?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type AuditRecordCreateNestedManyWithoutReviewerInput = {
    create?: XOR<AuditRecordCreateWithoutReviewerInput, AuditRecordUncheckedCreateWithoutReviewerInput> | AuditRecordCreateWithoutReviewerInput[] | AuditRecordUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: AuditRecordCreateOrConnectWithoutReviewerInput | AuditRecordCreateOrConnectWithoutReviewerInput[]
    createMany?: AuditRecordCreateManyReviewerInputEnvelope
    connect?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
  }

  export type BalanceRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<BalanceRecordCreateWithoutUserInput, BalanceRecordUncheckedCreateWithoutUserInput> | BalanceRecordCreateWithoutUserInput[] | BalanceRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BalanceRecordCreateOrConnectWithoutUserInput | BalanceRecordCreateOrConnectWithoutUserInput[]
    createMany?: BalanceRecordCreateManyUserInputEnvelope
    connect?: BalanceRecordWhereUniqueInput | BalanceRecordWhereUniqueInput[]
  }

  export type NoteCreateNestedManyWithoutUserInput = {
    create?: XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput> | NoteCreateWithoutUserInput[] | NoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutUserInput | NoteCreateOrConnectWithoutUserInput[]
    createMany?: NoteCreateManyUserInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AttachmentCreateWithoutUserInput, AttachmentUncheckedCreateWithoutUserInput> | AttachmentCreateWithoutUserInput[] | AttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutUserInput | AttachmentCreateOrConnectWithoutUserInput[]
    createMany?: AttachmentCreateManyUserInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CourseCreateWithoutAuthorInput, CourseUncheckedCreateWithoutAuthorInput> | CourseCreateWithoutAuthorInput[] | CourseUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutAuthorInput | CourseCreateOrConnectWithoutAuthorInput[]
    createMany?: CourseCreateManyAuthorInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type CourseContentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CourseContentCreateWithoutAuthorInput, CourseContentUncheckedCreateWithoutAuthorInput> | CourseContentCreateWithoutAuthorInput[] | CourseContentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CourseContentCreateOrConnectWithoutAuthorInput | CourseContentCreateOrConnectWithoutAuthorInput[]
    createMany?: CourseContentCreateManyAuthorInputEnvelope
    connect?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type AuditRecordUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<AuditRecordCreateWithoutReviewerInput, AuditRecordUncheckedCreateWithoutReviewerInput> | AuditRecordCreateWithoutReviewerInput[] | AuditRecordUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: AuditRecordCreateOrConnectWithoutReviewerInput | AuditRecordCreateOrConnectWithoutReviewerInput[]
    createMany?: AuditRecordCreateManyReviewerInputEnvelope
    connect?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
  }

  export type BalanceRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BalanceRecordCreateWithoutUserInput, BalanceRecordUncheckedCreateWithoutUserInput> | BalanceRecordCreateWithoutUserInput[] | BalanceRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BalanceRecordCreateOrConnectWithoutUserInput | BalanceRecordCreateOrConnectWithoutUserInput[]
    createMany?: BalanceRecordCreateManyUserInputEnvelope
    connect?: BalanceRecordWhereUniqueInput | BalanceRecordWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput> | NoteCreateWithoutUserInput[] | NoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutUserInput | NoteCreateOrConnectWithoutUserInput[]
    createMany?: NoteCreateManyUserInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type AttachmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttachmentCreateWithoutUserInput, AttachmentUncheckedCreateWithoutUserInput> | AttachmentCreateWithoutUserInput[] | AttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutUserInput | AttachmentCreateOrConnectWithoutUserInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutUserInput | AttachmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttachmentCreateManyUserInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutUserInput | AttachmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutUserInput | AttachmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type CourseUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CourseCreateWithoutAuthorInput, CourseUncheckedCreateWithoutAuthorInput> | CourseCreateWithoutAuthorInput[] | CourseUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutAuthorInput | CourseCreateOrConnectWithoutAuthorInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutAuthorInput | CourseUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CourseCreateManyAuthorInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutAuthorInput | CourseUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutAuthorInput | CourseUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type CourseContentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CourseContentCreateWithoutAuthorInput, CourseContentUncheckedCreateWithoutAuthorInput> | CourseContentCreateWithoutAuthorInput[] | CourseContentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CourseContentCreateOrConnectWithoutAuthorInput | CourseContentCreateOrConnectWithoutAuthorInput[]
    upsert?: CourseContentUpsertWithWhereUniqueWithoutAuthorInput | CourseContentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CourseContentCreateManyAuthorInputEnvelope
    set?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    disconnect?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    delete?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    connect?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    update?: CourseContentUpdateWithWhereUniqueWithoutAuthorInput | CourseContentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CourseContentUpdateManyWithWhereWithoutAuthorInput | CourseContentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CourseContentScalarWhereInput | CourseContentScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type AuditRecordUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<AuditRecordCreateWithoutReviewerInput, AuditRecordUncheckedCreateWithoutReviewerInput> | AuditRecordCreateWithoutReviewerInput[] | AuditRecordUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: AuditRecordCreateOrConnectWithoutReviewerInput | AuditRecordCreateOrConnectWithoutReviewerInput[]
    upsert?: AuditRecordUpsertWithWhereUniqueWithoutReviewerInput | AuditRecordUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: AuditRecordCreateManyReviewerInputEnvelope
    set?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    disconnect?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    delete?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    connect?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    update?: AuditRecordUpdateWithWhereUniqueWithoutReviewerInput | AuditRecordUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: AuditRecordUpdateManyWithWhereWithoutReviewerInput | AuditRecordUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: AuditRecordScalarWhereInput | AuditRecordScalarWhereInput[]
  }

  export type BalanceRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<BalanceRecordCreateWithoutUserInput, BalanceRecordUncheckedCreateWithoutUserInput> | BalanceRecordCreateWithoutUserInput[] | BalanceRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BalanceRecordCreateOrConnectWithoutUserInput | BalanceRecordCreateOrConnectWithoutUserInput[]
    upsert?: BalanceRecordUpsertWithWhereUniqueWithoutUserInput | BalanceRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BalanceRecordCreateManyUserInputEnvelope
    set?: BalanceRecordWhereUniqueInput | BalanceRecordWhereUniqueInput[]
    disconnect?: BalanceRecordWhereUniqueInput | BalanceRecordWhereUniqueInput[]
    delete?: BalanceRecordWhereUniqueInput | BalanceRecordWhereUniqueInput[]
    connect?: BalanceRecordWhereUniqueInput | BalanceRecordWhereUniqueInput[]
    update?: BalanceRecordUpdateWithWhereUniqueWithoutUserInput | BalanceRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BalanceRecordUpdateManyWithWhereWithoutUserInput | BalanceRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BalanceRecordScalarWhereInput | BalanceRecordScalarWhereInput[]
  }

  export type NoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput> | NoteCreateWithoutUserInput[] | NoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutUserInput | NoteCreateOrConnectWithoutUserInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutUserInput | NoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NoteCreateManyUserInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutUserInput | NoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutUserInput | NoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttachmentCreateWithoutUserInput, AttachmentUncheckedCreateWithoutUserInput> | AttachmentCreateWithoutUserInput[] | AttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutUserInput | AttachmentCreateOrConnectWithoutUserInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutUserInput | AttachmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttachmentCreateManyUserInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutUserInput | AttachmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutUserInput | AttachmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CourseCreateWithoutAuthorInput, CourseUncheckedCreateWithoutAuthorInput> | CourseCreateWithoutAuthorInput[] | CourseUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutAuthorInput | CourseCreateOrConnectWithoutAuthorInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutAuthorInput | CourseUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CourseCreateManyAuthorInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutAuthorInput | CourseUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutAuthorInput | CourseUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type CourseContentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CourseContentCreateWithoutAuthorInput, CourseContentUncheckedCreateWithoutAuthorInput> | CourseContentCreateWithoutAuthorInput[] | CourseContentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CourseContentCreateOrConnectWithoutAuthorInput | CourseContentCreateOrConnectWithoutAuthorInput[]
    upsert?: CourseContentUpsertWithWhereUniqueWithoutAuthorInput | CourseContentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CourseContentCreateManyAuthorInputEnvelope
    set?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    disconnect?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    delete?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    connect?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    update?: CourseContentUpdateWithWhereUniqueWithoutAuthorInput | CourseContentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CourseContentUpdateManyWithWhereWithoutAuthorInput | CourseContentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CourseContentScalarWhereInput | CourseContentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type AuditRecordUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<AuditRecordCreateWithoutReviewerInput, AuditRecordUncheckedCreateWithoutReviewerInput> | AuditRecordCreateWithoutReviewerInput[] | AuditRecordUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: AuditRecordCreateOrConnectWithoutReviewerInput | AuditRecordCreateOrConnectWithoutReviewerInput[]
    upsert?: AuditRecordUpsertWithWhereUniqueWithoutReviewerInput | AuditRecordUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: AuditRecordCreateManyReviewerInputEnvelope
    set?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    disconnect?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    delete?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    connect?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    update?: AuditRecordUpdateWithWhereUniqueWithoutReviewerInput | AuditRecordUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: AuditRecordUpdateManyWithWhereWithoutReviewerInput | AuditRecordUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: AuditRecordScalarWhereInput | AuditRecordScalarWhereInput[]
  }

  export type BalanceRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BalanceRecordCreateWithoutUserInput, BalanceRecordUncheckedCreateWithoutUserInput> | BalanceRecordCreateWithoutUserInput[] | BalanceRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BalanceRecordCreateOrConnectWithoutUserInput | BalanceRecordCreateOrConnectWithoutUserInput[]
    upsert?: BalanceRecordUpsertWithWhereUniqueWithoutUserInput | BalanceRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BalanceRecordCreateManyUserInputEnvelope
    set?: BalanceRecordWhereUniqueInput | BalanceRecordWhereUniqueInput[]
    disconnect?: BalanceRecordWhereUniqueInput | BalanceRecordWhereUniqueInput[]
    delete?: BalanceRecordWhereUniqueInput | BalanceRecordWhereUniqueInput[]
    connect?: BalanceRecordWhereUniqueInput | BalanceRecordWhereUniqueInput[]
    update?: BalanceRecordUpdateWithWhereUniqueWithoutUserInput | BalanceRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BalanceRecordUpdateManyWithWhereWithoutUserInput | BalanceRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BalanceRecordScalarWhereInput | BalanceRecordScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput> | NoteCreateWithoutUserInput[] | NoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutUserInput | NoteCreateOrConnectWithoutUserInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutUserInput | NoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NoteCreateManyUserInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutUserInput | NoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutUserInput | NoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type RolePermissionsCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionsCreateWithoutRoleInput, RolePermissionsUncheckedCreateWithoutRoleInput> | RolePermissionsCreateWithoutRoleInput[] | RolePermissionsUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionsCreateOrConnectWithoutRoleInput | RolePermissionsCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionsCreateManyRoleInputEnvelope
    connect?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
  }

  export type RolePolicyCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePolicyCreateWithoutRoleInput, RolePolicyUncheckedCreateWithoutRoleInput> | RolePolicyCreateWithoutRoleInput[] | RolePolicyUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePolicyCreateOrConnectWithoutRoleInput | RolePolicyCreateOrConnectWithoutRoleInput[]
    createMany?: RolePolicyCreateManyRoleInputEnvelope
    connect?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
  }

  export type RoleMenuCreateNestedManyWithoutRoleInput = {
    create?: XOR<RoleMenuCreateWithoutRoleInput, RoleMenuUncheckedCreateWithoutRoleInput> | RoleMenuCreateWithoutRoleInput[] | RoleMenuUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RoleMenuCreateOrConnectWithoutRoleInput | RoleMenuCreateOrConnectWithoutRoleInput[]
    createMany?: RoleMenuCreateManyRoleInputEnvelope
    connect?: RoleMenuWhereUniqueInput | RoleMenuWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type RolePermissionsUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionsCreateWithoutRoleInput, RolePermissionsUncheckedCreateWithoutRoleInput> | RolePermissionsCreateWithoutRoleInput[] | RolePermissionsUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionsCreateOrConnectWithoutRoleInput | RolePermissionsCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionsCreateManyRoleInputEnvelope
    connect?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
  }

  export type RolePolicyUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePolicyCreateWithoutRoleInput, RolePolicyUncheckedCreateWithoutRoleInput> | RolePolicyCreateWithoutRoleInput[] | RolePolicyUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePolicyCreateOrConnectWithoutRoleInput | RolePolicyCreateOrConnectWithoutRoleInput[]
    createMany?: RolePolicyCreateManyRoleInputEnvelope
    connect?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
  }

  export type RoleMenuUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RoleMenuCreateWithoutRoleInput, RoleMenuUncheckedCreateWithoutRoleInput> | RoleMenuCreateWithoutRoleInput[] | RoleMenuUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RoleMenuCreateOrConnectWithoutRoleInput | RoleMenuCreateOrConnectWithoutRoleInput[]
    createMany?: RoleMenuCreateManyRoleInputEnvelope
    connect?: RoleMenuWhereUniqueInput | RoleMenuWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type RolePermissionsUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionsCreateWithoutRoleInput, RolePermissionsUncheckedCreateWithoutRoleInput> | RolePermissionsCreateWithoutRoleInput[] | RolePermissionsUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionsCreateOrConnectWithoutRoleInput | RolePermissionsCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionsUpsertWithWhereUniqueWithoutRoleInput | RolePermissionsUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionsCreateManyRoleInputEnvelope
    set?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    disconnect?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    delete?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    connect?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    update?: RolePermissionsUpdateWithWhereUniqueWithoutRoleInput | RolePermissionsUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionsUpdateManyWithWhereWithoutRoleInput | RolePermissionsUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionsScalarWhereInput | RolePermissionsScalarWhereInput[]
  }

  export type RolePolicyUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePolicyCreateWithoutRoleInput, RolePolicyUncheckedCreateWithoutRoleInput> | RolePolicyCreateWithoutRoleInput[] | RolePolicyUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePolicyCreateOrConnectWithoutRoleInput | RolePolicyCreateOrConnectWithoutRoleInput[]
    upsert?: RolePolicyUpsertWithWhereUniqueWithoutRoleInput | RolePolicyUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePolicyCreateManyRoleInputEnvelope
    set?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    disconnect?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    delete?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    connect?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    update?: RolePolicyUpdateWithWhereUniqueWithoutRoleInput | RolePolicyUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePolicyUpdateManyWithWhereWithoutRoleInput | RolePolicyUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePolicyScalarWhereInput | RolePolicyScalarWhereInput[]
  }

  export type RoleMenuUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RoleMenuCreateWithoutRoleInput, RoleMenuUncheckedCreateWithoutRoleInput> | RoleMenuCreateWithoutRoleInput[] | RoleMenuUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RoleMenuCreateOrConnectWithoutRoleInput | RoleMenuCreateOrConnectWithoutRoleInput[]
    upsert?: RoleMenuUpsertWithWhereUniqueWithoutRoleInput | RoleMenuUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RoleMenuCreateManyRoleInputEnvelope
    set?: RoleMenuWhereUniqueInput | RoleMenuWhereUniqueInput[]
    disconnect?: RoleMenuWhereUniqueInput | RoleMenuWhereUniqueInput[]
    delete?: RoleMenuWhereUniqueInput | RoleMenuWhereUniqueInput[]
    connect?: RoleMenuWhereUniqueInput | RoleMenuWhereUniqueInput[]
    update?: RoleMenuUpdateWithWhereUniqueWithoutRoleInput | RoleMenuUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RoleMenuUpdateManyWithWhereWithoutRoleInput | RoleMenuUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RoleMenuScalarWhereInput | RoleMenuScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type RolePermissionsUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionsCreateWithoutRoleInput, RolePermissionsUncheckedCreateWithoutRoleInput> | RolePermissionsCreateWithoutRoleInput[] | RolePermissionsUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionsCreateOrConnectWithoutRoleInput | RolePermissionsCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionsUpsertWithWhereUniqueWithoutRoleInput | RolePermissionsUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionsCreateManyRoleInputEnvelope
    set?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    disconnect?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    delete?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    connect?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    update?: RolePermissionsUpdateWithWhereUniqueWithoutRoleInput | RolePermissionsUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionsUpdateManyWithWhereWithoutRoleInput | RolePermissionsUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionsScalarWhereInput | RolePermissionsScalarWhereInput[]
  }

  export type RolePolicyUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePolicyCreateWithoutRoleInput, RolePolicyUncheckedCreateWithoutRoleInput> | RolePolicyCreateWithoutRoleInput[] | RolePolicyUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePolicyCreateOrConnectWithoutRoleInput | RolePolicyCreateOrConnectWithoutRoleInput[]
    upsert?: RolePolicyUpsertWithWhereUniqueWithoutRoleInput | RolePolicyUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePolicyCreateManyRoleInputEnvelope
    set?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    disconnect?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    delete?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    connect?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    update?: RolePolicyUpdateWithWhereUniqueWithoutRoleInput | RolePolicyUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePolicyUpdateManyWithWhereWithoutRoleInput | RolePolicyUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePolicyScalarWhereInput | RolePolicyScalarWhereInput[]
  }

  export type RoleMenuUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RoleMenuCreateWithoutRoleInput, RoleMenuUncheckedCreateWithoutRoleInput> | RoleMenuCreateWithoutRoleInput[] | RoleMenuUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RoleMenuCreateOrConnectWithoutRoleInput | RoleMenuCreateOrConnectWithoutRoleInput[]
    upsert?: RoleMenuUpsertWithWhereUniqueWithoutRoleInput | RoleMenuUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RoleMenuCreateManyRoleInputEnvelope
    set?: RoleMenuWhereUniqueInput | RoleMenuWhereUniqueInput[]
    disconnect?: RoleMenuWhereUniqueInput | RoleMenuWhereUniqueInput[]
    delete?: RoleMenuWhereUniqueInput | RoleMenuWhereUniqueInput[]
    connect?: RoleMenuWhereUniqueInput | RoleMenuWhereUniqueInput[]
    update?: RoleMenuUpdateWithWhereUniqueWithoutRoleInput | RoleMenuUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RoleMenuUpdateManyWithWhereWithoutRoleInput | RoleMenuUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RoleMenuScalarWhereInput | RoleMenuScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserRoleInput = {
    create?: XOR<UserCreateWithoutUserRoleInput, UserUncheckedCreateWithoutUserRoleInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRoleInput
    connect?: UserWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutUserRoleNestedInput = {
    create?: XOR<UserCreateWithoutUserRoleInput, UserUncheckedCreateWithoutUserRoleInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRoleInput
    upsert?: UserUpsertWithoutUserRoleInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserRoleInput, UserUpdateWithoutUserRoleInput>, UserUncheckedUpdateWithoutUserRoleInput>
  }

  export type RolePermissionsCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionsCreateWithoutPermissionInput, RolePermissionsUncheckedCreateWithoutPermissionInput> | RolePermissionsCreateWithoutPermissionInput[] | RolePermissionsUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionsCreateOrConnectWithoutPermissionInput | RolePermissionsCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionsCreateManyPermissionInputEnvelope
    connect?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
  }

  export type PermissionPolicyCreateNestedManyWithoutPermissionInput = {
    create?: XOR<PermissionPolicyCreateWithoutPermissionInput, PermissionPolicyUncheckedCreateWithoutPermissionInput> | PermissionPolicyCreateWithoutPermissionInput[] | PermissionPolicyUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: PermissionPolicyCreateOrConnectWithoutPermissionInput | PermissionPolicyCreateOrConnectWithoutPermissionInput[]
    createMany?: PermissionPolicyCreateManyPermissionInputEnvelope
    connect?: PermissionPolicyWhereUniqueInput | PermissionPolicyWhereUniqueInput[]
  }

  export type RolePermissionsUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionsCreateWithoutPermissionInput, RolePermissionsUncheckedCreateWithoutPermissionInput> | RolePermissionsCreateWithoutPermissionInput[] | RolePermissionsUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionsCreateOrConnectWithoutPermissionInput | RolePermissionsCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionsCreateManyPermissionInputEnvelope
    connect?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
  }

  export type PermissionPolicyUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<PermissionPolicyCreateWithoutPermissionInput, PermissionPolicyUncheckedCreateWithoutPermissionInput> | PermissionPolicyCreateWithoutPermissionInput[] | PermissionPolicyUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: PermissionPolicyCreateOrConnectWithoutPermissionInput | PermissionPolicyCreateOrConnectWithoutPermissionInput[]
    createMany?: PermissionPolicyCreateManyPermissionInputEnvelope
    connect?: PermissionPolicyWhereUniqueInput | PermissionPolicyWhereUniqueInput[]
  }

  export type RolePermissionsUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionsCreateWithoutPermissionInput, RolePermissionsUncheckedCreateWithoutPermissionInput> | RolePermissionsCreateWithoutPermissionInput[] | RolePermissionsUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionsCreateOrConnectWithoutPermissionInput | RolePermissionsCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionsUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionsUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionsCreateManyPermissionInputEnvelope
    set?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    disconnect?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    delete?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    connect?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    update?: RolePermissionsUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionsUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionsUpdateManyWithWhereWithoutPermissionInput | RolePermissionsUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionsScalarWhereInput | RolePermissionsScalarWhereInput[]
  }

  export type PermissionPolicyUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<PermissionPolicyCreateWithoutPermissionInput, PermissionPolicyUncheckedCreateWithoutPermissionInput> | PermissionPolicyCreateWithoutPermissionInput[] | PermissionPolicyUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: PermissionPolicyCreateOrConnectWithoutPermissionInput | PermissionPolicyCreateOrConnectWithoutPermissionInput[]
    upsert?: PermissionPolicyUpsertWithWhereUniqueWithoutPermissionInput | PermissionPolicyUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: PermissionPolicyCreateManyPermissionInputEnvelope
    set?: PermissionPolicyWhereUniqueInput | PermissionPolicyWhereUniqueInput[]
    disconnect?: PermissionPolicyWhereUniqueInput | PermissionPolicyWhereUniqueInput[]
    delete?: PermissionPolicyWhereUniqueInput | PermissionPolicyWhereUniqueInput[]
    connect?: PermissionPolicyWhereUniqueInput | PermissionPolicyWhereUniqueInput[]
    update?: PermissionPolicyUpdateWithWhereUniqueWithoutPermissionInput | PermissionPolicyUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: PermissionPolicyUpdateManyWithWhereWithoutPermissionInput | PermissionPolicyUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: PermissionPolicyScalarWhereInput | PermissionPolicyScalarWhereInput[]
  }

  export type RolePermissionsUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionsCreateWithoutPermissionInput, RolePermissionsUncheckedCreateWithoutPermissionInput> | RolePermissionsCreateWithoutPermissionInput[] | RolePermissionsUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionsCreateOrConnectWithoutPermissionInput | RolePermissionsCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionsUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionsUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionsCreateManyPermissionInputEnvelope
    set?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    disconnect?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    delete?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    connect?: RolePermissionsWhereUniqueInput | RolePermissionsWhereUniqueInput[]
    update?: RolePermissionsUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionsUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionsUpdateManyWithWhereWithoutPermissionInput | RolePermissionsUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionsScalarWhereInput | RolePermissionsScalarWhereInput[]
  }

  export type PermissionPolicyUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<PermissionPolicyCreateWithoutPermissionInput, PermissionPolicyUncheckedCreateWithoutPermissionInput> | PermissionPolicyCreateWithoutPermissionInput[] | PermissionPolicyUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: PermissionPolicyCreateOrConnectWithoutPermissionInput | PermissionPolicyCreateOrConnectWithoutPermissionInput[]
    upsert?: PermissionPolicyUpsertWithWhereUniqueWithoutPermissionInput | PermissionPolicyUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: PermissionPolicyCreateManyPermissionInputEnvelope
    set?: PermissionPolicyWhereUniqueInput | PermissionPolicyWhereUniqueInput[]
    disconnect?: PermissionPolicyWhereUniqueInput | PermissionPolicyWhereUniqueInput[]
    delete?: PermissionPolicyWhereUniqueInput | PermissionPolicyWhereUniqueInput[]
    connect?: PermissionPolicyWhereUniqueInput | PermissionPolicyWhereUniqueInput[]
    update?: PermissionPolicyUpdateWithWhereUniqueWithoutPermissionInput | PermissionPolicyUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: PermissionPolicyUpdateManyWithWhereWithoutPermissionInput | PermissionPolicyUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: PermissionPolicyScalarWhereInput | PermissionPolicyScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutRolePermissionsInput = {
    create?: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRolePermissionsInput
    connect?: RoleWhereUniqueInput
  }

  export type PermissionCreateNestedOneWithoutRolePermissionsInput = {
    create?: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolePermissionsInput
    connect?: PermissionWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutRolePermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRolePermissionsInput
    upsert?: RoleUpsertWithoutRolePermissionsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutRolePermissionsInput, RoleUpdateWithoutRolePermissionsInput>, RoleUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput = {
    create?: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolePermissionsInput
    upsert?: PermissionUpsertWithoutRolePermissionsInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRolePermissionsInput, PermissionUpdateWithoutRolePermissionsInput>, PermissionUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type RolePolicyCreateNestedManyWithoutPolicyInput = {
    create?: XOR<RolePolicyCreateWithoutPolicyInput, RolePolicyUncheckedCreateWithoutPolicyInput> | RolePolicyCreateWithoutPolicyInput[] | RolePolicyUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: RolePolicyCreateOrConnectWithoutPolicyInput | RolePolicyCreateOrConnectWithoutPolicyInput[]
    createMany?: RolePolicyCreateManyPolicyInputEnvelope
    connect?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
  }

  export type PermissionPolicyCreateNestedManyWithoutPolicyInput = {
    create?: XOR<PermissionPolicyCreateWithoutPolicyInput, PermissionPolicyUncheckedCreateWithoutPolicyInput> | PermissionPolicyCreateWithoutPolicyInput[] | PermissionPolicyUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: PermissionPolicyCreateOrConnectWithoutPolicyInput | PermissionPolicyCreateOrConnectWithoutPolicyInput[]
    createMany?: PermissionPolicyCreateManyPolicyInputEnvelope
    connect?: PermissionPolicyWhereUniqueInput | PermissionPolicyWhereUniqueInput[]
  }

  export type RolePolicyUncheckedCreateNestedManyWithoutPolicyInput = {
    create?: XOR<RolePolicyCreateWithoutPolicyInput, RolePolicyUncheckedCreateWithoutPolicyInput> | RolePolicyCreateWithoutPolicyInput[] | RolePolicyUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: RolePolicyCreateOrConnectWithoutPolicyInput | RolePolicyCreateOrConnectWithoutPolicyInput[]
    createMany?: RolePolicyCreateManyPolicyInputEnvelope
    connect?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
  }

  export type PermissionPolicyUncheckedCreateNestedManyWithoutPolicyInput = {
    create?: XOR<PermissionPolicyCreateWithoutPolicyInput, PermissionPolicyUncheckedCreateWithoutPolicyInput> | PermissionPolicyCreateWithoutPolicyInput[] | PermissionPolicyUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: PermissionPolicyCreateOrConnectWithoutPolicyInput | PermissionPolicyCreateOrConnectWithoutPolicyInput[]
    createMany?: PermissionPolicyCreateManyPolicyInputEnvelope
    connect?: PermissionPolicyWhereUniqueInput | PermissionPolicyWhereUniqueInput[]
  }

  export type RolePolicyUpdateManyWithoutPolicyNestedInput = {
    create?: XOR<RolePolicyCreateWithoutPolicyInput, RolePolicyUncheckedCreateWithoutPolicyInput> | RolePolicyCreateWithoutPolicyInput[] | RolePolicyUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: RolePolicyCreateOrConnectWithoutPolicyInput | RolePolicyCreateOrConnectWithoutPolicyInput[]
    upsert?: RolePolicyUpsertWithWhereUniqueWithoutPolicyInput | RolePolicyUpsertWithWhereUniqueWithoutPolicyInput[]
    createMany?: RolePolicyCreateManyPolicyInputEnvelope
    set?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    disconnect?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    delete?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    connect?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    update?: RolePolicyUpdateWithWhereUniqueWithoutPolicyInput | RolePolicyUpdateWithWhereUniqueWithoutPolicyInput[]
    updateMany?: RolePolicyUpdateManyWithWhereWithoutPolicyInput | RolePolicyUpdateManyWithWhereWithoutPolicyInput[]
    deleteMany?: RolePolicyScalarWhereInput | RolePolicyScalarWhereInput[]
  }

  export type PermissionPolicyUpdateManyWithoutPolicyNestedInput = {
    create?: XOR<PermissionPolicyCreateWithoutPolicyInput, PermissionPolicyUncheckedCreateWithoutPolicyInput> | PermissionPolicyCreateWithoutPolicyInput[] | PermissionPolicyUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: PermissionPolicyCreateOrConnectWithoutPolicyInput | PermissionPolicyCreateOrConnectWithoutPolicyInput[]
    upsert?: PermissionPolicyUpsertWithWhereUniqueWithoutPolicyInput | PermissionPolicyUpsertWithWhereUniqueWithoutPolicyInput[]
    createMany?: PermissionPolicyCreateManyPolicyInputEnvelope
    set?: PermissionPolicyWhereUniqueInput | PermissionPolicyWhereUniqueInput[]
    disconnect?: PermissionPolicyWhereUniqueInput | PermissionPolicyWhereUniqueInput[]
    delete?: PermissionPolicyWhereUniqueInput | PermissionPolicyWhereUniqueInput[]
    connect?: PermissionPolicyWhereUniqueInput | PermissionPolicyWhereUniqueInput[]
    update?: PermissionPolicyUpdateWithWhereUniqueWithoutPolicyInput | PermissionPolicyUpdateWithWhereUniqueWithoutPolicyInput[]
    updateMany?: PermissionPolicyUpdateManyWithWhereWithoutPolicyInput | PermissionPolicyUpdateManyWithWhereWithoutPolicyInput[]
    deleteMany?: PermissionPolicyScalarWhereInput | PermissionPolicyScalarWhereInput[]
  }

  export type RolePolicyUncheckedUpdateManyWithoutPolicyNestedInput = {
    create?: XOR<RolePolicyCreateWithoutPolicyInput, RolePolicyUncheckedCreateWithoutPolicyInput> | RolePolicyCreateWithoutPolicyInput[] | RolePolicyUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: RolePolicyCreateOrConnectWithoutPolicyInput | RolePolicyCreateOrConnectWithoutPolicyInput[]
    upsert?: RolePolicyUpsertWithWhereUniqueWithoutPolicyInput | RolePolicyUpsertWithWhereUniqueWithoutPolicyInput[]
    createMany?: RolePolicyCreateManyPolicyInputEnvelope
    set?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    disconnect?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    delete?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    connect?: RolePolicyWhereUniqueInput | RolePolicyWhereUniqueInput[]
    update?: RolePolicyUpdateWithWhereUniqueWithoutPolicyInput | RolePolicyUpdateWithWhereUniqueWithoutPolicyInput[]
    updateMany?: RolePolicyUpdateManyWithWhereWithoutPolicyInput | RolePolicyUpdateManyWithWhereWithoutPolicyInput[]
    deleteMany?: RolePolicyScalarWhereInput | RolePolicyScalarWhereInput[]
  }

  export type PermissionPolicyUncheckedUpdateManyWithoutPolicyNestedInput = {
    create?: XOR<PermissionPolicyCreateWithoutPolicyInput, PermissionPolicyUncheckedCreateWithoutPolicyInput> | PermissionPolicyCreateWithoutPolicyInput[] | PermissionPolicyUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: PermissionPolicyCreateOrConnectWithoutPolicyInput | PermissionPolicyCreateOrConnectWithoutPolicyInput[]
    upsert?: PermissionPolicyUpsertWithWhereUniqueWithoutPolicyInput | PermissionPolicyUpsertWithWhereUniqueWithoutPolicyInput[]
    createMany?: PermissionPolicyCreateManyPolicyInputEnvelope
    set?: PermissionPolicyWhereUniqueInput | PermissionPolicyWhereUniqueInput[]
    disconnect?: PermissionPolicyWhereUniqueInput | PermissionPolicyWhereUniqueInput[]
    delete?: PermissionPolicyWhereUniqueInput | PermissionPolicyWhereUniqueInput[]
    connect?: PermissionPolicyWhereUniqueInput | PermissionPolicyWhereUniqueInput[]
    update?: PermissionPolicyUpdateWithWhereUniqueWithoutPolicyInput | PermissionPolicyUpdateWithWhereUniqueWithoutPolicyInput[]
    updateMany?: PermissionPolicyUpdateManyWithWhereWithoutPolicyInput | PermissionPolicyUpdateManyWithWhereWithoutPolicyInput[]
    deleteMany?: PermissionPolicyScalarWhereInput | PermissionPolicyScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutRolePolicyInput = {
    create?: XOR<RoleCreateWithoutRolePolicyInput, RoleUncheckedCreateWithoutRolePolicyInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRolePolicyInput
    connect?: RoleWhereUniqueInput
  }

  export type PolicyCreateNestedOneWithoutRolePolicyInput = {
    create?: XOR<PolicyCreateWithoutRolePolicyInput, PolicyUncheckedCreateWithoutRolePolicyInput>
    connectOrCreate?: PolicyCreateOrConnectWithoutRolePolicyInput
    connect?: PolicyWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutRolePolicyNestedInput = {
    create?: XOR<RoleCreateWithoutRolePolicyInput, RoleUncheckedCreateWithoutRolePolicyInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRolePolicyInput
    upsert?: RoleUpsertWithoutRolePolicyInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutRolePolicyInput, RoleUpdateWithoutRolePolicyInput>, RoleUncheckedUpdateWithoutRolePolicyInput>
  }

  export type PolicyUpdateOneRequiredWithoutRolePolicyNestedInput = {
    create?: XOR<PolicyCreateWithoutRolePolicyInput, PolicyUncheckedCreateWithoutRolePolicyInput>
    connectOrCreate?: PolicyCreateOrConnectWithoutRolePolicyInput
    upsert?: PolicyUpsertWithoutRolePolicyInput
    connect?: PolicyWhereUniqueInput
    update?: XOR<XOR<PolicyUpdateToOneWithWhereWithoutRolePolicyInput, PolicyUpdateWithoutRolePolicyInput>, PolicyUncheckedUpdateWithoutRolePolicyInput>
  }

  export type PermissionCreateNestedOneWithoutPermissionPolicyInput = {
    create?: XOR<PermissionCreateWithoutPermissionPolicyInput, PermissionUncheckedCreateWithoutPermissionPolicyInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutPermissionPolicyInput
    connect?: PermissionWhereUniqueInput
  }

  export type PolicyCreateNestedOneWithoutPermissionPolicyInput = {
    create?: XOR<PolicyCreateWithoutPermissionPolicyInput, PolicyUncheckedCreateWithoutPermissionPolicyInput>
    connectOrCreate?: PolicyCreateOrConnectWithoutPermissionPolicyInput
    connect?: PolicyWhereUniqueInput
  }

  export type PermissionUpdateOneRequiredWithoutPermissionPolicyNestedInput = {
    create?: XOR<PermissionCreateWithoutPermissionPolicyInput, PermissionUncheckedCreateWithoutPermissionPolicyInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutPermissionPolicyInput
    upsert?: PermissionUpsertWithoutPermissionPolicyInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutPermissionPolicyInput, PermissionUpdateWithoutPermissionPolicyInput>, PermissionUncheckedUpdateWithoutPermissionPolicyInput>
  }

  export type PolicyUpdateOneRequiredWithoutPermissionPolicyNestedInput = {
    create?: XOR<PolicyCreateWithoutPermissionPolicyInput, PolicyUncheckedCreateWithoutPermissionPolicyInput>
    connectOrCreate?: PolicyCreateOrConnectWithoutPermissionPolicyInput
    upsert?: PolicyUpsertWithoutPermissionPolicyInput
    connect?: PolicyWhereUniqueInput
    update?: XOR<XOR<PolicyUpdateToOneWithWhereWithoutPermissionPolicyInput, PolicyUpdateWithoutPermissionPolicyInput>, PolicyUncheckedUpdateWithoutPermissionPolicyInput>
  }

  export type MenuMetaCreateNestedOneWithoutMenuInput = {
    create?: XOR<MenuMetaCreateWithoutMenuInput, MenuMetaUncheckedCreateWithoutMenuInput>
    connectOrCreate?: MenuMetaCreateOrConnectWithoutMenuInput
    connect?: MenuMetaWhereUniqueInput
  }

  export type MenuCreateNestedOneWithoutChildrenInput = {
    create?: XOR<MenuCreateWithoutChildrenInput, MenuUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: MenuCreateOrConnectWithoutChildrenInput
    connect?: MenuWhereUniqueInput
  }

  export type MenuCreateNestedManyWithoutParentInput = {
    create?: XOR<MenuCreateWithoutParentInput, MenuUncheckedCreateWithoutParentInput> | MenuCreateWithoutParentInput[] | MenuUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutParentInput | MenuCreateOrConnectWithoutParentInput[]
    createMany?: MenuCreateManyParentInputEnvelope
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
  }

  export type RoleMenuCreateNestedManyWithoutMenuInput = {
    create?: XOR<RoleMenuCreateWithoutMenuInput, RoleMenuUncheckedCreateWithoutMenuInput> | RoleMenuCreateWithoutMenuInput[] | RoleMenuUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: RoleMenuCreateOrConnectWithoutMenuInput | RoleMenuCreateOrConnectWithoutMenuInput[]
    createMany?: RoleMenuCreateManyMenuInputEnvelope
    connect?: RoleMenuWhereUniqueInput | RoleMenuWhereUniqueInput[]
  }

  export type MenuMetaUncheckedCreateNestedOneWithoutMenuInput = {
    create?: XOR<MenuMetaCreateWithoutMenuInput, MenuMetaUncheckedCreateWithoutMenuInput>
    connectOrCreate?: MenuMetaCreateOrConnectWithoutMenuInput
    connect?: MenuMetaWhereUniqueInput
  }

  export type MenuUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<MenuCreateWithoutParentInput, MenuUncheckedCreateWithoutParentInput> | MenuCreateWithoutParentInput[] | MenuUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutParentInput | MenuCreateOrConnectWithoutParentInput[]
    createMany?: MenuCreateManyParentInputEnvelope
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
  }

  export type RoleMenuUncheckedCreateNestedManyWithoutMenuInput = {
    create?: XOR<RoleMenuCreateWithoutMenuInput, RoleMenuUncheckedCreateWithoutMenuInput> | RoleMenuCreateWithoutMenuInput[] | RoleMenuUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: RoleMenuCreateOrConnectWithoutMenuInput | RoleMenuCreateOrConnectWithoutMenuInput[]
    createMany?: RoleMenuCreateManyMenuInputEnvelope
    connect?: RoleMenuWhereUniqueInput | RoleMenuWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MenuMetaUpdateOneWithoutMenuNestedInput = {
    create?: XOR<MenuMetaCreateWithoutMenuInput, MenuMetaUncheckedCreateWithoutMenuInput>
    connectOrCreate?: MenuMetaCreateOrConnectWithoutMenuInput
    upsert?: MenuMetaUpsertWithoutMenuInput
    disconnect?: MenuMetaWhereInput | boolean
    delete?: MenuMetaWhereInput | boolean
    connect?: MenuMetaWhereUniqueInput
    update?: XOR<XOR<MenuMetaUpdateToOneWithWhereWithoutMenuInput, MenuMetaUpdateWithoutMenuInput>, MenuMetaUncheckedUpdateWithoutMenuInput>
  }

  export type MenuUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<MenuCreateWithoutChildrenInput, MenuUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: MenuCreateOrConnectWithoutChildrenInput
    upsert?: MenuUpsertWithoutChildrenInput
    disconnect?: MenuWhereInput | boolean
    delete?: MenuWhereInput | boolean
    connect?: MenuWhereUniqueInput
    update?: XOR<XOR<MenuUpdateToOneWithWhereWithoutChildrenInput, MenuUpdateWithoutChildrenInput>, MenuUncheckedUpdateWithoutChildrenInput>
  }

  export type MenuUpdateManyWithoutParentNestedInput = {
    create?: XOR<MenuCreateWithoutParentInput, MenuUncheckedCreateWithoutParentInput> | MenuCreateWithoutParentInput[] | MenuUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutParentInput | MenuCreateOrConnectWithoutParentInput[]
    upsert?: MenuUpsertWithWhereUniqueWithoutParentInput | MenuUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: MenuCreateManyParentInputEnvelope
    set?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    disconnect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    delete?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    update?: MenuUpdateWithWhereUniqueWithoutParentInput | MenuUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: MenuUpdateManyWithWhereWithoutParentInput | MenuUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: MenuScalarWhereInput | MenuScalarWhereInput[]
  }

  export type RoleMenuUpdateManyWithoutMenuNestedInput = {
    create?: XOR<RoleMenuCreateWithoutMenuInput, RoleMenuUncheckedCreateWithoutMenuInput> | RoleMenuCreateWithoutMenuInput[] | RoleMenuUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: RoleMenuCreateOrConnectWithoutMenuInput | RoleMenuCreateOrConnectWithoutMenuInput[]
    upsert?: RoleMenuUpsertWithWhereUniqueWithoutMenuInput | RoleMenuUpsertWithWhereUniqueWithoutMenuInput[]
    createMany?: RoleMenuCreateManyMenuInputEnvelope
    set?: RoleMenuWhereUniqueInput | RoleMenuWhereUniqueInput[]
    disconnect?: RoleMenuWhereUniqueInput | RoleMenuWhereUniqueInput[]
    delete?: RoleMenuWhereUniqueInput | RoleMenuWhereUniqueInput[]
    connect?: RoleMenuWhereUniqueInput | RoleMenuWhereUniqueInput[]
    update?: RoleMenuUpdateWithWhereUniqueWithoutMenuInput | RoleMenuUpdateWithWhereUniqueWithoutMenuInput[]
    updateMany?: RoleMenuUpdateManyWithWhereWithoutMenuInput | RoleMenuUpdateManyWithWhereWithoutMenuInput[]
    deleteMany?: RoleMenuScalarWhereInput | RoleMenuScalarWhereInput[]
  }

  export type MenuMetaUncheckedUpdateOneWithoutMenuNestedInput = {
    create?: XOR<MenuMetaCreateWithoutMenuInput, MenuMetaUncheckedCreateWithoutMenuInput>
    connectOrCreate?: MenuMetaCreateOrConnectWithoutMenuInput
    upsert?: MenuMetaUpsertWithoutMenuInput
    disconnect?: MenuMetaWhereInput | boolean
    delete?: MenuMetaWhereInput | boolean
    connect?: MenuMetaWhereUniqueInput
    update?: XOR<XOR<MenuMetaUpdateToOneWithWhereWithoutMenuInput, MenuMetaUpdateWithoutMenuInput>, MenuMetaUncheckedUpdateWithoutMenuInput>
  }

  export type MenuUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<MenuCreateWithoutParentInput, MenuUncheckedCreateWithoutParentInput> | MenuCreateWithoutParentInput[] | MenuUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutParentInput | MenuCreateOrConnectWithoutParentInput[]
    upsert?: MenuUpsertWithWhereUniqueWithoutParentInput | MenuUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: MenuCreateManyParentInputEnvelope
    set?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    disconnect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    delete?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    update?: MenuUpdateWithWhereUniqueWithoutParentInput | MenuUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: MenuUpdateManyWithWhereWithoutParentInput | MenuUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: MenuScalarWhereInput | MenuScalarWhereInput[]
  }

  export type RoleMenuUncheckedUpdateManyWithoutMenuNestedInput = {
    create?: XOR<RoleMenuCreateWithoutMenuInput, RoleMenuUncheckedCreateWithoutMenuInput> | RoleMenuCreateWithoutMenuInput[] | RoleMenuUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: RoleMenuCreateOrConnectWithoutMenuInput | RoleMenuCreateOrConnectWithoutMenuInput[]
    upsert?: RoleMenuUpsertWithWhereUniqueWithoutMenuInput | RoleMenuUpsertWithWhereUniqueWithoutMenuInput[]
    createMany?: RoleMenuCreateManyMenuInputEnvelope
    set?: RoleMenuWhereUniqueInput | RoleMenuWhereUniqueInput[]
    disconnect?: RoleMenuWhereUniqueInput | RoleMenuWhereUniqueInput[]
    delete?: RoleMenuWhereUniqueInput | RoleMenuWhereUniqueInput[]
    connect?: RoleMenuWhereUniqueInput | RoleMenuWhereUniqueInput[]
    update?: RoleMenuUpdateWithWhereUniqueWithoutMenuInput | RoleMenuUpdateWithWhereUniqueWithoutMenuInput[]
    updateMany?: RoleMenuUpdateManyWithWhereWithoutMenuInput | RoleMenuUpdateManyWithWhereWithoutMenuInput[]
    deleteMany?: RoleMenuScalarWhereInput | RoleMenuScalarWhereInput[]
  }

  export type MenuCreateNestedOneWithoutMetaInput = {
    create?: XOR<MenuCreateWithoutMetaInput, MenuUncheckedCreateWithoutMetaInput>
    connectOrCreate?: MenuCreateOrConnectWithoutMetaInput
    connect?: MenuWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type MenuUpdateOneRequiredWithoutMetaNestedInput = {
    create?: XOR<MenuCreateWithoutMetaInput, MenuUncheckedCreateWithoutMetaInput>
    connectOrCreate?: MenuCreateOrConnectWithoutMetaInput
    upsert?: MenuUpsertWithoutMetaInput
    connect?: MenuWhereUniqueInput
    update?: XOR<XOR<MenuUpdateToOneWithWhereWithoutMetaInput, MenuUpdateWithoutMetaInput>, MenuUncheckedUpdateWithoutMetaInput>
  }

  export type RoleCreateNestedOneWithoutRoleMenuInput = {
    create?: XOR<RoleCreateWithoutRoleMenuInput, RoleUncheckedCreateWithoutRoleMenuInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRoleMenuInput
    connect?: RoleWhereUniqueInput
  }

  export type MenuCreateNestedOneWithoutRoleMenusInput = {
    create?: XOR<MenuCreateWithoutRoleMenusInput, MenuUncheckedCreateWithoutRoleMenusInput>
    connectOrCreate?: MenuCreateOrConnectWithoutRoleMenusInput
    connect?: MenuWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutRoleMenuNestedInput = {
    create?: XOR<RoleCreateWithoutRoleMenuInput, RoleUncheckedCreateWithoutRoleMenuInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRoleMenuInput
    upsert?: RoleUpsertWithoutRoleMenuInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutRoleMenuInput, RoleUpdateWithoutRoleMenuInput>, RoleUncheckedUpdateWithoutRoleMenuInput>
  }

  export type MenuUpdateOneRequiredWithoutRoleMenusNestedInput = {
    create?: XOR<MenuCreateWithoutRoleMenusInput, MenuUncheckedCreateWithoutRoleMenusInput>
    connectOrCreate?: MenuCreateOrConnectWithoutRoleMenusInput
    upsert?: MenuUpsertWithoutRoleMenusInput
    connect?: MenuWhereUniqueInput
    update?: XOR<XOR<MenuUpdateToOneWithWhereWithoutRoleMenusInput, MenuUpdateWithoutRoleMenusInput>, MenuUncheckedUpdateWithoutRoleMenusInput>
  }

  export type AttachmentAttributeCreateNestedManyWithoutDictAttributeInput = {
    create?: XOR<AttachmentAttributeCreateWithoutDictAttributeInput, AttachmentAttributeUncheckedCreateWithoutDictAttributeInput> | AttachmentAttributeCreateWithoutDictAttributeInput[] | AttachmentAttributeUncheckedCreateWithoutDictAttributeInput[]
    connectOrCreate?: AttachmentAttributeCreateOrConnectWithoutDictAttributeInput | AttachmentAttributeCreateOrConnectWithoutDictAttributeInput[]
    createMany?: AttachmentAttributeCreateManyDictAttributeInputEnvelope
    connect?: AttachmentAttributeWhereUniqueInput | AttachmentAttributeWhereUniqueInput[]
  }

  export type AttachmentAttributeUncheckedCreateNestedManyWithoutDictAttributeInput = {
    create?: XOR<AttachmentAttributeCreateWithoutDictAttributeInput, AttachmentAttributeUncheckedCreateWithoutDictAttributeInput> | AttachmentAttributeCreateWithoutDictAttributeInput[] | AttachmentAttributeUncheckedCreateWithoutDictAttributeInput[]
    connectOrCreate?: AttachmentAttributeCreateOrConnectWithoutDictAttributeInput | AttachmentAttributeCreateOrConnectWithoutDictAttributeInput[]
    createMany?: AttachmentAttributeCreateManyDictAttributeInputEnvelope
    connect?: AttachmentAttributeWhereUniqueInput | AttachmentAttributeWhereUniqueInput[]
  }

  export type AttachmentAttributeUpdateManyWithoutDictAttributeNestedInput = {
    create?: XOR<AttachmentAttributeCreateWithoutDictAttributeInput, AttachmentAttributeUncheckedCreateWithoutDictAttributeInput> | AttachmentAttributeCreateWithoutDictAttributeInput[] | AttachmentAttributeUncheckedCreateWithoutDictAttributeInput[]
    connectOrCreate?: AttachmentAttributeCreateOrConnectWithoutDictAttributeInput | AttachmentAttributeCreateOrConnectWithoutDictAttributeInput[]
    upsert?: AttachmentAttributeUpsertWithWhereUniqueWithoutDictAttributeInput | AttachmentAttributeUpsertWithWhereUniqueWithoutDictAttributeInput[]
    createMany?: AttachmentAttributeCreateManyDictAttributeInputEnvelope
    set?: AttachmentAttributeWhereUniqueInput | AttachmentAttributeWhereUniqueInput[]
    disconnect?: AttachmentAttributeWhereUniqueInput | AttachmentAttributeWhereUniqueInput[]
    delete?: AttachmentAttributeWhereUniqueInput | AttachmentAttributeWhereUniqueInput[]
    connect?: AttachmentAttributeWhereUniqueInput | AttachmentAttributeWhereUniqueInput[]
    update?: AttachmentAttributeUpdateWithWhereUniqueWithoutDictAttributeInput | AttachmentAttributeUpdateWithWhereUniqueWithoutDictAttributeInput[]
    updateMany?: AttachmentAttributeUpdateManyWithWhereWithoutDictAttributeInput | AttachmentAttributeUpdateManyWithWhereWithoutDictAttributeInput[]
    deleteMany?: AttachmentAttributeScalarWhereInput | AttachmentAttributeScalarWhereInput[]
  }

  export type AttachmentAttributeUncheckedUpdateManyWithoutDictAttributeNestedInput = {
    create?: XOR<AttachmentAttributeCreateWithoutDictAttributeInput, AttachmentAttributeUncheckedCreateWithoutDictAttributeInput> | AttachmentAttributeCreateWithoutDictAttributeInput[] | AttachmentAttributeUncheckedCreateWithoutDictAttributeInput[]
    connectOrCreate?: AttachmentAttributeCreateOrConnectWithoutDictAttributeInput | AttachmentAttributeCreateOrConnectWithoutDictAttributeInput[]
    upsert?: AttachmentAttributeUpsertWithWhereUniqueWithoutDictAttributeInput | AttachmentAttributeUpsertWithWhereUniqueWithoutDictAttributeInput[]
    createMany?: AttachmentAttributeCreateManyDictAttributeInputEnvelope
    set?: AttachmentAttributeWhereUniqueInput | AttachmentAttributeWhereUniqueInput[]
    disconnect?: AttachmentAttributeWhereUniqueInput | AttachmentAttributeWhereUniqueInput[]
    delete?: AttachmentAttributeWhereUniqueInput | AttachmentAttributeWhereUniqueInput[]
    connect?: AttachmentAttributeWhereUniqueInput | AttachmentAttributeWhereUniqueInput[]
    update?: AttachmentAttributeUpdateWithWhereUniqueWithoutDictAttributeInput | AttachmentAttributeUpdateWithWhereUniqueWithoutDictAttributeInput[]
    updateMany?: AttachmentAttributeUpdateManyWithWhereWithoutDictAttributeInput | AttachmentAttributeUpdateManyWithWhereWithoutDictAttributeInput[]
    deleteMany?: AttachmentAttributeScalarWhereInput | AttachmentAttributeScalarWhereInput[]
  }

  export type AttachmentCreateNestedOneWithoutAttachmentAttributeInput = {
    create?: XOR<AttachmentCreateWithoutAttachmentAttributeInput, AttachmentUncheckedCreateWithoutAttachmentAttributeInput>
    connectOrCreate?: AttachmentCreateOrConnectWithoutAttachmentAttributeInput
    connect?: AttachmentWhereUniqueInput
  }

  export type DictAttachmentAttributeCreateNestedOneWithoutAttachmentAttributeInput = {
    create?: XOR<DictAttachmentAttributeCreateWithoutAttachmentAttributeInput, DictAttachmentAttributeUncheckedCreateWithoutAttachmentAttributeInput>
    connectOrCreate?: DictAttachmentAttributeCreateOrConnectWithoutAttachmentAttributeInput
    connect?: DictAttachmentAttributeWhereUniqueInput
  }

  export type AttachmentUpdateOneRequiredWithoutAttachmentAttributeNestedInput = {
    create?: XOR<AttachmentCreateWithoutAttachmentAttributeInput, AttachmentUncheckedCreateWithoutAttachmentAttributeInput>
    connectOrCreate?: AttachmentCreateOrConnectWithoutAttachmentAttributeInput
    upsert?: AttachmentUpsertWithoutAttachmentAttributeInput
    connect?: AttachmentWhereUniqueInput
    update?: XOR<XOR<AttachmentUpdateToOneWithWhereWithoutAttachmentAttributeInput, AttachmentUpdateWithoutAttachmentAttributeInput>, AttachmentUncheckedUpdateWithoutAttachmentAttributeInput>
  }

  export type DictAttachmentAttributeUpdateOneRequiredWithoutAttachmentAttributeNestedInput = {
    create?: XOR<DictAttachmentAttributeCreateWithoutAttachmentAttributeInput, DictAttachmentAttributeUncheckedCreateWithoutAttachmentAttributeInput>
    connectOrCreate?: DictAttachmentAttributeCreateOrConnectWithoutAttachmentAttributeInput
    upsert?: DictAttachmentAttributeUpsertWithoutAttachmentAttributeInput
    connect?: DictAttachmentAttributeWhereUniqueInput
    update?: XOR<XOR<DictAttachmentAttributeUpdateToOneWithWhereWithoutAttachmentAttributeInput, DictAttachmentAttributeUpdateWithoutAttachmentAttributeInput>, DictAttachmentAttributeUncheckedUpdateWithoutAttachmentAttributeInput>
  }

  export type UserCreateNestedOneWithoutAttachmentInput = {
    create?: XOR<UserCreateWithoutAttachmentInput, UserUncheckedCreateWithoutAttachmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttachmentInput
    connect?: UserWhereUniqueInput
  }

  export type AttachmentAttributeCreateNestedManyWithoutAttachmentInput = {
    create?: XOR<AttachmentAttributeCreateWithoutAttachmentInput, AttachmentAttributeUncheckedCreateWithoutAttachmentInput> | AttachmentAttributeCreateWithoutAttachmentInput[] | AttachmentAttributeUncheckedCreateWithoutAttachmentInput[]
    connectOrCreate?: AttachmentAttributeCreateOrConnectWithoutAttachmentInput | AttachmentAttributeCreateOrConnectWithoutAttachmentInput[]
    createMany?: AttachmentAttributeCreateManyAttachmentInputEnvelope
    connect?: AttachmentAttributeWhereUniqueInput | AttachmentAttributeWhereUniqueInput[]
  }

  export type CourseCreateNestedManyWithoutCoverInput = {
    create?: XOR<CourseCreateWithoutCoverInput, CourseUncheckedCreateWithoutCoverInput> | CourseCreateWithoutCoverInput[] | CourseUncheckedCreateWithoutCoverInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCoverInput | CourseCreateOrConnectWithoutCoverInput[]
    createMany?: CourseCreateManyCoverInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type ContentAttachmentCreateNestedManyWithoutAttachmentInput = {
    create?: XOR<ContentAttachmentCreateWithoutAttachmentInput, ContentAttachmentUncheckedCreateWithoutAttachmentInput> | ContentAttachmentCreateWithoutAttachmentInput[] | ContentAttachmentUncheckedCreateWithoutAttachmentInput[]
    connectOrCreate?: ContentAttachmentCreateOrConnectWithoutAttachmentInput | ContentAttachmentCreateOrConnectWithoutAttachmentInput[]
    createMany?: ContentAttachmentCreateManyAttachmentInputEnvelope
    connect?: ContentAttachmentWhereUniqueInput | ContentAttachmentWhereUniqueInput[]
  }

  export type AttachmentAttributeUncheckedCreateNestedManyWithoutAttachmentInput = {
    create?: XOR<AttachmentAttributeCreateWithoutAttachmentInput, AttachmentAttributeUncheckedCreateWithoutAttachmentInput> | AttachmentAttributeCreateWithoutAttachmentInput[] | AttachmentAttributeUncheckedCreateWithoutAttachmentInput[]
    connectOrCreate?: AttachmentAttributeCreateOrConnectWithoutAttachmentInput | AttachmentAttributeCreateOrConnectWithoutAttachmentInput[]
    createMany?: AttachmentAttributeCreateManyAttachmentInputEnvelope
    connect?: AttachmentAttributeWhereUniqueInput | AttachmentAttributeWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutCoverInput = {
    create?: XOR<CourseCreateWithoutCoverInput, CourseUncheckedCreateWithoutCoverInput> | CourseCreateWithoutCoverInput[] | CourseUncheckedCreateWithoutCoverInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCoverInput | CourseCreateOrConnectWithoutCoverInput[]
    createMany?: CourseCreateManyCoverInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type ContentAttachmentUncheckedCreateNestedManyWithoutAttachmentInput = {
    create?: XOR<ContentAttachmentCreateWithoutAttachmentInput, ContentAttachmentUncheckedCreateWithoutAttachmentInput> | ContentAttachmentCreateWithoutAttachmentInput[] | ContentAttachmentUncheckedCreateWithoutAttachmentInput[]
    connectOrCreate?: ContentAttachmentCreateOrConnectWithoutAttachmentInput | ContentAttachmentCreateOrConnectWithoutAttachmentInput[]
    createMany?: ContentAttachmentCreateManyAttachmentInputEnvelope
    connect?: ContentAttachmentWhereUniqueInput | ContentAttachmentWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutAttachmentNestedInput = {
    create?: XOR<UserCreateWithoutAttachmentInput, UserUncheckedCreateWithoutAttachmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttachmentInput
    upsert?: UserUpsertWithoutAttachmentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttachmentInput, UserUpdateWithoutAttachmentInput>, UserUncheckedUpdateWithoutAttachmentInput>
  }

  export type AttachmentAttributeUpdateManyWithoutAttachmentNestedInput = {
    create?: XOR<AttachmentAttributeCreateWithoutAttachmentInput, AttachmentAttributeUncheckedCreateWithoutAttachmentInput> | AttachmentAttributeCreateWithoutAttachmentInput[] | AttachmentAttributeUncheckedCreateWithoutAttachmentInput[]
    connectOrCreate?: AttachmentAttributeCreateOrConnectWithoutAttachmentInput | AttachmentAttributeCreateOrConnectWithoutAttachmentInput[]
    upsert?: AttachmentAttributeUpsertWithWhereUniqueWithoutAttachmentInput | AttachmentAttributeUpsertWithWhereUniqueWithoutAttachmentInput[]
    createMany?: AttachmentAttributeCreateManyAttachmentInputEnvelope
    set?: AttachmentAttributeWhereUniqueInput | AttachmentAttributeWhereUniqueInput[]
    disconnect?: AttachmentAttributeWhereUniqueInput | AttachmentAttributeWhereUniqueInput[]
    delete?: AttachmentAttributeWhereUniqueInput | AttachmentAttributeWhereUniqueInput[]
    connect?: AttachmentAttributeWhereUniqueInput | AttachmentAttributeWhereUniqueInput[]
    update?: AttachmentAttributeUpdateWithWhereUniqueWithoutAttachmentInput | AttachmentAttributeUpdateWithWhereUniqueWithoutAttachmentInput[]
    updateMany?: AttachmentAttributeUpdateManyWithWhereWithoutAttachmentInput | AttachmentAttributeUpdateManyWithWhereWithoutAttachmentInput[]
    deleteMany?: AttachmentAttributeScalarWhereInput | AttachmentAttributeScalarWhereInput[]
  }

  export type CourseUpdateManyWithoutCoverNestedInput = {
    create?: XOR<CourseCreateWithoutCoverInput, CourseUncheckedCreateWithoutCoverInput> | CourseCreateWithoutCoverInput[] | CourseUncheckedCreateWithoutCoverInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCoverInput | CourseCreateOrConnectWithoutCoverInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCoverInput | CourseUpsertWithWhereUniqueWithoutCoverInput[]
    createMany?: CourseCreateManyCoverInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCoverInput | CourseUpdateWithWhereUniqueWithoutCoverInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCoverInput | CourseUpdateManyWithWhereWithoutCoverInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type ContentAttachmentUpdateManyWithoutAttachmentNestedInput = {
    create?: XOR<ContentAttachmentCreateWithoutAttachmentInput, ContentAttachmentUncheckedCreateWithoutAttachmentInput> | ContentAttachmentCreateWithoutAttachmentInput[] | ContentAttachmentUncheckedCreateWithoutAttachmentInput[]
    connectOrCreate?: ContentAttachmentCreateOrConnectWithoutAttachmentInput | ContentAttachmentCreateOrConnectWithoutAttachmentInput[]
    upsert?: ContentAttachmentUpsertWithWhereUniqueWithoutAttachmentInput | ContentAttachmentUpsertWithWhereUniqueWithoutAttachmentInput[]
    createMany?: ContentAttachmentCreateManyAttachmentInputEnvelope
    set?: ContentAttachmentWhereUniqueInput | ContentAttachmentWhereUniqueInput[]
    disconnect?: ContentAttachmentWhereUniqueInput | ContentAttachmentWhereUniqueInput[]
    delete?: ContentAttachmentWhereUniqueInput | ContentAttachmentWhereUniqueInput[]
    connect?: ContentAttachmentWhereUniqueInput | ContentAttachmentWhereUniqueInput[]
    update?: ContentAttachmentUpdateWithWhereUniqueWithoutAttachmentInput | ContentAttachmentUpdateWithWhereUniqueWithoutAttachmentInput[]
    updateMany?: ContentAttachmentUpdateManyWithWhereWithoutAttachmentInput | ContentAttachmentUpdateManyWithWhereWithoutAttachmentInput[]
    deleteMany?: ContentAttachmentScalarWhereInput | ContentAttachmentScalarWhereInput[]
  }

  export type AttachmentAttributeUncheckedUpdateManyWithoutAttachmentNestedInput = {
    create?: XOR<AttachmentAttributeCreateWithoutAttachmentInput, AttachmentAttributeUncheckedCreateWithoutAttachmentInput> | AttachmentAttributeCreateWithoutAttachmentInput[] | AttachmentAttributeUncheckedCreateWithoutAttachmentInput[]
    connectOrCreate?: AttachmentAttributeCreateOrConnectWithoutAttachmentInput | AttachmentAttributeCreateOrConnectWithoutAttachmentInput[]
    upsert?: AttachmentAttributeUpsertWithWhereUniqueWithoutAttachmentInput | AttachmentAttributeUpsertWithWhereUniqueWithoutAttachmentInput[]
    createMany?: AttachmentAttributeCreateManyAttachmentInputEnvelope
    set?: AttachmentAttributeWhereUniqueInput | AttachmentAttributeWhereUniqueInput[]
    disconnect?: AttachmentAttributeWhereUniqueInput | AttachmentAttributeWhereUniqueInput[]
    delete?: AttachmentAttributeWhereUniqueInput | AttachmentAttributeWhereUniqueInput[]
    connect?: AttachmentAttributeWhereUniqueInput | AttachmentAttributeWhereUniqueInput[]
    update?: AttachmentAttributeUpdateWithWhereUniqueWithoutAttachmentInput | AttachmentAttributeUpdateWithWhereUniqueWithoutAttachmentInput[]
    updateMany?: AttachmentAttributeUpdateManyWithWhereWithoutAttachmentInput | AttachmentAttributeUpdateManyWithWhereWithoutAttachmentInput[]
    deleteMany?: AttachmentAttributeScalarWhereInput | AttachmentAttributeScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutCoverNestedInput = {
    create?: XOR<CourseCreateWithoutCoverInput, CourseUncheckedCreateWithoutCoverInput> | CourseCreateWithoutCoverInput[] | CourseUncheckedCreateWithoutCoverInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCoverInput | CourseCreateOrConnectWithoutCoverInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCoverInput | CourseUpsertWithWhereUniqueWithoutCoverInput[]
    createMany?: CourseCreateManyCoverInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCoverInput | CourseUpdateWithWhereUniqueWithoutCoverInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCoverInput | CourseUpdateManyWithWhereWithoutCoverInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type ContentAttachmentUncheckedUpdateManyWithoutAttachmentNestedInput = {
    create?: XOR<ContentAttachmentCreateWithoutAttachmentInput, ContentAttachmentUncheckedCreateWithoutAttachmentInput> | ContentAttachmentCreateWithoutAttachmentInput[] | ContentAttachmentUncheckedCreateWithoutAttachmentInput[]
    connectOrCreate?: ContentAttachmentCreateOrConnectWithoutAttachmentInput | ContentAttachmentCreateOrConnectWithoutAttachmentInput[]
    upsert?: ContentAttachmentUpsertWithWhereUniqueWithoutAttachmentInput | ContentAttachmentUpsertWithWhereUniqueWithoutAttachmentInput[]
    createMany?: ContentAttachmentCreateManyAttachmentInputEnvelope
    set?: ContentAttachmentWhereUniqueInput | ContentAttachmentWhereUniqueInput[]
    disconnect?: ContentAttachmentWhereUniqueInput | ContentAttachmentWhereUniqueInput[]
    delete?: ContentAttachmentWhereUniqueInput | ContentAttachmentWhereUniqueInput[]
    connect?: ContentAttachmentWhereUniqueInput | ContentAttachmentWhereUniqueInput[]
    update?: ContentAttachmentUpdateWithWhereUniqueWithoutAttachmentInput | ContentAttachmentUpdateWithWhereUniqueWithoutAttachmentInput[]
    updateMany?: ContentAttachmentUpdateManyWithWhereWithoutAttachmentInput | ContentAttachmentUpdateManyWithWhereWithoutAttachmentInput[]
    deleteMany?: ContentAttachmentScalarWhereInput | ContentAttachmentScalarWhereInput[]
  }

  export type AttachmentCreateNestedOneWithoutCourseInput = {
    create?: XOR<AttachmentCreateWithoutCourseInput, AttachmentUncheckedCreateWithoutCourseInput>
    connectOrCreate?: AttachmentCreateOrConnectWithoutCourseInput
    connect?: AttachmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCourseInput = {
    create?: XOR<UserCreateWithoutCourseInput, UserUncheckedCreateWithoutCourseInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourseInput
    connect?: UserWhereUniqueInput
  }

  export type CourseContentCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseContentCreateWithoutCourseInput, CourseContentUncheckedCreateWithoutCourseInput> | CourseContentCreateWithoutCourseInput[] | CourseContentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseContentCreateOrConnectWithoutCourseInput | CourseContentCreateOrConnectWithoutCourseInput[]
    createMany?: CourseContentCreateManyCourseInputEnvelope
    connect?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
  }

  export type CourseTagCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseTagCreateWithoutCourseInput, CourseTagUncheckedCreateWithoutCourseInput> | CourseTagCreateWithoutCourseInput[] | CourseTagUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseTagCreateOrConnectWithoutCourseInput | CourseTagCreateOrConnectWithoutCourseInput[]
    createMany?: CourseTagCreateManyCourseInputEnvelope
    connect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
  }

  export type CourseCommentCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseCommentCreateWithoutCourseInput, CourseCommentUncheckedCreateWithoutCourseInput> | CourseCommentCreateWithoutCourseInput[] | CourseCommentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseCommentCreateOrConnectWithoutCourseInput | CourseCommentCreateOrConnectWithoutCourseInput[]
    createMany?: CourseCommentCreateManyCourseInputEnvelope
    connect?: CourseCommentWhereUniqueInput | CourseCommentWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutCourseInput = {
    create?: XOR<TransactionCreateWithoutCourseInput, TransactionUncheckedCreateWithoutCourseInput> | TransactionCreateWithoutCourseInput[] | TransactionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCourseInput | TransactionCreateOrConnectWithoutCourseInput[]
    createMany?: TransactionCreateManyCourseInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type CourseContentUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseContentCreateWithoutCourseInput, CourseContentUncheckedCreateWithoutCourseInput> | CourseContentCreateWithoutCourseInput[] | CourseContentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseContentCreateOrConnectWithoutCourseInput | CourseContentCreateOrConnectWithoutCourseInput[]
    createMany?: CourseContentCreateManyCourseInputEnvelope
    connect?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
  }

  export type CourseTagUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseTagCreateWithoutCourseInput, CourseTagUncheckedCreateWithoutCourseInput> | CourseTagCreateWithoutCourseInput[] | CourseTagUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseTagCreateOrConnectWithoutCourseInput | CourseTagCreateOrConnectWithoutCourseInput[]
    createMany?: CourseTagCreateManyCourseInputEnvelope
    connect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
  }

  export type CourseCommentUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseCommentCreateWithoutCourseInput, CourseCommentUncheckedCreateWithoutCourseInput> | CourseCommentCreateWithoutCourseInput[] | CourseCommentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseCommentCreateOrConnectWithoutCourseInput | CourseCommentCreateOrConnectWithoutCourseInput[]
    createMany?: CourseCommentCreateManyCourseInputEnvelope
    connect?: CourseCommentWhereUniqueInput | CourseCommentWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<TransactionCreateWithoutCourseInput, TransactionUncheckedCreateWithoutCourseInput> | TransactionCreateWithoutCourseInput[] | TransactionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCourseInput | TransactionCreateOrConnectWithoutCourseInput[]
    createMany?: TransactionCreateManyCourseInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AttachmentUpdateOneWithoutCourseNestedInput = {
    create?: XOR<AttachmentCreateWithoutCourseInput, AttachmentUncheckedCreateWithoutCourseInput>
    connectOrCreate?: AttachmentCreateOrConnectWithoutCourseInput
    upsert?: AttachmentUpsertWithoutCourseInput
    disconnect?: AttachmentWhereInput | boolean
    delete?: AttachmentWhereInput | boolean
    connect?: AttachmentWhereUniqueInput
    update?: XOR<XOR<AttachmentUpdateToOneWithWhereWithoutCourseInput, AttachmentUpdateWithoutCourseInput>, AttachmentUncheckedUpdateWithoutCourseInput>
  }

  export type UserUpdateOneRequiredWithoutCourseNestedInput = {
    create?: XOR<UserCreateWithoutCourseInput, UserUncheckedCreateWithoutCourseInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourseInput
    upsert?: UserUpsertWithoutCourseInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCourseInput, UserUpdateWithoutCourseInput>, UserUncheckedUpdateWithoutCourseInput>
  }

  export type CourseContentUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseContentCreateWithoutCourseInput, CourseContentUncheckedCreateWithoutCourseInput> | CourseContentCreateWithoutCourseInput[] | CourseContentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseContentCreateOrConnectWithoutCourseInput | CourseContentCreateOrConnectWithoutCourseInput[]
    upsert?: CourseContentUpsertWithWhereUniqueWithoutCourseInput | CourseContentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseContentCreateManyCourseInputEnvelope
    set?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    disconnect?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    delete?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    connect?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    update?: CourseContentUpdateWithWhereUniqueWithoutCourseInput | CourseContentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseContentUpdateManyWithWhereWithoutCourseInput | CourseContentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseContentScalarWhereInput | CourseContentScalarWhereInput[]
  }

  export type CourseTagUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseTagCreateWithoutCourseInput, CourseTagUncheckedCreateWithoutCourseInput> | CourseTagCreateWithoutCourseInput[] | CourseTagUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseTagCreateOrConnectWithoutCourseInput | CourseTagCreateOrConnectWithoutCourseInput[]
    upsert?: CourseTagUpsertWithWhereUniqueWithoutCourseInput | CourseTagUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseTagCreateManyCourseInputEnvelope
    set?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    disconnect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    delete?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    connect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    update?: CourseTagUpdateWithWhereUniqueWithoutCourseInput | CourseTagUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseTagUpdateManyWithWhereWithoutCourseInput | CourseTagUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseTagScalarWhereInput | CourseTagScalarWhereInput[]
  }

  export type CourseCommentUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseCommentCreateWithoutCourseInput, CourseCommentUncheckedCreateWithoutCourseInput> | CourseCommentCreateWithoutCourseInput[] | CourseCommentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseCommentCreateOrConnectWithoutCourseInput | CourseCommentCreateOrConnectWithoutCourseInput[]
    upsert?: CourseCommentUpsertWithWhereUniqueWithoutCourseInput | CourseCommentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseCommentCreateManyCourseInputEnvelope
    set?: CourseCommentWhereUniqueInput | CourseCommentWhereUniqueInput[]
    disconnect?: CourseCommentWhereUniqueInput | CourseCommentWhereUniqueInput[]
    delete?: CourseCommentWhereUniqueInput | CourseCommentWhereUniqueInput[]
    connect?: CourseCommentWhereUniqueInput | CourseCommentWhereUniqueInput[]
    update?: CourseCommentUpdateWithWhereUniqueWithoutCourseInput | CourseCommentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseCommentUpdateManyWithWhereWithoutCourseInput | CourseCommentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseCommentScalarWhereInput | CourseCommentScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutCourseNestedInput = {
    create?: XOR<TransactionCreateWithoutCourseInput, TransactionUncheckedCreateWithoutCourseInput> | TransactionCreateWithoutCourseInput[] | TransactionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCourseInput | TransactionCreateOrConnectWithoutCourseInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCourseInput | TransactionUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: TransactionCreateManyCourseInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCourseInput | TransactionUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCourseInput | TransactionUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type CourseContentUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseContentCreateWithoutCourseInput, CourseContentUncheckedCreateWithoutCourseInput> | CourseContentCreateWithoutCourseInput[] | CourseContentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseContentCreateOrConnectWithoutCourseInput | CourseContentCreateOrConnectWithoutCourseInput[]
    upsert?: CourseContentUpsertWithWhereUniqueWithoutCourseInput | CourseContentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseContentCreateManyCourseInputEnvelope
    set?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    disconnect?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    delete?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    connect?: CourseContentWhereUniqueInput | CourseContentWhereUniqueInput[]
    update?: CourseContentUpdateWithWhereUniqueWithoutCourseInput | CourseContentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseContentUpdateManyWithWhereWithoutCourseInput | CourseContentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseContentScalarWhereInput | CourseContentScalarWhereInput[]
  }

  export type CourseTagUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseTagCreateWithoutCourseInput, CourseTagUncheckedCreateWithoutCourseInput> | CourseTagCreateWithoutCourseInput[] | CourseTagUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseTagCreateOrConnectWithoutCourseInput | CourseTagCreateOrConnectWithoutCourseInput[]
    upsert?: CourseTagUpsertWithWhereUniqueWithoutCourseInput | CourseTagUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseTagCreateManyCourseInputEnvelope
    set?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    disconnect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    delete?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    connect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    update?: CourseTagUpdateWithWhereUniqueWithoutCourseInput | CourseTagUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseTagUpdateManyWithWhereWithoutCourseInput | CourseTagUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseTagScalarWhereInput | CourseTagScalarWhereInput[]
  }

  export type CourseCommentUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseCommentCreateWithoutCourseInput, CourseCommentUncheckedCreateWithoutCourseInput> | CourseCommentCreateWithoutCourseInput[] | CourseCommentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseCommentCreateOrConnectWithoutCourseInput | CourseCommentCreateOrConnectWithoutCourseInput[]
    upsert?: CourseCommentUpsertWithWhereUniqueWithoutCourseInput | CourseCommentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseCommentCreateManyCourseInputEnvelope
    set?: CourseCommentWhereUniqueInput | CourseCommentWhereUniqueInput[]
    disconnect?: CourseCommentWhereUniqueInput | CourseCommentWhereUniqueInput[]
    delete?: CourseCommentWhereUniqueInput | CourseCommentWhereUniqueInput[]
    connect?: CourseCommentWhereUniqueInput | CourseCommentWhereUniqueInput[]
    update?: CourseCommentUpdateWithWhereUniqueWithoutCourseInput | CourseCommentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseCommentUpdateManyWithWhereWithoutCourseInput | CourseCommentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseCommentScalarWhereInput | CourseCommentScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<TransactionCreateWithoutCourseInput, TransactionUncheckedCreateWithoutCourseInput> | TransactionCreateWithoutCourseInput[] | TransactionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCourseInput | TransactionCreateOrConnectWithoutCourseInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCourseInput | TransactionUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: TransactionCreateManyCourseInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCourseInput | TransactionUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCourseInput | TransactionUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutContentsInput = {
    create?: XOR<CourseCreateWithoutContentsInput, CourseUncheckedCreateWithoutContentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutContentsInput
    connect?: CourseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCourseContentInput = {
    create?: XOR<UserCreateWithoutCourseContentInput, UserUncheckedCreateWithoutCourseContentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourseContentInput
    connect?: UserWhereUniqueInput
  }

  export type ContentAttachmentCreateNestedManyWithoutContentInput = {
    create?: XOR<ContentAttachmentCreateWithoutContentInput, ContentAttachmentUncheckedCreateWithoutContentInput> | ContentAttachmentCreateWithoutContentInput[] | ContentAttachmentUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentAttachmentCreateOrConnectWithoutContentInput | ContentAttachmentCreateOrConnectWithoutContentInput[]
    createMany?: ContentAttachmentCreateManyContentInputEnvelope
    connect?: ContentAttachmentWhereUniqueInput | ContentAttachmentWhereUniqueInput[]
  }

  export type ContentTagCreateNestedManyWithoutContentInput = {
    create?: XOR<ContentTagCreateWithoutContentInput, ContentTagUncheckedCreateWithoutContentInput> | ContentTagCreateWithoutContentInput[] | ContentTagUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentTagCreateOrConnectWithoutContentInput | ContentTagCreateOrConnectWithoutContentInput[]
    createMany?: ContentTagCreateManyContentInputEnvelope
    connect?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
  }

  export type ContentCommentCreateNestedManyWithoutContentInput = {
    create?: XOR<ContentCommentCreateWithoutContentInput, ContentCommentUncheckedCreateWithoutContentInput> | ContentCommentCreateWithoutContentInput[] | ContentCommentUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentCommentCreateOrConnectWithoutContentInput | ContentCommentCreateOrConnectWithoutContentInput[]
    createMany?: ContentCommentCreateManyContentInputEnvelope
    connect?: ContentCommentWhereUniqueInput | ContentCommentWhereUniqueInput[]
  }

  export type ContentAttachmentUncheckedCreateNestedManyWithoutContentInput = {
    create?: XOR<ContentAttachmentCreateWithoutContentInput, ContentAttachmentUncheckedCreateWithoutContentInput> | ContentAttachmentCreateWithoutContentInput[] | ContentAttachmentUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentAttachmentCreateOrConnectWithoutContentInput | ContentAttachmentCreateOrConnectWithoutContentInput[]
    createMany?: ContentAttachmentCreateManyContentInputEnvelope
    connect?: ContentAttachmentWhereUniqueInput | ContentAttachmentWhereUniqueInput[]
  }

  export type ContentTagUncheckedCreateNestedManyWithoutContentInput = {
    create?: XOR<ContentTagCreateWithoutContentInput, ContentTagUncheckedCreateWithoutContentInput> | ContentTagCreateWithoutContentInput[] | ContentTagUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentTagCreateOrConnectWithoutContentInput | ContentTagCreateOrConnectWithoutContentInput[]
    createMany?: ContentTagCreateManyContentInputEnvelope
    connect?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
  }

  export type ContentCommentUncheckedCreateNestedManyWithoutContentInput = {
    create?: XOR<ContentCommentCreateWithoutContentInput, ContentCommentUncheckedCreateWithoutContentInput> | ContentCommentCreateWithoutContentInput[] | ContentCommentUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentCommentCreateOrConnectWithoutContentInput | ContentCommentCreateOrConnectWithoutContentInput[]
    createMany?: ContentCommentCreateManyContentInputEnvelope
    connect?: ContentCommentWhereUniqueInput | ContentCommentWhereUniqueInput[]
  }

  export type CourseUpdateOneRequiredWithoutContentsNestedInput = {
    create?: XOR<CourseCreateWithoutContentsInput, CourseUncheckedCreateWithoutContentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutContentsInput
    upsert?: CourseUpsertWithoutContentsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutContentsInput, CourseUpdateWithoutContentsInput>, CourseUncheckedUpdateWithoutContentsInput>
  }

  export type UserUpdateOneRequiredWithoutCourseContentNestedInput = {
    create?: XOR<UserCreateWithoutCourseContentInput, UserUncheckedCreateWithoutCourseContentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourseContentInput
    upsert?: UserUpsertWithoutCourseContentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCourseContentInput, UserUpdateWithoutCourseContentInput>, UserUncheckedUpdateWithoutCourseContentInput>
  }

  export type ContentAttachmentUpdateManyWithoutContentNestedInput = {
    create?: XOR<ContentAttachmentCreateWithoutContentInput, ContentAttachmentUncheckedCreateWithoutContentInput> | ContentAttachmentCreateWithoutContentInput[] | ContentAttachmentUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentAttachmentCreateOrConnectWithoutContentInput | ContentAttachmentCreateOrConnectWithoutContentInput[]
    upsert?: ContentAttachmentUpsertWithWhereUniqueWithoutContentInput | ContentAttachmentUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: ContentAttachmentCreateManyContentInputEnvelope
    set?: ContentAttachmentWhereUniqueInput | ContentAttachmentWhereUniqueInput[]
    disconnect?: ContentAttachmentWhereUniqueInput | ContentAttachmentWhereUniqueInput[]
    delete?: ContentAttachmentWhereUniqueInput | ContentAttachmentWhereUniqueInput[]
    connect?: ContentAttachmentWhereUniqueInput | ContentAttachmentWhereUniqueInput[]
    update?: ContentAttachmentUpdateWithWhereUniqueWithoutContentInput | ContentAttachmentUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: ContentAttachmentUpdateManyWithWhereWithoutContentInput | ContentAttachmentUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: ContentAttachmentScalarWhereInput | ContentAttachmentScalarWhereInput[]
  }

  export type ContentTagUpdateManyWithoutContentNestedInput = {
    create?: XOR<ContentTagCreateWithoutContentInput, ContentTagUncheckedCreateWithoutContentInput> | ContentTagCreateWithoutContentInput[] | ContentTagUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentTagCreateOrConnectWithoutContentInput | ContentTagCreateOrConnectWithoutContentInput[]
    upsert?: ContentTagUpsertWithWhereUniqueWithoutContentInput | ContentTagUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: ContentTagCreateManyContentInputEnvelope
    set?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    disconnect?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    delete?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    connect?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    update?: ContentTagUpdateWithWhereUniqueWithoutContentInput | ContentTagUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: ContentTagUpdateManyWithWhereWithoutContentInput | ContentTagUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: ContentTagScalarWhereInput | ContentTagScalarWhereInput[]
  }

  export type ContentCommentUpdateManyWithoutContentNestedInput = {
    create?: XOR<ContentCommentCreateWithoutContentInput, ContentCommentUncheckedCreateWithoutContentInput> | ContentCommentCreateWithoutContentInput[] | ContentCommentUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentCommentCreateOrConnectWithoutContentInput | ContentCommentCreateOrConnectWithoutContentInput[]
    upsert?: ContentCommentUpsertWithWhereUniqueWithoutContentInput | ContentCommentUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: ContentCommentCreateManyContentInputEnvelope
    set?: ContentCommentWhereUniqueInput | ContentCommentWhereUniqueInput[]
    disconnect?: ContentCommentWhereUniqueInput | ContentCommentWhereUniqueInput[]
    delete?: ContentCommentWhereUniqueInput | ContentCommentWhereUniqueInput[]
    connect?: ContentCommentWhereUniqueInput | ContentCommentWhereUniqueInput[]
    update?: ContentCommentUpdateWithWhereUniqueWithoutContentInput | ContentCommentUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: ContentCommentUpdateManyWithWhereWithoutContentInput | ContentCommentUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: ContentCommentScalarWhereInput | ContentCommentScalarWhereInput[]
  }

  export type ContentAttachmentUncheckedUpdateManyWithoutContentNestedInput = {
    create?: XOR<ContentAttachmentCreateWithoutContentInput, ContentAttachmentUncheckedCreateWithoutContentInput> | ContentAttachmentCreateWithoutContentInput[] | ContentAttachmentUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentAttachmentCreateOrConnectWithoutContentInput | ContentAttachmentCreateOrConnectWithoutContentInput[]
    upsert?: ContentAttachmentUpsertWithWhereUniqueWithoutContentInput | ContentAttachmentUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: ContentAttachmentCreateManyContentInputEnvelope
    set?: ContentAttachmentWhereUniqueInput | ContentAttachmentWhereUniqueInput[]
    disconnect?: ContentAttachmentWhereUniqueInput | ContentAttachmentWhereUniqueInput[]
    delete?: ContentAttachmentWhereUniqueInput | ContentAttachmentWhereUniqueInput[]
    connect?: ContentAttachmentWhereUniqueInput | ContentAttachmentWhereUniqueInput[]
    update?: ContentAttachmentUpdateWithWhereUniqueWithoutContentInput | ContentAttachmentUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: ContentAttachmentUpdateManyWithWhereWithoutContentInput | ContentAttachmentUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: ContentAttachmentScalarWhereInput | ContentAttachmentScalarWhereInput[]
  }

  export type ContentTagUncheckedUpdateManyWithoutContentNestedInput = {
    create?: XOR<ContentTagCreateWithoutContentInput, ContentTagUncheckedCreateWithoutContentInput> | ContentTagCreateWithoutContentInput[] | ContentTagUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentTagCreateOrConnectWithoutContentInput | ContentTagCreateOrConnectWithoutContentInput[]
    upsert?: ContentTagUpsertWithWhereUniqueWithoutContentInput | ContentTagUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: ContentTagCreateManyContentInputEnvelope
    set?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    disconnect?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    delete?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    connect?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    update?: ContentTagUpdateWithWhereUniqueWithoutContentInput | ContentTagUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: ContentTagUpdateManyWithWhereWithoutContentInput | ContentTagUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: ContentTagScalarWhereInput | ContentTagScalarWhereInput[]
  }

  export type ContentCommentUncheckedUpdateManyWithoutContentNestedInput = {
    create?: XOR<ContentCommentCreateWithoutContentInput, ContentCommentUncheckedCreateWithoutContentInput> | ContentCommentCreateWithoutContentInput[] | ContentCommentUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentCommentCreateOrConnectWithoutContentInput | ContentCommentCreateOrConnectWithoutContentInput[]
    upsert?: ContentCommentUpsertWithWhereUniqueWithoutContentInput | ContentCommentUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: ContentCommentCreateManyContentInputEnvelope
    set?: ContentCommentWhereUniqueInput | ContentCommentWhereUniqueInput[]
    disconnect?: ContentCommentWhereUniqueInput | ContentCommentWhereUniqueInput[]
    delete?: ContentCommentWhereUniqueInput | ContentCommentWhereUniqueInput[]
    connect?: ContentCommentWhereUniqueInput | ContentCommentWhereUniqueInput[]
    update?: ContentCommentUpdateWithWhereUniqueWithoutContentInput | ContentCommentUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: ContentCommentUpdateManyWithWhereWithoutContentInput | ContentCommentUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: ContentCommentScalarWhereInput | ContentCommentScalarWhereInput[]
  }

  export type CourseContentCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<CourseContentCreateWithoutAttachmentsInput, CourseContentUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: CourseContentCreateOrConnectWithoutAttachmentsInput
    connect?: CourseContentWhereUniqueInput
  }

  export type AttachmentCreateNestedOneWithoutContentAttachmentInput = {
    create?: XOR<AttachmentCreateWithoutContentAttachmentInput, AttachmentUncheckedCreateWithoutContentAttachmentInput>
    connectOrCreate?: AttachmentCreateOrConnectWithoutContentAttachmentInput
    connect?: AttachmentWhereUniqueInput
  }

  export type CourseContentUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<CourseContentCreateWithoutAttachmentsInput, CourseContentUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: CourseContentCreateOrConnectWithoutAttachmentsInput
    upsert?: CourseContentUpsertWithoutAttachmentsInput
    connect?: CourseContentWhereUniqueInput
    update?: XOR<XOR<CourseContentUpdateToOneWithWhereWithoutAttachmentsInput, CourseContentUpdateWithoutAttachmentsInput>, CourseContentUncheckedUpdateWithoutAttachmentsInput>
  }

  export type AttachmentUpdateOneRequiredWithoutContentAttachmentNestedInput = {
    create?: XOR<AttachmentCreateWithoutContentAttachmentInput, AttachmentUncheckedCreateWithoutContentAttachmentInput>
    connectOrCreate?: AttachmentCreateOrConnectWithoutContentAttachmentInput
    upsert?: AttachmentUpsertWithoutContentAttachmentInput
    connect?: AttachmentWhereUniqueInput
    update?: XOR<XOR<AttachmentUpdateToOneWithWhereWithoutContentAttachmentInput, AttachmentUpdateWithoutContentAttachmentInput>, AttachmentUncheckedUpdateWithoutContentAttachmentInput>
  }

  export type DictCourseTypeCreateNestedOneWithoutCourseTagsInput = {
    create?: XOR<DictCourseTypeCreateWithoutCourseTagsInput, DictCourseTypeUncheckedCreateWithoutCourseTagsInput>
    connectOrCreate?: DictCourseTypeCreateOrConnectWithoutCourseTagsInput
    connect?: DictCourseTypeWhereUniqueInput
  }

  export type CourseTagCreateNestedManyWithoutTagInput = {
    create?: XOR<CourseTagCreateWithoutTagInput, CourseTagUncheckedCreateWithoutTagInput> | CourseTagCreateWithoutTagInput[] | CourseTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: CourseTagCreateOrConnectWithoutTagInput | CourseTagCreateOrConnectWithoutTagInput[]
    createMany?: CourseTagCreateManyTagInputEnvelope
    connect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
  }

  export type ContentTagCreateNestedManyWithoutTagInput = {
    create?: XOR<ContentTagCreateWithoutTagInput, ContentTagUncheckedCreateWithoutTagInput> | ContentTagCreateWithoutTagInput[] | ContentTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ContentTagCreateOrConnectWithoutTagInput | ContentTagCreateOrConnectWithoutTagInput[]
    createMany?: ContentTagCreateManyTagInputEnvelope
    connect?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
  }

  export type CourseTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<CourseTagCreateWithoutTagInput, CourseTagUncheckedCreateWithoutTagInput> | CourseTagCreateWithoutTagInput[] | CourseTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: CourseTagCreateOrConnectWithoutTagInput | CourseTagCreateOrConnectWithoutTagInput[]
    createMany?: CourseTagCreateManyTagInputEnvelope
    connect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
  }

  export type ContentTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<ContentTagCreateWithoutTagInput, ContentTagUncheckedCreateWithoutTagInput> | ContentTagCreateWithoutTagInput[] | ContentTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ContentTagCreateOrConnectWithoutTagInput | ContentTagCreateOrConnectWithoutTagInput[]
    createMany?: ContentTagCreateManyTagInputEnvelope
    connect?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
  }

  export type DictCourseTypeUpdateOneWithoutCourseTagsNestedInput = {
    create?: XOR<DictCourseTypeCreateWithoutCourseTagsInput, DictCourseTypeUncheckedCreateWithoutCourseTagsInput>
    connectOrCreate?: DictCourseTypeCreateOrConnectWithoutCourseTagsInput
    upsert?: DictCourseTypeUpsertWithoutCourseTagsInput
    disconnect?: DictCourseTypeWhereInput | boolean
    delete?: DictCourseTypeWhereInput | boolean
    connect?: DictCourseTypeWhereUniqueInput
    update?: XOR<XOR<DictCourseTypeUpdateToOneWithWhereWithoutCourseTagsInput, DictCourseTypeUpdateWithoutCourseTagsInput>, DictCourseTypeUncheckedUpdateWithoutCourseTagsInput>
  }

  export type CourseTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<CourseTagCreateWithoutTagInput, CourseTagUncheckedCreateWithoutTagInput> | CourseTagCreateWithoutTagInput[] | CourseTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: CourseTagCreateOrConnectWithoutTagInput | CourseTagCreateOrConnectWithoutTagInput[]
    upsert?: CourseTagUpsertWithWhereUniqueWithoutTagInput | CourseTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: CourseTagCreateManyTagInputEnvelope
    set?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    disconnect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    delete?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    connect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    update?: CourseTagUpdateWithWhereUniqueWithoutTagInput | CourseTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: CourseTagUpdateManyWithWhereWithoutTagInput | CourseTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: CourseTagScalarWhereInput | CourseTagScalarWhereInput[]
  }

  export type ContentTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<ContentTagCreateWithoutTagInput, ContentTagUncheckedCreateWithoutTagInput> | ContentTagCreateWithoutTagInput[] | ContentTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ContentTagCreateOrConnectWithoutTagInput | ContentTagCreateOrConnectWithoutTagInput[]
    upsert?: ContentTagUpsertWithWhereUniqueWithoutTagInput | ContentTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: ContentTagCreateManyTagInputEnvelope
    set?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    disconnect?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    delete?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    connect?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    update?: ContentTagUpdateWithWhereUniqueWithoutTagInput | ContentTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: ContentTagUpdateManyWithWhereWithoutTagInput | ContentTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: ContentTagScalarWhereInput | ContentTagScalarWhereInput[]
  }

  export type CourseTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<CourseTagCreateWithoutTagInput, CourseTagUncheckedCreateWithoutTagInput> | CourseTagCreateWithoutTagInput[] | CourseTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: CourseTagCreateOrConnectWithoutTagInput | CourseTagCreateOrConnectWithoutTagInput[]
    upsert?: CourseTagUpsertWithWhereUniqueWithoutTagInput | CourseTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: CourseTagCreateManyTagInputEnvelope
    set?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    disconnect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    delete?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    connect?: CourseTagWhereUniqueInput | CourseTagWhereUniqueInput[]
    update?: CourseTagUpdateWithWhereUniqueWithoutTagInput | CourseTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: CourseTagUpdateManyWithWhereWithoutTagInput | CourseTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: CourseTagScalarWhereInput | CourseTagScalarWhereInput[]
  }

  export type ContentTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<ContentTagCreateWithoutTagInput, ContentTagUncheckedCreateWithoutTagInput> | ContentTagCreateWithoutTagInput[] | ContentTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ContentTagCreateOrConnectWithoutTagInput | ContentTagCreateOrConnectWithoutTagInput[]
    upsert?: ContentTagUpsertWithWhereUniqueWithoutTagInput | ContentTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: ContentTagCreateManyTagInputEnvelope
    set?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    disconnect?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    delete?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    connect?: ContentTagWhereUniqueInput | ContentTagWhereUniqueInput[]
    update?: ContentTagUpdateWithWhereUniqueWithoutTagInput | ContentTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: ContentTagUpdateManyWithWhereWithoutTagInput | ContentTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: ContentTagScalarWhereInput | ContentTagScalarWhereInput[]
  }

  export type DictCourseTagCreateNestedManyWithoutCourseTypeInput = {
    create?: XOR<DictCourseTagCreateWithoutCourseTypeInput, DictCourseTagUncheckedCreateWithoutCourseTypeInput> | DictCourseTagCreateWithoutCourseTypeInput[] | DictCourseTagUncheckedCreateWithoutCourseTypeInput[]
    connectOrCreate?: DictCourseTagCreateOrConnectWithoutCourseTypeInput | DictCourseTagCreateOrConnectWithoutCourseTypeInput[]
    createMany?: DictCourseTagCreateManyCourseTypeInputEnvelope
    connect?: DictCourseTagWhereUniqueInput | DictCourseTagWhereUniqueInput[]
  }

  export type DictCourseTagUncheckedCreateNestedManyWithoutCourseTypeInput = {
    create?: XOR<DictCourseTagCreateWithoutCourseTypeInput, DictCourseTagUncheckedCreateWithoutCourseTypeInput> | DictCourseTagCreateWithoutCourseTypeInput[] | DictCourseTagUncheckedCreateWithoutCourseTypeInput[]
    connectOrCreate?: DictCourseTagCreateOrConnectWithoutCourseTypeInput | DictCourseTagCreateOrConnectWithoutCourseTypeInput[]
    createMany?: DictCourseTagCreateManyCourseTypeInputEnvelope
    connect?: DictCourseTagWhereUniqueInput | DictCourseTagWhereUniqueInput[]
  }

  export type DictCourseTagUpdateManyWithoutCourseTypeNestedInput = {
    create?: XOR<DictCourseTagCreateWithoutCourseTypeInput, DictCourseTagUncheckedCreateWithoutCourseTypeInput> | DictCourseTagCreateWithoutCourseTypeInput[] | DictCourseTagUncheckedCreateWithoutCourseTypeInput[]
    connectOrCreate?: DictCourseTagCreateOrConnectWithoutCourseTypeInput | DictCourseTagCreateOrConnectWithoutCourseTypeInput[]
    upsert?: DictCourseTagUpsertWithWhereUniqueWithoutCourseTypeInput | DictCourseTagUpsertWithWhereUniqueWithoutCourseTypeInput[]
    createMany?: DictCourseTagCreateManyCourseTypeInputEnvelope
    set?: DictCourseTagWhereUniqueInput | DictCourseTagWhereUniqueInput[]
    disconnect?: DictCourseTagWhereUniqueInput | DictCourseTagWhereUniqueInput[]
    delete?: DictCourseTagWhereUniqueInput | DictCourseTagWhereUniqueInput[]
    connect?: DictCourseTagWhereUniqueInput | DictCourseTagWhereUniqueInput[]
    update?: DictCourseTagUpdateWithWhereUniqueWithoutCourseTypeInput | DictCourseTagUpdateWithWhereUniqueWithoutCourseTypeInput[]
    updateMany?: DictCourseTagUpdateManyWithWhereWithoutCourseTypeInput | DictCourseTagUpdateManyWithWhereWithoutCourseTypeInput[]
    deleteMany?: DictCourseTagScalarWhereInput | DictCourseTagScalarWhereInput[]
  }

  export type DictCourseTagUncheckedUpdateManyWithoutCourseTypeNestedInput = {
    create?: XOR<DictCourseTagCreateWithoutCourseTypeInput, DictCourseTagUncheckedCreateWithoutCourseTypeInput> | DictCourseTagCreateWithoutCourseTypeInput[] | DictCourseTagUncheckedCreateWithoutCourseTypeInput[]
    connectOrCreate?: DictCourseTagCreateOrConnectWithoutCourseTypeInput | DictCourseTagCreateOrConnectWithoutCourseTypeInput[]
    upsert?: DictCourseTagUpsertWithWhereUniqueWithoutCourseTypeInput | DictCourseTagUpsertWithWhereUniqueWithoutCourseTypeInput[]
    createMany?: DictCourseTagCreateManyCourseTypeInputEnvelope
    set?: DictCourseTagWhereUniqueInput | DictCourseTagWhereUniqueInput[]
    disconnect?: DictCourseTagWhereUniqueInput | DictCourseTagWhereUniqueInput[]
    delete?: DictCourseTagWhereUniqueInput | DictCourseTagWhereUniqueInput[]
    connect?: DictCourseTagWhereUniqueInput | DictCourseTagWhereUniqueInput[]
    update?: DictCourseTagUpdateWithWhereUniqueWithoutCourseTypeInput | DictCourseTagUpdateWithWhereUniqueWithoutCourseTypeInput[]
    updateMany?: DictCourseTagUpdateManyWithWhereWithoutCourseTypeInput | DictCourseTagUpdateManyWithWhereWithoutCourseTypeInput[]
    deleteMany?: DictCourseTagScalarWhereInput | DictCourseTagScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutTagsInput = {
    create?: XOR<CourseCreateWithoutTagsInput, CourseUncheckedCreateWithoutTagsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutTagsInput
    connect?: CourseWhereUniqueInput
  }

  export type DictCourseTagCreateNestedOneWithoutCourseTagInput = {
    create?: XOR<DictCourseTagCreateWithoutCourseTagInput, DictCourseTagUncheckedCreateWithoutCourseTagInput>
    connectOrCreate?: DictCourseTagCreateOrConnectWithoutCourseTagInput
    connect?: DictCourseTagWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<CourseCreateWithoutTagsInput, CourseUncheckedCreateWithoutTagsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutTagsInput
    upsert?: CourseUpsertWithoutTagsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutTagsInput, CourseUpdateWithoutTagsInput>, CourseUncheckedUpdateWithoutTagsInput>
  }

  export type DictCourseTagUpdateOneRequiredWithoutCourseTagNestedInput = {
    create?: XOR<DictCourseTagCreateWithoutCourseTagInput, DictCourseTagUncheckedCreateWithoutCourseTagInput>
    connectOrCreate?: DictCourseTagCreateOrConnectWithoutCourseTagInput
    upsert?: DictCourseTagUpsertWithoutCourseTagInput
    connect?: DictCourseTagWhereUniqueInput
    update?: XOR<XOR<DictCourseTagUpdateToOneWithWhereWithoutCourseTagInput, DictCourseTagUpdateWithoutCourseTagInput>, DictCourseTagUncheckedUpdateWithoutCourseTagInput>
  }

  export type CourseContentCreateNestedOneWithoutTagsInput = {
    create?: XOR<CourseContentCreateWithoutTagsInput, CourseContentUncheckedCreateWithoutTagsInput>
    connectOrCreate?: CourseContentCreateOrConnectWithoutTagsInput
    connect?: CourseContentWhereUniqueInput
  }

  export type DictCourseTagCreateNestedOneWithoutContentTagInput = {
    create?: XOR<DictCourseTagCreateWithoutContentTagInput, DictCourseTagUncheckedCreateWithoutContentTagInput>
    connectOrCreate?: DictCourseTagCreateOrConnectWithoutContentTagInput
    connect?: DictCourseTagWhereUniqueInput
  }

  export type CourseContentUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<CourseContentCreateWithoutTagsInput, CourseContentUncheckedCreateWithoutTagsInput>
    connectOrCreate?: CourseContentCreateOrConnectWithoutTagsInput
    upsert?: CourseContentUpsertWithoutTagsInput
    connect?: CourseContentWhereUniqueInput
    update?: XOR<XOR<CourseContentUpdateToOneWithWhereWithoutTagsInput, CourseContentUpdateWithoutTagsInput>, CourseContentUncheckedUpdateWithoutTagsInput>
  }

  export type DictCourseTagUpdateOneRequiredWithoutContentTagNestedInput = {
    create?: XOR<DictCourseTagCreateWithoutContentTagInput, DictCourseTagUncheckedCreateWithoutContentTagInput>
    connectOrCreate?: DictCourseTagCreateOrConnectWithoutContentTagInput
    upsert?: DictCourseTagUpsertWithoutContentTagInput
    connect?: DictCourseTagWhereUniqueInput
    update?: XOR<XOR<DictCourseTagUpdateToOneWithWhereWithoutContentTagInput, DictCourseTagUpdateWithoutContentTagInput>, DictCourseTagUncheckedUpdateWithoutContentTagInput>
  }

  export type UserCreateNestedOneWithoutCommentInput = {
    create?: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CommentCreateWithoutChildrenInput, CommentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CommentCreateOrConnectWithoutChildrenInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CourseCommentCreateNestedManyWithoutCommentInput = {
    create?: XOR<CourseCommentCreateWithoutCommentInput, CourseCommentUncheckedCreateWithoutCommentInput> | CourseCommentCreateWithoutCommentInput[] | CourseCommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CourseCommentCreateOrConnectWithoutCommentInput | CourseCommentCreateOrConnectWithoutCommentInput[]
    createMany?: CourseCommentCreateManyCommentInputEnvelope
    connect?: CourseCommentWhereUniqueInput | CourseCommentWhereUniqueInput[]
  }

  export type ContentCommentCreateNestedManyWithoutCommentInput = {
    create?: XOR<ContentCommentCreateWithoutCommentInput, ContentCommentUncheckedCreateWithoutCommentInput> | ContentCommentCreateWithoutCommentInput[] | ContentCommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ContentCommentCreateOrConnectWithoutCommentInput | ContentCommentCreateOrConnectWithoutCommentInput[]
    createMany?: ContentCommentCreateManyCommentInputEnvelope
    connect?: ContentCommentWhereUniqueInput | ContentCommentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CourseCommentUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<CourseCommentCreateWithoutCommentInput, CourseCommentUncheckedCreateWithoutCommentInput> | CourseCommentCreateWithoutCommentInput[] | CourseCommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CourseCommentCreateOrConnectWithoutCommentInput | CourseCommentCreateOrConnectWithoutCommentInput[]
    createMany?: CourseCommentCreateManyCommentInputEnvelope
    connect?: CourseCommentWhereUniqueInput | CourseCommentWhereUniqueInput[]
  }

  export type ContentCommentUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<ContentCommentCreateWithoutCommentInput, ContentCommentUncheckedCreateWithoutCommentInput> | ContentCommentCreateWithoutCommentInput[] | ContentCommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ContentCommentCreateOrConnectWithoutCommentInput | ContentCommentCreateOrConnectWithoutCommentInput[]
    createMany?: ContentCommentCreateManyCommentInputEnvelope
    connect?: ContentCommentWhereUniqueInput | ContentCommentWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type UserUpdateOneRequiredWithoutCommentNestedInput = {
    create?: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentInput
    upsert?: UserUpsertWithoutCommentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentInput, UserUpdateWithoutCommentInput>, UserUncheckedUpdateWithoutCommentInput>
  }

  export type CommentUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<CommentCreateWithoutChildrenInput, CommentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CommentCreateOrConnectWithoutChildrenInput
    upsert?: CommentUpsertWithoutChildrenInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutChildrenInput, CommentUpdateWithoutChildrenInput>, CommentUncheckedUpdateWithoutChildrenInput>
  }

  export type CommentUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CourseCommentUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CourseCommentCreateWithoutCommentInput, CourseCommentUncheckedCreateWithoutCommentInput> | CourseCommentCreateWithoutCommentInput[] | CourseCommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CourseCommentCreateOrConnectWithoutCommentInput | CourseCommentCreateOrConnectWithoutCommentInput[]
    upsert?: CourseCommentUpsertWithWhereUniqueWithoutCommentInput | CourseCommentUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CourseCommentCreateManyCommentInputEnvelope
    set?: CourseCommentWhereUniqueInput | CourseCommentWhereUniqueInput[]
    disconnect?: CourseCommentWhereUniqueInput | CourseCommentWhereUniqueInput[]
    delete?: CourseCommentWhereUniqueInput | CourseCommentWhereUniqueInput[]
    connect?: CourseCommentWhereUniqueInput | CourseCommentWhereUniqueInput[]
    update?: CourseCommentUpdateWithWhereUniqueWithoutCommentInput | CourseCommentUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CourseCommentUpdateManyWithWhereWithoutCommentInput | CourseCommentUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CourseCommentScalarWhereInput | CourseCommentScalarWhereInput[]
  }

  export type ContentCommentUpdateManyWithoutCommentNestedInput = {
    create?: XOR<ContentCommentCreateWithoutCommentInput, ContentCommentUncheckedCreateWithoutCommentInput> | ContentCommentCreateWithoutCommentInput[] | ContentCommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ContentCommentCreateOrConnectWithoutCommentInput | ContentCommentCreateOrConnectWithoutCommentInput[]
    upsert?: ContentCommentUpsertWithWhereUniqueWithoutCommentInput | ContentCommentUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: ContentCommentCreateManyCommentInputEnvelope
    set?: ContentCommentWhereUniqueInput | ContentCommentWhereUniqueInput[]
    disconnect?: ContentCommentWhereUniqueInput | ContentCommentWhereUniqueInput[]
    delete?: ContentCommentWhereUniqueInput | ContentCommentWhereUniqueInput[]
    connect?: ContentCommentWhereUniqueInput | ContentCommentWhereUniqueInput[]
    update?: ContentCommentUpdateWithWhereUniqueWithoutCommentInput | ContentCommentUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: ContentCommentUpdateManyWithWhereWithoutCommentInput | ContentCommentUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: ContentCommentScalarWhereInput | ContentCommentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CourseCommentUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CourseCommentCreateWithoutCommentInput, CourseCommentUncheckedCreateWithoutCommentInput> | CourseCommentCreateWithoutCommentInput[] | CourseCommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CourseCommentCreateOrConnectWithoutCommentInput | CourseCommentCreateOrConnectWithoutCommentInput[]
    upsert?: CourseCommentUpsertWithWhereUniqueWithoutCommentInput | CourseCommentUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CourseCommentCreateManyCommentInputEnvelope
    set?: CourseCommentWhereUniqueInput | CourseCommentWhereUniqueInput[]
    disconnect?: CourseCommentWhereUniqueInput | CourseCommentWhereUniqueInput[]
    delete?: CourseCommentWhereUniqueInput | CourseCommentWhereUniqueInput[]
    connect?: CourseCommentWhereUniqueInput | CourseCommentWhereUniqueInput[]
    update?: CourseCommentUpdateWithWhereUniqueWithoutCommentInput | CourseCommentUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CourseCommentUpdateManyWithWhereWithoutCommentInput | CourseCommentUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CourseCommentScalarWhereInput | CourseCommentScalarWhereInput[]
  }

  export type ContentCommentUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<ContentCommentCreateWithoutCommentInput, ContentCommentUncheckedCreateWithoutCommentInput> | ContentCommentCreateWithoutCommentInput[] | ContentCommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ContentCommentCreateOrConnectWithoutCommentInput | ContentCommentCreateOrConnectWithoutCommentInput[]
    upsert?: ContentCommentUpsertWithWhereUniqueWithoutCommentInput | ContentCommentUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: ContentCommentCreateManyCommentInputEnvelope
    set?: ContentCommentWhereUniqueInput | ContentCommentWhereUniqueInput[]
    disconnect?: ContentCommentWhereUniqueInput | ContentCommentWhereUniqueInput[]
    delete?: ContentCommentWhereUniqueInput | ContentCommentWhereUniqueInput[]
    connect?: ContentCommentWhereUniqueInput | ContentCommentWhereUniqueInput[]
    update?: ContentCommentUpdateWithWhereUniqueWithoutCommentInput | ContentCommentUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: ContentCommentUpdateManyWithWhereWithoutCommentInput | ContentCommentUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: ContentCommentScalarWhereInput | ContentCommentScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutCourseCommentInput = {
    create?: XOR<CourseCreateWithoutCourseCommentInput, CourseUncheckedCreateWithoutCourseCommentInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCourseCommentInput
    connect?: CourseWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutCourseCommentInput = {
    create?: XOR<CommentCreateWithoutCourseCommentInput, CommentUncheckedCreateWithoutCourseCommentInput>
    connectOrCreate?: CommentCreateOrConnectWithoutCourseCommentInput
    connect?: CommentWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutCourseCommentNestedInput = {
    create?: XOR<CourseCreateWithoutCourseCommentInput, CourseUncheckedCreateWithoutCourseCommentInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCourseCommentInput
    upsert?: CourseUpsertWithoutCourseCommentInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutCourseCommentInput, CourseUpdateWithoutCourseCommentInput>, CourseUncheckedUpdateWithoutCourseCommentInput>
  }

  export type CommentUpdateOneRequiredWithoutCourseCommentNestedInput = {
    create?: XOR<CommentCreateWithoutCourseCommentInput, CommentUncheckedCreateWithoutCourseCommentInput>
    connectOrCreate?: CommentCreateOrConnectWithoutCourseCommentInput
    upsert?: CommentUpsertWithoutCourseCommentInput
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutCourseCommentInput, CommentUpdateWithoutCourseCommentInput>, CommentUncheckedUpdateWithoutCourseCommentInput>
  }

  export type CourseContentCreateNestedOneWithoutContentCommentInput = {
    create?: XOR<CourseContentCreateWithoutContentCommentInput, CourseContentUncheckedCreateWithoutContentCommentInput>
    connectOrCreate?: CourseContentCreateOrConnectWithoutContentCommentInput
    connect?: CourseContentWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutContentCommentInput = {
    create?: XOR<CommentCreateWithoutContentCommentInput, CommentUncheckedCreateWithoutContentCommentInput>
    connectOrCreate?: CommentCreateOrConnectWithoutContentCommentInput
    connect?: CommentWhereUniqueInput
  }

  export type CourseContentUpdateOneRequiredWithoutContentCommentNestedInput = {
    create?: XOR<CourseContentCreateWithoutContentCommentInput, CourseContentUncheckedCreateWithoutContentCommentInput>
    connectOrCreate?: CourseContentCreateOrConnectWithoutContentCommentInput
    upsert?: CourseContentUpsertWithoutContentCommentInput
    connect?: CourseContentWhereUniqueInput
    update?: XOR<XOR<CourseContentUpdateToOneWithWhereWithoutContentCommentInput, CourseContentUpdateWithoutContentCommentInput>, CourseContentUncheckedUpdateWithoutContentCommentInput>
  }

  export type CommentUpdateOneRequiredWithoutContentCommentNestedInput = {
    create?: XOR<CommentCreateWithoutContentCommentInput, CommentUncheckedCreateWithoutContentCommentInput>
    connectOrCreate?: CommentCreateOrConnectWithoutContentCommentInput
    upsert?: CommentUpsertWithoutContentCommentInput
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutContentCommentInput, CommentUpdateWithoutContentCommentInput>, CommentUncheckedUpdateWithoutContentCommentInput>
  }

  export type UserCreateNestedOneWithoutNoteInput = {
    create?: XOR<UserCreateWithoutNoteInput, UserUncheckedCreateWithoutNoteInput>
    connectOrCreate?: UserCreateOrConnectWithoutNoteInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNoteNestedInput = {
    create?: XOR<UserCreateWithoutNoteInput, UserUncheckedCreateWithoutNoteInput>
    connectOrCreate?: UserCreateOrConnectWithoutNoteInput
    upsert?: UserUpsertWithoutNoteInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNoteInput, UserUpdateWithoutNoteInput>, UserUncheckedUpdateWithoutNoteInput>
  }

  export type TransactionCreateNestedManyWithoutPlatformInput = {
    create?: XOR<TransactionCreateWithoutPlatformInput, TransactionUncheckedCreateWithoutPlatformInput> | TransactionCreateWithoutPlatformInput[] | TransactionUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPlatformInput | TransactionCreateOrConnectWithoutPlatformInput[]
    createMany?: TransactionCreateManyPlatformInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutPlatformInput = {
    create?: XOR<TransactionCreateWithoutPlatformInput, TransactionUncheckedCreateWithoutPlatformInput> | TransactionCreateWithoutPlatformInput[] | TransactionUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPlatformInput | TransactionCreateOrConnectWithoutPlatformInput[]
    createMany?: TransactionCreateManyPlatformInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUpdateManyWithoutPlatformNestedInput = {
    create?: XOR<TransactionCreateWithoutPlatformInput, TransactionUncheckedCreateWithoutPlatformInput> | TransactionCreateWithoutPlatformInput[] | TransactionUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPlatformInput | TransactionCreateOrConnectWithoutPlatformInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutPlatformInput | TransactionUpsertWithWhereUniqueWithoutPlatformInput[]
    createMany?: TransactionCreateManyPlatformInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutPlatformInput | TransactionUpdateWithWhereUniqueWithoutPlatformInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutPlatformInput | TransactionUpdateManyWithWhereWithoutPlatformInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutPlatformNestedInput = {
    create?: XOR<TransactionCreateWithoutPlatformInput, TransactionUncheckedCreateWithoutPlatformInput> | TransactionCreateWithoutPlatformInput[] | TransactionUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPlatformInput | TransactionCreateOrConnectWithoutPlatformInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutPlatformInput | TransactionUpsertWithWhereUniqueWithoutPlatformInput[]
    createMany?: TransactionCreateManyPlatformInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutPlatformInput | TransactionUpdateWithWhereUniqueWithoutPlatformInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutPlatformInput | TransactionUpdateManyWithWhereWithoutPlatformInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutTransactionInput = {
    create?: XOR<CourseCreateWithoutTransactionInput, CourseUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: CourseCreateOrConnectWithoutTransactionInput
    connect?: CourseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTransactionInput = {
    create?: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionInput
    connect?: UserWhereUniqueInput
  }

  export type DictPlatformCreateNestedOneWithoutTransactionInput = {
    create?: XOR<DictPlatformCreateWithoutTransactionInput, DictPlatformUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: DictPlatformCreateOrConnectWithoutTransactionInput
    connect?: DictPlatformWhereUniqueInput
  }

  export type GroupTransactionCreateNestedManyWithoutTransactionInput = {
    create?: XOR<GroupTransactionCreateWithoutTransactionInput, GroupTransactionUncheckedCreateWithoutTransactionInput> | GroupTransactionCreateWithoutTransactionInput[] | GroupTransactionUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: GroupTransactionCreateOrConnectWithoutTransactionInput | GroupTransactionCreateOrConnectWithoutTransactionInput[]
    createMany?: GroupTransactionCreateManyTransactionInputEnvelope
    connect?: GroupTransactionWhereUniqueInput | GroupTransactionWhereUniqueInput[]
  }

  export type BalanceRecordCreateNestedManyWithoutTransactionInput = {
    create?: XOR<BalanceRecordCreateWithoutTransactionInput, BalanceRecordUncheckedCreateWithoutTransactionInput> | BalanceRecordCreateWithoutTransactionInput[] | BalanceRecordUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: BalanceRecordCreateOrConnectWithoutTransactionInput | BalanceRecordCreateOrConnectWithoutTransactionInput[]
    createMany?: BalanceRecordCreateManyTransactionInputEnvelope
    connect?: BalanceRecordWhereUniqueInput | BalanceRecordWhereUniqueInput[]
  }

  export type GroupTransactionUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<GroupTransactionCreateWithoutTransactionInput, GroupTransactionUncheckedCreateWithoutTransactionInput> | GroupTransactionCreateWithoutTransactionInput[] | GroupTransactionUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: GroupTransactionCreateOrConnectWithoutTransactionInput | GroupTransactionCreateOrConnectWithoutTransactionInput[]
    createMany?: GroupTransactionCreateManyTransactionInputEnvelope
    connect?: GroupTransactionWhereUniqueInput | GroupTransactionWhereUniqueInput[]
  }

  export type BalanceRecordUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<BalanceRecordCreateWithoutTransactionInput, BalanceRecordUncheckedCreateWithoutTransactionInput> | BalanceRecordCreateWithoutTransactionInput[] | BalanceRecordUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: BalanceRecordCreateOrConnectWithoutTransactionInput | BalanceRecordCreateOrConnectWithoutTransactionInput[]
    createMany?: BalanceRecordCreateManyTransactionInputEnvelope
    connect?: BalanceRecordWhereUniqueInput | BalanceRecordWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CourseUpdateOneRequiredWithoutTransactionNestedInput = {
    create?: XOR<CourseCreateWithoutTransactionInput, CourseUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: CourseCreateOrConnectWithoutTransactionInput
    upsert?: CourseUpsertWithoutTransactionInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutTransactionInput, CourseUpdateWithoutTransactionInput>, CourseUncheckedUpdateWithoutTransactionInput>
  }

  export type UserUpdateOneRequiredWithoutTransactionNestedInput = {
    create?: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionInput
    upsert?: UserUpsertWithoutTransactionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionInput, UserUpdateWithoutTransactionInput>, UserUncheckedUpdateWithoutTransactionInput>
  }

  export type DictPlatformUpdateOneRequiredWithoutTransactionNestedInput = {
    create?: XOR<DictPlatformCreateWithoutTransactionInput, DictPlatformUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: DictPlatformCreateOrConnectWithoutTransactionInput
    upsert?: DictPlatformUpsertWithoutTransactionInput
    connect?: DictPlatformWhereUniqueInput
    update?: XOR<XOR<DictPlatformUpdateToOneWithWhereWithoutTransactionInput, DictPlatformUpdateWithoutTransactionInput>, DictPlatformUncheckedUpdateWithoutTransactionInput>
  }

  export type GroupTransactionUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<GroupTransactionCreateWithoutTransactionInput, GroupTransactionUncheckedCreateWithoutTransactionInput> | GroupTransactionCreateWithoutTransactionInput[] | GroupTransactionUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: GroupTransactionCreateOrConnectWithoutTransactionInput | GroupTransactionCreateOrConnectWithoutTransactionInput[]
    upsert?: GroupTransactionUpsertWithWhereUniqueWithoutTransactionInput | GroupTransactionUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: GroupTransactionCreateManyTransactionInputEnvelope
    set?: GroupTransactionWhereUniqueInput | GroupTransactionWhereUniqueInput[]
    disconnect?: GroupTransactionWhereUniqueInput | GroupTransactionWhereUniqueInput[]
    delete?: GroupTransactionWhereUniqueInput | GroupTransactionWhereUniqueInput[]
    connect?: GroupTransactionWhereUniqueInput | GroupTransactionWhereUniqueInput[]
    update?: GroupTransactionUpdateWithWhereUniqueWithoutTransactionInput | GroupTransactionUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: GroupTransactionUpdateManyWithWhereWithoutTransactionInput | GroupTransactionUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: GroupTransactionScalarWhereInput | GroupTransactionScalarWhereInput[]
  }

  export type BalanceRecordUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<BalanceRecordCreateWithoutTransactionInput, BalanceRecordUncheckedCreateWithoutTransactionInput> | BalanceRecordCreateWithoutTransactionInput[] | BalanceRecordUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: BalanceRecordCreateOrConnectWithoutTransactionInput | BalanceRecordCreateOrConnectWithoutTransactionInput[]
    upsert?: BalanceRecordUpsertWithWhereUniqueWithoutTransactionInput | BalanceRecordUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: BalanceRecordCreateManyTransactionInputEnvelope
    set?: BalanceRecordWhereUniqueInput | BalanceRecordWhereUniqueInput[]
    disconnect?: BalanceRecordWhereUniqueInput | BalanceRecordWhereUniqueInput[]
    delete?: BalanceRecordWhereUniqueInput | BalanceRecordWhereUniqueInput[]
    connect?: BalanceRecordWhereUniqueInput | BalanceRecordWhereUniqueInput[]
    update?: BalanceRecordUpdateWithWhereUniqueWithoutTransactionInput | BalanceRecordUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: BalanceRecordUpdateManyWithWhereWithoutTransactionInput | BalanceRecordUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: BalanceRecordScalarWhereInput | BalanceRecordScalarWhereInput[]
  }

  export type GroupTransactionUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<GroupTransactionCreateWithoutTransactionInput, GroupTransactionUncheckedCreateWithoutTransactionInput> | GroupTransactionCreateWithoutTransactionInput[] | GroupTransactionUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: GroupTransactionCreateOrConnectWithoutTransactionInput | GroupTransactionCreateOrConnectWithoutTransactionInput[]
    upsert?: GroupTransactionUpsertWithWhereUniqueWithoutTransactionInput | GroupTransactionUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: GroupTransactionCreateManyTransactionInputEnvelope
    set?: GroupTransactionWhereUniqueInput | GroupTransactionWhereUniqueInput[]
    disconnect?: GroupTransactionWhereUniqueInput | GroupTransactionWhereUniqueInput[]
    delete?: GroupTransactionWhereUniqueInput | GroupTransactionWhereUniqueInput[]
    connect?: GroupTransactionWhereUniqueInput | GroupTransactionWhereUniqueInput[]
    update?: GroupTransactionUpdateWithWhereUniqueWithoutTransactionInput | GroupTransactionUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: GroupTransactionUpdateManyWithWhereWithoutTransactionInput | GroupTransactionUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: GroupTransactionScalarWhereInput | GroupTransactionScalarWhereInput[]
  }

  export type BalanceRecordUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<BalanceRecordCreateWithoutTransactionInput, BalanceRecordUncheckedCreateWithoutTransactionInput> | BalanceRecordCreateWithoutTransactionInput[] | BalanceRecordUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: BalanceRecordCreateOrConnectWithoutTransactionInput | BalanceRecordCreateOrConnectWithoutTransactionInput[]
    upsert?: BalanceRecordUpsertWithWhereUniqueWithoutTransactionInput | BalanceRecordUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: BalanceRecordCreateManyTransactionInputEnvelope
    set?: BalanceRecordWhereUniqueInput | BalanceRecordWhereUniqueInput[]
    disconnect?: BalanceRecordWhereUniqueInput | BalanceRecordWhereUniqueInput[]
    delete?: BalanceRecordWhereUniqueInput | BalanceRecordWhereUniqueInput[]
    connect?: BalanceRecordWhereUniqueInput | BalanceRecordWhereUniqueInput[]
    update?: BalanceRecordUpdateWithWhereUniqueWithoutTransactionInput | BalanceRecordUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: BalanceRecordUpdateManyWithWhereWithoutTransactionInput | BalanceRecordUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: BalanceRecordScalarWhereInput | BalanceRecordScalarWhereInput[]
  }

  export type TransactionCreateNestedOneWithoutGroupTransactionInput = {
    create?: XOR<TransactionCreateWithoutGroupTransactionInput, TransactionUncheckedCreateWithoutGroupTransactionInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutGroupTransactionInput
    connect?: TransactionWhereUniqueInput
  }

  export type TransactionUpdateOneRequiredWithoutGroupTransactionNestedInput = {
    create?: XOR<TransactionCreateWithoutGroupTransactionInput, TransactionUncheckedCreateWithoutGroupTransactionInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutGroupTransactionInput
    upsert?: TransactionUpsertWithoutGroupTransactionInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutGroupTransactionInput, TransactionUpdateWithoutGroupTransactionInput>, TransactionUncheckedUpdateWithoutGroupTransactionInput>
  }

  export type AuditStageCreateNestedManyWithoutFlowInput = {
    create?: XOR<AuditStageCreateWithoutFlowInput, AuditStageUncheckedCreateWithoutFlowInput> | AuditStageCreateWithoutFlowInput[] | AuditStageUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: AuditStageCreateOrConnectWithoutFlowInput | AuditStageCreateOrConnectWithoutFlowInput[]
    createMany?: AuditStageCreateManyFlowInputEnvelope
    connect?: AuditStageWhereUniqueInput | AuditStageWhereUniqueInput[]
  }

  export type AuditStageUncheckedCreateNestedManyWithoutFlowInput = {
    create?: XOR<AuditStageCreateWithoutFlowInput, AuditStageUncheckedCreateWithoutFlowInput> | AuditStageCreateWithoutFlowInput[] | AuditStageUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: AuditStageCreateOrConnectWithoutFlowInput | AuditStageCreateOrConnectWithoutFlowInput[]
    createMany?: AuditStageCreateManyFlowInputEnvelope
    connect?: AuditStageWhereUniqueInput | AuditStageWhereUniqueInput[]
  }

  export type AuditStageUpdateManyWithoutFlowNestedInput = {
    create?: XOR<AuditStageCreateWithoutFlowInput, AuditStageUncheckedCreateWithoutFlowInput> | AuditStageCreateWithoutFlowInput[] | AuditStageUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: AuditStageCreateOrConnectWithoutFlowInput | AuditStageCreateOrConnectWithoutFlowInput[]
    upsert?: AuditStageUpsertWithWhereUniqueWithoutFlowInput | AuditStageUpsertWithWhereUniqueWithoutFlowInput[]
    createMany?: AuditStageCreateManyFlowInputEnvelope
    set?: AuditStageWhereUniqueInput | AuditStageWhereUniqueInput[]
    disconnect?: AuditStageWhereUniqueInput | AuditStageWhereUniqueInput[]
    delete?: AuditStageWhereUniqueInput | AuditStageWhereUniqueInput[]
    connect?: AuditStageWhereUniqueInput | AuditStageWhereUniqueInput[]
    update?: AuditStageUpdateWithWhereUniqueWithoutFlowInput | AuditStageUpdateWithWhereUniqueWithoutFlowInput[]
    updateMany?: AuditStageUpdateManyWithWhereWithoutFlowInput | AuditStageUpdateManyWithWhereWithoutFlowInput[]
    deleteMany?: AuditStageScalarWhereInput | AuditStageScalarWhereInput[]
  }

  export type AuditStageUncheckedUpdateManyWithoutFlowNestedInput = {
    create?: XOR<AuditStageCreateWithoutFlowInput, AuditStageUncheckedCreateWithoutFlowInput> | AuditStageCreateWithoutFlowInput[] | AuditStageUncheckedCreateWithoutFlowInput[]
    connectOrCreate?: AuditStageCreateOrConnectWithoutFlowInput | AuditStageCreateOrConnectWithoutFlowInput[]
    upsert?: AuditStageUpsertWithWhereUniqueWithoutFlowInput | AuditStageUpsertWithWhereUniqueWithoutFlowInput[]
    createMany?: AuditStageCreateManyFlowInputEnvelope
    set?: AuditStageWhereUniqueInput | AuditStageWhereUniqueInput[]
    disconnect?: AuditStageWhereUniqueInput | AuditStageWhereUniqueInput[]
    delete?: AuditStageWhereUniqueInput | AuditStageWhereUniqueInput[]
    connect?: AuditStageWhereUniqueInput | AuditStageWhereUniqueInput[]
    update?: AuditStageUpdateWithWhereUniqueWithoutFlowInput | AuditStageUpdateWithWhereUniqueWithoutFlowInput[]
    updateMany?: AuditStageUpdateManyWithWhereWithoutFlowInput | AuditStageUpdateManyWithWhereWithoutFlowInput[]
    deleteMany?: AuditStageScalarWhereInput | AuditStageScalarWhereInput[]
  }

  export type AuditFlowCreateNestedOneWithoutAuditStageInput = {
    create?: XOR<AuditFlowCreateWithoutAuditStageInput, AuditFlowUncheckedCreateWithoutAuditStageInput>
    connectOrCreate?: AuditFlowCreateOrConnectWithoutAuditStageInput
    connect?: AuditFlowWhereUniqueInput
  }

  export type AuditStageCreateNestedOneWithoutChildrenInput = {
    create?: XOR<AuditStageCreateWithoutChildrenInput, AuditStageUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: AuditStageCreateOrConnectWithoutChildrenInput
    connect?: AuditStageWhereUniqueInput
  }

  export type AuditStageCreateNestedManyWithoutParentInput = {
    create?: XOR<AuditStageCreateWithoutParentInput, AuditStageUncheckedCreateWithoutParentInput> | AuditStageCreateWithoutParentInput[] | AuditStageUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AuditStageCreateOrConnectWithoutParentInput | AuditStageCreateOrConnectWithoutParentInput[]
    createMany?: AuditStageCreateManyParentInputEnvelope
    connect?: AuditStageWhereUniqueInput | AuditStageWhereUniqueInput[]
  }

  export type AuditRecordCreateNestedManyWithoutStageInput = {
    create?: XOR<AuditRecordCreateWithoutStageInput, AuditRecordUncheckedCreateWithoutStageInput> | AuditRecordCreateWithoutStageInput[] | AuditRecordUncheckedCreateWithoutStageInput[]
    connectOrCreate?: AuditRecordCreateOrConnectWithoutStageInput | AuditRecordCreateOrConnectWithoutStageInput[]
    createMany?: AuditRecordCreateManyStageInputEnvelope
    connect?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
  }

  export type AuditStageUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<AuditStageCreateWithoutParentInput, AuditStageUncheckedCreateWithoutParentInput> | AuditStageCreateWithoutParentInput[] | AuditStageUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AuditStageCreateOrConnectWithoutParentInput | AuditStageCreateOrConnectWithoutParentInput[]
    createMany?: AuditStageCreateManyParentInputEnvelope
    connect?: AuditStageWhereUniqueInput | AuditStageWhereUniqueInput[]
  }

  export type AuditRecordUncheckedCreateNestedManyWithoutStageInput = {
    create?: XOR<AuditRecordCreateWithoutStageInput, AuditRecordUncheckedCreateWithoutStageInput> | AuditRecordCreateWithoutStageInput[] | AuditRecordUncheckedCreateWithoutStageInput[]
    connectOrCreate?: AuditRecordCreateOrConnectWithoutStageInput | AuditRecordCreateOrConnectWithoutStageInput[]
    createMany?: AuditRecordCreateManyStageInputEnvelope
    connect?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
  }

  export type AuditFlowUpdateOneRequiredWithoutAuditStageNestedInput = {
    create?: XOR<AuditFlowCreateWithoutAuditStageInput, AuditFlowUncheckedCreateWithoutAuditStageInput>
    connectOrCreate?: AuditFlowCreateOrConnectWithoutAuditStageInput
    upsert?: AuditFlowUpsertWithoutAuditStageInput
    connect?: AuditFlowWhereUniqueInput
    update?: XOR<XOR<AuditFlowUpdateToOneWithWhereWithoutAuditStageInput, AuditFlowUpdateWithoutAuditStageInput>, AuditFlowUncheckedUpdateWithoutAuditStageInput>
  }

  export type AuditStageUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<AuditStageCreateWithoutChildrenInput, AuditStageUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: AuditStageCreateOrConnectWithoutChildrenInput
    upsert?: AuditStageUpsertWithoutChildrenInput
    disconnect?: AuditStageWhereInput | boolean
    delete?: AuditStageWhereInput | boolean
    connect?: AuditStageWhereUniqueInput
    update?: XOR<XOR<AuditStageUpdateToOneWithWhereWithoutChildrenInput, AuditStageUpdateWithoutChildrenInput>, AuditStageUncheckedUpdateWithoutChildrenInput>
  }

  export type AuditStageUpdateManyWithoutParentNestedInput = {
    create?: XOR<AuditStageCreateWithoutParentInput, AuditStageUncheckedCreateWithoutParentInput> | AuditStageCreateWithoutParentInput[] | AuditStageUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AuditStageCreateOrConnectWithoutParentInput | AuditStageCreateOrConnectWithoutParentInput[]
    upsert?: AuditStageUpsertWithWhereUniqueWithoutParentInput | AuditStageUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: AuditStageCreateManyParentInputEnvelope
    set?: AuditStageWhereUniqueInput | AuditStageWhereUniqueInput[]
    disconnect?: AuditStageWhereUniqueInput | AuditStageWhereUniqueInput[]
    delete?: AuditStageWhereUniqueInput | AuditStageWhereUniqueInput[]
    connect?: AuditStageWhereUniqueInput | AuditStageWhereUniqueInput[]
    update?: AuditStageUpdateWithWhereUniqueWithoutParentInput | AuditStageUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: AuditStageUpdateManyWithWhereWithoutParentInput | AuditStageUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: AuditStageScalarWhereInput | AuditStageScalarWhereInput[]
  }

  export type AuditRecordUpdateManyWithoutStageNestedInput = {
    create?: XOR<AuditRecordCreateWithoutStageInput, AuditRecordUncheckedCreateWithoutStageInput> | AuditRecordCreateWithoutStageInput[] | AuditRecordUncheckedCreateWithoutStageInput[]
    connectOrCreate?: AuditRecordCreateOrConnectWithoutStageInput | AuditRecordCreateOrConnectWithoutStageInput[]
    upsert?: AuditRecordUpsertWithWhereUniqueWithoutStageInput | AuditRecordUpsertWithWhereUniqueWithoutStageInput[]
    createMany?: AuditRecordCreateManyStageInputEnvelope
    set?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    disconnect?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    delete?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    connect?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    update?: AuditRecordUpdateWithWhereUniqueWithoutStageInput | AuditRecordUpdateWithWhereUniqueWithoutStageInput[]
    updateMany?: AuditRecordUpdateManyWithWhereWithoutStageInput | AuditRecordUpdateManyWithWhereWithoutStageInput[]
    deleteMany?: AuditRecordScalarWhereInput | AuditRecordScalarWhereInput[]
  }

  export type AuditStageUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<AuditStageCreateWithoutParentInput, AuditStageUncheckedCreateWithoutParentInput> | AuditStageCreateWithoutParentInput[] | AuditStageUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AuditStageCreateOrConnectWithoutParentInput | AuditStageCreateOrConnectWithoutParentInput[]
    upsert?: AuditStageUpsertWithWhereUniqueWithoutParentInput | AuditStageUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: AuditStageCreateManyParentInputEnvelope
    set?: AuditStageWhereUniqueInput | AuditStageWhereUniqueInput[]
    disconnect?: AuditStageWhereUniqueInput | AuditStageWhereUniqueInput[]
    delete?: AuditStageWhereUniqueInput | AuditStageWhereUniqueInput[]
    connect?: AuditStageWhereUniqueInput | AuditStageWhereUniqueInput[]
    update?: AuditStageUpdateWithWhereUniqueWithoutParentInput | AuditStageUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: AuditStageUpdateManyWithWhereWithoutParentInput | AuditStageUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: AuditStageScalarWhereInput | AuditStageScalarWhereInput[]
  }

  export type AuditRecordUncheckedUpdateManyWithoutStageNestedInput = {
    create?: XOR<AuditRecordCreateWithoutStageInput, AuditRecordUncheckedCreateWithoutStageInput> | AuditRecordCreateWithoutStageInput[] | AuditRecordUncheckedCreateWithoutStageInput[]
    connectOrCreate?: AuditRecordCreateOrConnectWithoutStageInput | AuditRecordCreateOrConnectWithoutStageInput[]
    upsert?: AuditRecordUpsertWithWhereUniqueWithoutStageInput | AuditRecordUpsertWithWhereUniqueWithoutStageInput[]
    createMany?: AuditRecordCreateManyStageInputEnvelope
    set?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    disconnect?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    delete?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    connect?: AuditRecordWhereUniqueInput | AuditRecordWhereUniqueInput[]
    update?: AuditRecordUpdateWithWhereUniqueWithoutStageInput | AuditRecordUpdateWithWhereUniqueWithoutStageInput[]
    updateMany?: AuditRecordUpdateManyWithWhereWithoutStageInput | AuditRecordUpdateManyWithWhereWithoutStageInput[]
    deleteMany?: AuditRecordScalarWhereInput | AuditRecordScalarWhereInput[]
  }

  export type AuditStageCreateNestedOneWithoutAuditRecordInput = {
    create?: XOR<AuditStageCreateWithoutAuditRecordInput, AuditStageUncheckedCreateWithoutAuditRecordInput>
    connectOrCreate?: AuditStageCreateOrConnectWithoutAuditRecordInput
    connect?: AuditStageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditRecordInput = {
    create?: XOR<UserCreateWithoutAuditRecordInput, UserUncheckedCreateWithoutAuditRecordInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditRecordInput
    connect?: UserWhereUniqueInput
  }

  export type AuditStageUpdateOneRequiredWithoutAuditRecordNestedInput = {
    create?: XOR<AuditStageCreateWithoutAuditRecordInput, AuditStageUncheckedCreateWithoutAuditRecordInput>
    connectOrCreate?: AuditStageCreateOrConnectWithoutAuditRecordInput
    upsert?: AuditStageUpsertWithoutAuditRecordInput
    connect?: AuditStageWhereUniqueInput
    update?: XOR<XOR<AuditStageUpdateToOneWithWhereWithoutAuditRecordInput, AuditStageUpdateWithoutAuditRecordInput>, AuditStageUncheckedUpdateWithoutAuditRecordInput>
  }

  export type UserUpdateOneRequiredWithoutAuditRecordNestedInput = {
    create?: XOR<UserCreateWithoutAuditRecordInput, UserUncheckedCreateWithoutAuditRecordInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditRecordInput
    upsert?: UserUpsertWithoutAuditRecordInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditRecordInput, UserUpdateWithoutAuditRecordInput>, UserUncheckedUpdateWithoutAuditRecordInput>
  }

  export type CouponCreateNestedManyWithoutCouponTypeInput = {
    create?: XOR<CouponCreateWithoutCouponTypeInput, CouponUncheckedCreateWithoutCouponTypeInput> | CouponCreateWithoutCouponTypeInput[] | CouponUncheckedCreateWithoutCouponTypeInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutCouponTypeInput | CouponCreateOrConnectWithoutCouponTypeInput[]
    createMany?: CouponCreateManyCouponTypeInputEnvelope
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
  }

  export type CouponUncheckedCreateNestedManyWithoutCouponTypeInput = {
    create?: XOR<CouponCreateWithoutCouponTypeInput, CouponUncheckedCreateWithoutCouponTypeInput> | CouponCreateWithoutCouponTypeInput[] | CouponUncheckedCreateWithoutCouponTypeInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutCouponTypeInput | CouponCreateOrConnectWithoutCouponTypeInput[]
    createMany?: CouponCreateManyCouponTypeInputEnvelope
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
  }

  export type CouponUpdateManyWithoutCouponTypeNestedInput = {
    create?: XOR<CouponCreateWithoutCouponTypeInput, CouponUncheckedCreateWithoutCouponTypeInput> | CouponCreateWithoutCouponTypeInput[] | CouponUncheckedCreateWithoutCouponTypeInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutCouponTypeInput | CouponCreateOrConnectWithoutCouponTypeInput[]
    upsert?: CouponUpsertWithWhereUniqueWithoutCouponTypeInput | CouponUpsertWithWhereUniqueWithoutCouponTypeInput[]
    createMany?: CouponCreateManyCouponTypeInputEnvelope
    set?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    disconnect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    delete?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    update?: CouponUpdateWithWhereUniqueWithoutCouponTypeInput | CouponUpdateWithWhereUniqueWithoutCouponTypeInput[]
    updateMany?: CouponUpdateManyWithWhereWithoutCouponTypeInput | CouponUpdateManyWithWhereWithoutCouponTypeInput[]
    deleteMany?: CouponScalarWhereInput | CouponScalarWhereInput[]
  }

  export type CouponUncheckedUpdateManyWithoutCouponTypeNestedInput = {
    create?: XOR<CouponCreateWithoutCouponTypeInput, CouponUncheckedCreateWithoutCouponTypeInput> | CouponCreateWithoutCouponTypeInput[] | CouponUncheckedCreateWithoutCouponTypeInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutCouponTypeInput | CouponCreateOrConnectWithoutCouponTypeInput[]
    upsert?: CouponUpsertWithWhereUniqueWithoutCouponTypeInput | CouponUpsertWithWhereUniqueWithoutCouponTypeInput[]
    createMany?: CouponCreateManyCouponTypeInputEnvelope
    set?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    disconnect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    delete?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    update?: CouponUpdateWithWhereUniqueWithoutCouponTypeInput | CouponUpdateWithWhereUniqueWithoutCouponTypeInput[]
    updateMany?: CouponUpdateManyWithWhereWithoutCouponTypeInput | CouponUpdateManyWithWhereWithoutCouponTypeInput[]
    deleteMany?: CouponScalarWhereInput | CouponScalarWhereInput[]
  }

  export type DictCouponTypeCreateNestedOneWithoutCouponInput = {
    create?: XOR<DictCouponTypeCreateWithoutCouponInput, DictCouponTypeUncheckedCreateWithoutCouponInput>
    connectOrCreate?: DictCouponTypeCreateOrConnectWithoutCouponInput
    connect?: DictCouponTypeWhereUniqueInput
  }

  export type DictCouponTypeUpdateOneRequiredWithoutCouponNestedInput = {
    create?: XOR<DictCouponTypeCreateWithoutCouponInput, DictCouponTypeUncheckedCreateWithoutCouponInput>
    connectOrCreate?: DictCouponTypeCreateOrConnectWithoutCouponInput
    upsert?: DictCouponTypeUpsertWithoutCouponInput
    connect?: DictCouponTypeWhereUniqueInput
    update?: XOR<XOR<DictCouponTypeUpdateToOneWithWhereWithoutCouponInput, DictCouponTypeUpdateWithoutCouponInput>, DictCouponTypeUncheckedUpdateWithoutCouponInput>
  }

  export type UserCreateNestedOneWithoutBalanceRecordInput = {
    create?: XOR<UserCreateWithoutBalanceRecordInput, UserUncheckedCreateWithoutBalanceRecordInput>
    connectOrCreate?: UserCreateOrConnectWithoutBalanceRecordInput
    connect?: UserWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutBalanceRecordInput = {
    create?: XOR<TransactionCreateWithoutBalanceRecordInput, TransactionUncheckedCreateWithoutBalanceRecordInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutBalanceRecordInput
    connect?: TransactionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBalanceRecordNestedInput = {
    create?: XOR<UserCreateWithoutBalanceRecordInput, UserUncheckedCreateWithoutBalanceRecordInput>
    connectOrCreate?: UserCreateOrConnectWithoutBalanceRecordInput
    upsert?: UserUpsertWithoutBalanceRecordInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBalanceRecordInput, UserUpdateWithoutBalanceRecordInput>, UserUncheckedUpdateWithoutBalanceRecordInput>
  }

  export type TransactionUpdateOneWithoutBalanceRecordNestedInput = {
    create?: XOR<TransactionCreateWithoutBalanceRecordInput, TransactionUncheckedCreateWithoutBalanceRecordInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutBalanceRecordInput
    upsert?: TransactionUpsertWithoutBalanceRecordInput
    disconnect?: TransactionWhereInput | boolean
    delete?: TransactionWhereInput | boolean
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutBalanceRecordInput, TransactionUpdateWithoutBalanceRecordInput>, TransactionUncheckedUpdateWithoutBalanceRecordInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type UserRoleCreateWithoutUserInput = {
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    roleId: number
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AttachmentCreateWithoutUserInput = {
    type: string
    location: string
    name?: string | null
    ossType?: string | null
    status?: number
    desc?: string | null
    createdAt?: Date | string | null
    AttachmentAttribute?: AttachmentAttributeCreateNestedManyWithoutAttachmentInput
    Course?: CourseCreateNestedManyWithoutCoverInput
    ContentAttachment?: ContentAttachmentCreateNestedManyWithoutAttachmentInput
  }

  export type AttachmentUncheckedCreateWithoutUserInput = {
    id?: number
    type: string
    location: string
    name?: string | null
    ossType?: string | null
    status?: number
    desc?: string | null
    createdAt?: Date | string | null
    AttachmentAttribute?: AttachmentAttributeUncheckedCreateNestedManyWithoutAttachmentInput
    Course?: CourseUncheckedCreateNestedManyWithoutCoverInput
    ContentAttachment?: ContentAttachmentUncheckedCreateNestedManyWithoutAttachmentInput
  }

  export type AttachmentCreateOrConnectWithoutUserInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutUserInput, AttachmentUncheckedCreateWithoutUserInput>
  }

  export type AttachmentCreateManyUserInputEnvelope = {
    data: AttachmentCreateManyUserInput | AttachmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutAuthorInput = {
    title: string
    subTitle?: string | null
    desc?: string | null
    originPrice?: number | null
    price?: number | null
    status?: number
    counts?: number
    order?: number
    detail?: string | null
    type?: string | null
    Cover?: AttachmentCreateNestedOneWithoutCourseInput
    Contents?: CourseContentCreateNestedManyWithoutCourseInput
    Tags?: CourseTagCreateNestedManyWithoutCourseInput
    CourseComment?: CourseCommentCreateNestedManyWithoutCourseInput
    Transaction?: TransactionCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutAuthorInput = {
    id?: number
    title: string
    subTitle?: string | null
    desc?: string | null
    coverId?: number | null
    originPrice?: number | null
    price?: number | null
    status?: number
    counts?: number
    order?: number
    detail?: string | null
    type?: string | null
    Contents?: CourseContentUncheckedCreateNestedManyWithoutCourseInput
    Tags?: CourseTagUncheckedCreateNestedManyWithoutCourseInput
    CourseComment?: CourseCommentUncheckedCreateNestedManyWithoutCourseInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutAuthorInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutAuthorInput, CourseUncheckedCreateWithoutAuthorInput>
  }

  export type CourseCreateManyAuthorInputEnvelope = {
    data: CourseCreateManyAuthorInput | CourseCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type CourseContentCreateWithoutAuthorInput = {
    title: string
    type?: string | null
    order?: number
    pid?: number | null
    status?: number
    Course: CourseCreateNestedOneWithoutContentsInput
    Attachments?: ContentAttachmentCreateNestedManyWithoutContentInput
    Tags?: ContentTagCreateNestedManyWithoutContentInput
    ContentComment?: ContentCommentCreateNestedManyWithoutContentInput
  }

  export type CourseContentUncheckedCreateWithoutAuthorInput = {
    id?: number
    courseId: number
    title: string
    type?: string | null
    order?: number
    pid?: number | null
    status?: number
    Attachments?: ContentAttachmentUncheckedCreateNestedManyWithoutContentInput
    Tags?: ContentTagUncheckedCreateNestedManyWithoutContentInput
    ContentComment?: ContentCommentUncheckedCreateNestedManyWithoutContentInput
  }

  export type CourseContentCreateOrConnectWithoutAuthorInput = {
    where: CourseContentWhereUniqueInput
    create: XOR<CourseContentCreateWithoutAuthorInput, CourseContentUncheckedCreateWithoutAuthorInput>
  }

  export type CourseContentCreateManyAuthorInputEnvelope = {
    data: CourseContentCreateManyAuthorInput | CourseContentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    created?: Date | string
    hands?: bigint | number
    status?: number
    isBest?: number
    parent?: CommentCreateNestedOneWithoutChildrenInput
    children?: CommentCreateNestedManyWithoutParentInput
    CourseComment?: CourseCommentCreateNestedManyWithoutCommentInput
    ContentComment?: ContentCommentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: number
    pid?: number | null
    created?: Date | string
    hands?: bigint | number
    status?: number
    isBest?: number
    children?: CommentUncheckedCreateNestedManyWithoutParentInput
    CourseComment?: CourseCommentUncheckedCreateNestedManyWithoutCommentInput
    ContentComment?: ContentCommentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutUserInput = {
    amount: number
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Course: CourseCreateNestedOneWithoutTransactionInput
    Platform: DictPlatformCreateNestedOneWithoutTransactionInput
    GroupTransaction?: GroupTransactionCreateNestedManyWithoutTransactionInput
    BalanceRecord?: BalanceRecordCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: number
    courseId: number
    amount: number
    platformId: number
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    GroupTransaction?: GroupTransactionUncheckedCreateNestedManyWithoutTransactionInput
    BalanceRecord?: BalanceRecordUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditRecordCreateWithoutReviewerInput = {
    entityId: number
    entityType: string
    status?: string | null
    createdAt?: Date | string
    notes?: string | null
    Stage: AuditStageCreateNestedOneWithoutAuditRecordInput
  }

  export type AuditRecordUncheckedCreateWithoutReviewerInput = {
    id?: number
    entityId: number
    entityType: string
    stageId: number
    status?: string | null
    createdAt?: Date | string
    notes?: string | null
  }

  export type AuditRecordCreateOrConnectWithoutReviewerInput = {
    where: AuditRecordWhereUniqueInput
    create: XOR<AuditRecordCreateWithoutReviewerInput, AuditRecordUncheckedCreateWithoutReviewerInput>
  }

  export type AuditRecordCreateManyReviewerInputEnvelope = {
    data: AuditRecordCreateManyReviewerInput | AuditRecordCreateManyReviewerInput[]
    skipDuplicates?: boolean
  }

  export type BalanceRecordCreateWithoutUserInput = {
    amount: number
    type?: number
    createdAt?: Date | string
    Transaction?: TransactionCreateNestedOneWithoutBalanceRecordInput
  }

  export type BalanceRecordUncheckedCreateWithoutUserInput = {
    id?: number
    transactionId?: number | null
    amount: number
    type?: number
    createdAt?: Date | string
  }

  export type BalanceRecordCreateOrConnectWithoutUserInput = {
    where: BalanceRecordWhereUniqueInput
    create: XOR<BalanceRecordCreateWithoutUserInput, BalanceRecordUncheckedCreateWithoutUserInput>
  }

  export type BalanceRecordCreateManyUserInputEnvelope = {
    data: BalanceRecordCreateManyUserInput | BalanceRecordCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NoteCreateWithoutUserInput = {
    content: string
    createAt?: Date | string
    updateAt?: Date | string | null
    status?: number | null
  }

  export type NoteUncheckedCreateWithoutUserInput = {
    id?: number
    content: string
    createAt?: Date | string
    updateAt?: Date | string | null
    status?: number | null
  }

  export type NoteCreateOrConnectWithoutUserInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput>
  }

  export type NoteCreateManyUserInputEnvelope = {
    data: NoteCreateManyUserInput | NoteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    userId?: IntFilter<"UserRole"> | number
    roleId?: IntFilter<"UserRole"> | number
  }

  export type AttachmentUpsertWithWhereUniqueWithoutUserInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutUserInput, AttachmentUncheckedUpdateWithoutUserInput>
    create: XOR<AttachmentCreateWithoutUserInput, AttachmentUncheckedCreateWithoutUserInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutUserInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutUserInput, AttachmentUncheckedUpdateWithoutUserInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutUserInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutUserInput>
  }

  export type AttachmentScalarWhereInput = {
    AND?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    OR?: AttachmentScalarWhereInput[]
    NOT?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    id?: IntFilter<"Attachment"> | number
    type?: StringFilter<"Attachment"> | string
    location?: StringFilter<"Attachment"> | string
    name?: StringNullableFilter<"Attachment"> | string | null
    ossType?: StringNullableFilter<"Attachment"> | string | null
    userId?: IntFilter<"Attachment"> | number
    status?: IntFilter<"Attachment"> | number
    desc?: StringNullableFilter<"Attachment"> | string | null
    createdAt?: DateTimeNullableFilter<"Attachment"> | Date | string | null
  }

  export type CourseUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutAuthorInput, CourseUncheckedUpdateWithoutAuthorInput>
    create: XOR<CourseCreateWithoutAuthorInput, CourseUncheckedCreateWithoutAuthorInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutAuthorInput, CourseUncheckedUpdateWithoutAuthorInput>
  }

  export type CourseUpdateManyWithWhereWithoutAuthorInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CourseScalarWhereInput = {
    AND?: CourseScalarWhereInput | CourseScalarWhereInput[]
    OR?: CourseScalarWhereInput[]
    NOT?: CourseScalarWhereInput | CourseScalarWhereInput[]
    id?: IntFilter<"Course"> | number
    title?: StringFilter<"Course"> | string
    subTitle?: StringNullableFilter<"Course"> | string | null
    desc?: StringNullableFilter<"Course"> | string | null
    coverId?: IntNullableFilter<"Course"> | number | null
    authorId?: IntFilter<"Course"> | number
    originPrice?: FloatNullableFilter<"Course"> | number | null
    price?: FloatNullableFilter<"Course"> | number | null
    status?: IntFilter<"Course"> | number
    counts?: IntFilter<"Course"> | number
    order?: IntFilter<"Course"> | number
    detail?: StringNullableFilter<"Course"> | string | null
    type?: StringNullableFilter<"Course"> | string | null
  }

  export type CourseContentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CourseContentWhereUniqueInput
    update: XOR<CourseContentUpdateWithoutAuthorInput, CourseContentUncheckedUpdateWithoutAuthorInput>
    create: XOR<CourseContentCreateWithoutAuthorInput, CourseContentUncheckedCreateWithoutAuthorInput>
  }

  export type CourseContentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CourseContentWhereUniqueInput
    data: XOR<CourseContentUpdateWithoutAuthorInput, CourseContentUncheckedUpdateWithoutAuthorInput>
  }

  export type CourseContentUpdateManyWithWhereWithoutAuthorInput = {
    where: CourseContentScalarWhereInput
    data: XOR<CourseContentUpdateManyMutationInput, CourseContentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CourseContentScalarWhereInput = {
    AND?: CourseContentScalarWhereInput | CourseContentScalarWhereInput[]
    OR?: CourseContentScalarWhereInput[]
    NOT?: CourseContentScalarWhereInput | CourseContentScalarWhereInput[]
    id?: IntFilter<"CourseContent"> | number
    courseId?: IntFilter<"CourseContent"> | number
    title?: StringFilter<"CourseContent"> | string
    type?: StringNullableFilter<"CourseContent"> | string | null
    order?: IntFilter<"CourseContent"> | number
    pid?: IntNullableFilter<"CourseContent"> | number | null
    status?: IntFilter<"CourseContent"> | number
    authorId?: IntFilter<"CourseContent"> | number
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: IntFilter<"Comment"> | number
    pid?: IntNullableFilter<"Comment"> | number | null
    userId?: IntFilter<"Comment"> | number
    created?: DateTimeFilter<"Comment"> | Date | string
    hands?: BigIntFilter<"Comment"> | bigint | number
    status?: IntFilter<"Comment"> | number
    isBest?: IntFilter<"Comment"> | number
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: IntFilter<"Transaction"> | number
    courseId?: IntFilter<"Transaction"> | number
    userId?: IntFilter<"Transaction"> | number
    amount?: FloatFilter<"Transaction"> | number
    platformId?: IntFilter<"Transaction"> | number
    status?: IntFilter<"Transaction"> | number
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
  }

  export type AuditRecordUpsertWithWhereUniqueWithoutReviewerInput = {
    where: AuditRecordWhereUniqueInput
    update: XOR<AuditRecordUpdateWithoutReviewerInput, AuditRecordUncheckedUpdateWithoutReviewerInput>
    create: XOR<AuditRecordCreateWithoutReviewerInput, AuditRecordUncheckedCreateWithoutReviewerInput>
  }

  export type AuditRecordUpdateWithWhereUniqueWithoutReviewerInput = {
    where: AuditRecordWhereUniqueInput
    data: XOR<AuditRecordUpdateWithoutReviewerInput, AuditRecordUncheckedUpdateWithoutReviewerInput>
  }

  export type AuditRecordUpdateManyWithWhereWithoutReviewerInput = {
    where: AuditRecordScalarWhereInput
    data: XOR<AuditRecordUpdateManyMutationInput, AuditRecordUncheckedUpdateManyWithoutReviewerInput>
  }

  export type AuditRecordScalarWhereInput = {
    AND?: AuditRecordScalarWhereInput | AuditRecordScalarWhereInput[]
    OR?: AuditRecordScalarWhereInput[]
    NOT?: AuditRecordScalarWhereInput | AuditRecordScalarWhereInput[]
    id?: IntFilter<"AuditRecord"> | number
    entityId?: IntFilter<"AuditRecord"> | number
    entityType?: StringFilter<"AuditRecord"> | string
    stageId?: IntFilter<"AuditRecord"> | number
    status?: StringNullableFilter<"AuditRecord"> | string | null
    reviewerId?: IntFilter<"AuditRecord"> | number
    createdAt?: DateTimeFilter<"AuditRecord"> | Date | string
    notes?: StringNullableFilter<"AuditRecord"> | string | null
  }

  export type BalanceRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: BalanceRecordWhereUniqueInput
    update: XOR<BalanceRecordUpdateWithoutUserInput, BalanceRecordUncheckedUpdateWithoutUserInput>
    create: XOR<BalanceRecordCreateWithoutUserInput, BalanceRecordUncheckedCreateWithoutUserInput>
  }

  export type BalanceRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: BalanceRecordWhereUniqueInput
    data: XOR<BalanceRecordUpdateWithoutUserInput, BalanceRecordUncheckedUpdateWithoutUserInput>
  }

  export type BalanceRecordUpdateManyWithWhereWithoutUserInput = {
    where: BalanceRecordScalarWhereInput
    data: XOR<BalanceRecordUpdateManyMutationInput, BalanceRecordUncheckedUpdateManyWithoutUserInput>
  }

  export type BalanceRecordScalarWhereInput = {
    AND?: BalanceRecordScalarWhereInput | BalanceRecordScalarWhereInput[]
    OR?: BalanceRecordScalarWhereInput[]
    NOT?: BalanceRecordScalarWhereInput | BalanceRecordScalarWhereInput[]
    id?: IntFilter<"BalanceRecord"> | number
    userId?: IntFilter<"BalanceRecord"> | number
    transactionId?: IntNullableFilter<"BalanceRecord"> | number | null
    amount?: FloatFilter<"BalanceRecord"> | number
    type?: IntFilter<"BalanceRecord"> | number
    createdAt?: DateTimeFilter<"BalanceRecord"> | Date | string
  }

  export type NoteUpsertWithWhereUniqueWithoutUserInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutUserInput, NoteUncheckedUpdateWithoutUserInput>
    create: XOR<NoteCreateWithoutUserInput, NoteUncheckedCreateWithoutUserInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutUserInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutUserInput, NoteUncheckedUpdateWithoutUserInput>
  }

  export type NoteUpdateManyWithWhereWithoutUserInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutUserInput>
  }

  export type NoteScalarWhereInput = {
    AND?: NoteScalarWhereInput | NoteScalarWhereInput[]
    OR?: NoteScalarWhereInput[]
    NOT?: NoteScalarWhereInput | NoteScalarWhereInput[]
    id?: IntFilter<"Note"> | number
    userId?: IntFilter<"Note"> | number
    content?: StringFilter<"Note"> | string
    createAt?: DateTimeFilter<"Note"> | Date | string
    updateAt?: DateTimeNullableFilter<"Note"> | Date | string | null
    status?: IntNullableFilter<"Note"> | number | null
  }

  export type UserRoleCreateWithoutRoleInput = {
    user: UserCreateNestedOneWithoutUserRoleInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    userId: number
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionsCreateWithoutRoleInput = {
    permission: PermissionCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionsUncheckedCreateWithoutRoleInput = {
    permissionId: number
  }

  export type RolePermissionsCreateOrConnectWithoutRoleInput = {
    where: RolePermissionsWhereUniqueInput
    create: XOR<RolePermissionsCreateWithoutRoleInput, RolePermissionsUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionsCreateManyRoleInputEnvelope = {
    data: RolePermissionsCreateManyRoleInput | RolePermissionsCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type RolePolicyCreateWithoutRoleInput = {
    policy: PolicyCreateNestedOneWithoutRolePolicyInput
  }

  export type RolePolicyUncheckedCreateWithoutRoleInput = {
    policyId: number
  }

  export type RolePolicyCreateOrConnectWithoutRoleInput = {
    where: RolePolicyWhereUniqueInput
    create: XOR<RolePolicyCreateWithoutRoleInput, RolePolicyUncheckedCreateWithoutRoleInput>
  }

  export type RolePolicyCreateManyRoleInputEnvelope = {
    data: RolePolicyCreateManyRoleInput | RolePolicyCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type RoleMenuCreateWithoutRoleInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    menu: MenuCreateNestedOneWithoutRoleMenusInput
  }

  export type RoleMenuUncheckedCreateWithoutRoleInput = {
    menuId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleMenuCreateOrConnectWithoutRoleInput = {
    where: RoleMenuWhereUniqueInput
    create: XOR<RoleMenuCreateWithoutRoleInput, RoleMenuUncheckedCreateWithoutRoleInput>
  }

  export type RoleMenuCreateManyRoleInputEnvelope = {
    data: RoleMenuCreateManyRoleInput | RoleMenuCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionsUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionsWhereUniqueInput
    update: XOR<RolePermissionsUpdateWithoutRoleInput, RolePermissionsUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePermissionsCreateWithoutRoleInput, RolePermissionsUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionsUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionsWhereUniqueInput
    data: XOR<RolePermissionsUpdateWithoutRoleInput, RolePermissionsUncheckedUpdateWithoutRoleInput>
  }

  export type RolePermissionsUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionsScalarWhereInput
    data: XOR<RolePermissionsUpdateManyMutationInput, RolePermissionsUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionsScalarWhereInput = {
    AND?: RolePermissionsScalarWhereInput | RolePermissionsScalarWhereInput[]
    OR?: RolePermissionsScalarWhereInput[]
    NOT?: RolePermissionsScalarWhereInput | RolePermissionsScalarWhereInput[]
    roleId?: IntFilter<"RolePermissions"> | number
    permissionId?: IntFilter<"RolePermissions"> | number
  }

  export type RolePolicyUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePolicyWhereUniqueInput
    update: XOR<RolePolicyUpdateWithoutRoleInput, RolePolicyUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePolicyCreateWithoutRoleInput, RolePolicyUncheckedCreateWithoutRoleInput>
  }

  export type RolePolicyUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePolicyWhereUniqueInput
    data: XOR<RolePolicyUpdateWithoutRoleInput, RolePolicyUncheckedUpdateWithoutRoleInput>
  }

  export type RolePolicyUpdateManyWithWhereWithoutRoleInput = {
    where: RolePolicyScalarWhereInput
    data: XOR<RolePolicyUpdateManyMutationInput, RolePolicyUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePolicyScalarWhereInput = {
    AND?: RolePolicyScalarWhereInput | RolePolicyScalarWhereInput[]
    OR?: RolePolicyScalarWhereInput[]
    NOT?: RolePolicyScalarWhereInput | RolePolicyScalarWhereInput[]
    roleId?: IntFilter<"RolePolicy"> | number
    policyId?: IntFilter<"RolePolicy"> | number
  }

  export type RoleMenuUpsertWithWhereUniqueWithoutRoleInput = {
    where: RoleMenuWhereUniqueInput
    update: XOR<RoleMenuUpdateWithoutRoleInput, RoleMenuUncheckedUpdateWithoutRoleInput>
    create: XOR<RoleMenuCreateWithoutRoleInput, RoleMenuUncheckedCreateWithoutRoleInput>
  }

  export type RoleMenuUpdateWithWhereUniqueWithoutRoleInput = {
    where: RoleMenuWhereUniqueInput
    data: XOR<RoleMenuUpdateWithoutRoleInput, RoleMenuUncheckedUpdateWithoutRoleInput>
  }

  export type RoleMenuUpdateManyWithWhereWithoutRoleInput = {
    where: RoleMenuScalarWhereInput
    data: XOR<RoleMenuUpdateManyMutationInput, RoleMenuUncheckedUpdateManyWithoutRoleInput>
  }

  export type RoleMenuScalarWhereInput = {
    AND?: RoleMenuScalarWhereInput | RoleMenuScalarWhereInput[]
    OR?: RoleMenuScalarWhereInput[]
    NOT?: RoleMenuScalarWhereInput | RoleMenuScalarWhereInput[]
    roleId?: IntFilter<"RoleMenu"> | number
    menuId?: IntFilter<"RoleMenu"> | number
    createdAt?: DateTimeFilter<"RoleMenu"> | Date | string
    updatedAt?: DateTimeFilter<"RoleMenu"> | Date | string
  }

  export type RoleCreateWithoutUsersInput = {
    name: string
    description?: string | null
    RolePermissions?: RolePermissionsCreateNestedManyWithoutRoleInput
    RolePolicy?: RolePolicyCreateNestedManyWithoutRoleInput
    RoleMenu?: RoleMenuCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    description?: string | null
    RolePermissions?: RolePermissionsUncheckedCreateNestedManyWithoutRoleInput
    RolePolicy?: RolePolicyUncheckedCreateNestedManyWithoutRoleInput
    RoleMenu?: RoleMenuUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutUserRoleInput = {
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Attachment?: AttachmentCreateNestedManyWithoutUserInput
    Course?: CourseCreateNestedManyWithoutAuthorInput
    CourseContent?: CourseContentCreateNestedManyWithoutAuthorInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    AuditRecord?: AuditRecordCreateNestedManyWithoutReviewerInput
    BalanceRecord?: BalanceRecordCreateNestedManyWithoutUserInput
    Note?: NoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserRoleInput = {
    id?: number
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Attachment?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    Course?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    CourseContent?: CourseContentUncheckedCreateNestedManyWithoutAuthorInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    AuditRecord?: AuditRecordUncheckedCreateNestedManyWithoutReviewerInput
    BalanceRecord?: BalanceRecordUncheckedCreateNestedManyWithoutUserInput
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserRoleInput, UserUncheckedCreateWithoutUserRoleInput>
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    RolePermissions?: RolePermissionsUpdateManyWithoutRoleNestedInput
    RolePolicy?: RolePolicyUpdateManyWithoutRoleNestedInput
    RoleMenu?: RoleMenuUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    RolePermissions?: RolePermissionsUncheckedUpdateManyWithoutRoleNestedInput
    RolePolicy?: RolePolicyUncheckedUpdateManyWithoutRoleNestedInput
    RoleMenu?: RoleMenuUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type UserUpsertWithoutUserRoleInput = {
    update: XOR<UserUpdateWithoutUserRoleInput, UserUncheckedUpdateWithoutUserRoleInput>
    create: XOR<UserCreateWithoutUserRoleInput, UserUncheckedCreateWithoutUserRoleInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserRoleInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserRoleInput, UserUncheckedUpdateWithoutUserRoleInput>
  }

  export type UserUpdateWithoutUserRoleInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Attachment?: AttachmentUpdateManyWithoutUserNestedInput
    Course?: CourseUpdateManyWithoutAuthorNestedInput
    CourseContent?: CourseContentUpdateManyWithoutAuthorNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    AuditRecord?: AuditRecordUpdateManyWithoutReviewerNestedInput
    BalanceRecord?: BalanceRecordUpdateManyWithoutUserNestedInput
    Note?: NoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Attachment?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    Course?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    CourseContent?: CourseContentUncheckedUpdateManyWithoutAuthorNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    AuditRecord?: AuditRecordUncheckedUpdateManyWithoutReviewerNestedInput
    BalanceRecord?: BalanceRecordUncheckedUpdateManyWithoutUserNestedInput
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RolePermissionsCreateWithoutPermissionInput = {
    role: RoleCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionsUncheckedCreateWithoutPermissionInput = {
    roleId: number
  }

  export type RolePermissionsCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionsWhereUniqueInput
    create: XOR<RolePermissionsCreateWithoutPermissionInput, RolePermissionsUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionsCreateManyPermissionInputEnvelope = {
    data: RolePermissionsCreateManyPermissionInput | RolePermissionsCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type PermissionPolicyCreateWithoutPermissionInput = {
    policy: PolicyCreateNestedOneWithoutPermissionPolicyInput
  }

  export type PermissionPolicyUncheckedCreateWithoutPermissionInput = {
    policyId: number
  }

  export type PermissionPolicyCreateOrConnectWithoutPermissionInput = {
    where: PermissionPolicyWhereUniqueInput
    create: XOR<PermissionPolicyCreateWithoutPermissionInput, PermissionPolicyUncheckedCreateWithoutPermissionInput>
  }

  export type PermissionPolicyCreateManyPermissionInputEnvelope = {
    data: PermissionPolicyCreateManyPermissionInput | PermissionPolicyCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionsUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionsWhereUniqueInput
    update: XOR<RolePermissionsUpdateWithoutPermissionInput, RolePermissionsUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionsCreateWithoutPermissionInput, RolePermissionsUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionsUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionsWhereUniqueInput
    data: XOR<RolePermissionsUpdateWithoutPermissionInput, RolePermissionsUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionsUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionsScalarWhereInput
    data: XOR<RolePermissionsUpdateManyMutationInput, RolePermissionsUncheckedUpdateManyWithoutPermissionInput>
  }

  export type PermissionPolicyUpsertWithWhereUniqueWithoutPermissionInput = {
    where: PermissionPolicyWhereUniqueInput
    update: XOR<PermissionPolicyUpdateWithoutPermissionInput, PermissionPolicyUncheckedUpdateWithoutPermissionInput>
    create: XOR<PermissionPolicyCreateWithoutPermissionInput, PermissionPolicyUncheckedCreateWithoutPermissionInput>
  }

  export type PermissionPolicyUpdateWithWhereUniqueWithoutPermissionInput = {
    where: PermissionPolicyWhereUniqueInput
    data: XOR<PermissionPolicyUpdateWithoutPermissionInput, PermissionPolicyUncheckedUpdateWithoutPermissionInput>
  }

  export type PermissionPolicyUpdateManyWithWhereWithoutPermissionInput = {
    where: PermissionPolicyScalarWhereInput
    data: XOR<PermissionPolicyUpdateManyMutationInput, PermissionPolicyUncheckedUpdateManyWithoutPermissionInput>
  }

  export type PermissionPolicyScalarWhereInput = {
    AND?: PermissionPolicyScalarWhereInput | PermissionPolicyScalarWhereInput[]
    OR?: PermissionPolicyScalarWhereInput[]
    NOT?: PermissionPolicyScalarWhereInput | PermissionPolicyScalarWhereInput[]
    permissionId?: IntFilter<"PermissionPolicy"> | number
    policyId?: IntFilter<"PermissionPolicy"> | number
  }

  export type RoleCreateWithoutRolePermissionsInput = {
    name: string
    description?: string | null
    users?: UserRoleCreateNestedManyWithoutRoleInput
    RolePolicy?: RolePolicyCreateNestedManyWithoutRoleInput
    RoleMenu?: RoleMenuCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutRolePermissionsInput = {
    id?: number
    name: string
    description?: string | null
    users?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
    RolePolicy?: RolePolicyUncheckedCreateNestedManyWithoutRoleInput
    RoleMenu?: RoleMenuUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutRolePermissionsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
  }

  export type PermissionCreateWithoutRolePermissionsInput = {
    name: string
    action: string
    description?: string | null
    PermissionPolicy?: PermissionPolicyCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateWithoutRolePermissionsInput = {
    id?: number
    name: string
    action: string
    description?: string | null
    PermissionPolicy?: PermissionPolicyUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionCreateOrConnectWithoutRolePermissionsInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
  }

  export type RoleUpsertWithoutRolePermissionsInput = {
    update: XOR<RoleUpdateWithoutRolePermissionsInput, RoleUncheckedUpdateWithoutRolePermissionsInput>
    create: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutRolePermissionsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutRolePermissionsInput, RoleUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type RoleUpdateWithoutRolePermissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserRoleUpdateManyWithoutRoleNestedInput
    RolePolicy?: RolePolicyUpdateManyWithoutRoleNestedInput
    RoleMenu?: RoleMenuUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutRolePermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
    RolePolicy?: RolePolicyUncheckedUpdateManyWithoutRoleNestedInput
    RoleMenu?: RoleMenuUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type PermissionUpsertWithoutRolePermissionsInput = {
    update: XOR<PermissionUpdateWithoutRolePermissionsInput, PermissionUncheckedUpdateWithoutRolePermissionsInput>
    create: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRolePermissionsInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRolePermissionsInput, PermissionUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type PermissionUpdateWithoutRolePermissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    PermissionPolicy?: PermissionPolicyUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateWithoutRolePermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    PermissionPolicy?: PermissionPolicyUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type RolePolicyCreateWithoutPolicyInput = {
    role: RoleCreateNestedOneWithoutRolePolicyInput
  }

  export type RolePolicyUncheckedCreateWithoutPolicyInput = {
    roleId: number
  }

  export type RolePolicyCreateOrConnectWithoutPolicyInput = {
    where: RolePolicyWhereUniqueInput
    create: XOR<RolePolicyCreateWithoutPolicyInput, RolePolicyUncheckedCreateWithoutPolicyInput>
  }

  export type RolePolicyCreateManyPolicyInputEnvelope = {
    data: RolePolicyCreateManyPolicyInput | RolePolicyCreateManyPolicyInput[]
    skipDuplicates?: boolean
  }

  export type PermissionPolicyCreateWithoutPolicyInput = {
    permission: PermissionCreateNestedOneWithoutPermissionPolicyInput
  }

  export type PermissionPolicyUncheckedCreateWithoutPolicyInput = {
    permissionId: number
  }

  export type PermissionPolicyCreateOrConnectWithoutPolicyInput = {
    where: PermissionPolicyWhereUniqueInput
    create: XOR<PermissionPolicyCreateWithoutPolicyInput, PermissionPolicyUncheckedCreateWithoutPolicyInput>
  }

  export type PermissionPolicyCreateManyPolicyInputEnvelope = {
    data: PermissionPolicyCreateManyPolicyInput | PermissionPolicyCreateManyPolicyInput[]
    skipDuplicates?: boolean
  }

  export type RolePolicyUpsertWithWhereUniqueWithoutPolicyInput = {
    where: RolePolicyWhereUniqueInput
    update: XOR<RolePolicyUpdateWithoutPolicyInput, RolePolicyUncheckedUpdateWithoutPolicyInput>
    create: XOR<RolePolicyCreateWithoutPolicyInput, RolePolicyUncheckedCreateWithoutPolicyInput>
  }

  export type RolePolicyUpdateWithWhereUniqueWithoutPolicyInput = {
    where: RolePolicyWhereUniqueInput
    data: XOR<RolePolicyUpdateWithoutPolicyInput, RolePolicyUncheckedUpdateWithoutPolicyInput>
  }

  export type RolePolicyUpdateManyWithWhereWithoutPolicyInput = {
    where: RolePolicyScalarWhereInput
    data: XOR<RolePolicyUpdateManyMutationInput, RolePolicyUncheckedUpdateManyWithoutPolicyInput>
  }

  export type PermissionPolicyUpsertWithWhereUniqueWithoutPolicyInput = {
    where: PermissionPolicyWhereUniqueInput
    update: XOR<PermissionPolicyUpdateWithoutPolicyInput, PermissionPolicyUncheckedUpdateWithoutPolicyInput>
    create: XOR<PermissionPolicyCreateWithoutPolicyInput, PermissionPolicyUncheckedCreateWithoutPolicyInput>
  }

  export type PermissionPolicyUpdateWithWhereUniqueWithoutPolicyInput = {
    where: PermissionPolicyWhereUniqueInput
    data: XOR<PermissionPolicyUpdateWithoutPolicyInput, PermissionPolicyUncheckedUpdateWithoutPolicyInput>
  }

  export type PermissionPolicyUpdateManyWithWhereWithoutPolicyInput = {
    where: PermissionPolicyScalarWhereInput
    data: XOR<PermissionPolicyUpdateManyMutationInput, PermissionPolicyUncheckedUpdateManyWithoutPolicyInput>
  }

  export type RoleCreateWithoutRolePolicyInput = {
    name: string
    description?: string | null
    users?: UserRoleCreateNestedManyWithoutRoleInput
    RolePermissions?: RolePermissionsCreateNestedManyWithoutRoleInput
    RoleMenu?: RoleMenuCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutRolePolicyInput = {
    id?: number
    name: string
    description?: string | null
    users?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
    RolePermissions?: RolePermissionsUncheckedCreateNestedManyWithoutRoleInput
    RoleMenu?: RoleMenuUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutRolePolicyInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutRolePolicyInput, RoleUncheckedCreateWithoutRolePolicyInput>
  }

  export type PolicyCreateWithoutRolePolicyInput = {
    type: number
    effect: string
    action: string
    subject: string
    fields?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    args?: NullableJsonNullValueInput | InputJsonValue
    encode: string
    PermissionPolicy?: PermissionPolicyCreateNestedManyWithoutPolicyInput
  }

  export type PolicyUncheckedCreateWithoutRolePolicyInput = {
    id?: number
    type: number
    effect: string
    action: string
    subject: string
    fields?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    args?: NullableJsonNullValueInput | InputJsonValue
    encode: string
    PermissionPolicy?: PermissionPolicyUncheckedCreateNestedManyWithoutPolicyInput
  }

  export type PolicyCreateOrConnectWithoutRolePolicyInput = {
    where: PolicyWhereUniqueInput
    create: XOR<PolicyCreateWithoutRolePolicyInput, PolicyUncheckedCreateWithoutRolePolicyInput>
  }

  export type RoleUpsertWithoutRolePolicyInput = {
    update: XOR<RoleUpdateWithoutRolePolicyInput, RoleUncheckedUpdateWithoutRolePolicyInput>
    create: XOR<RoleCreateWithoutRolePolicyInput, RoleUncheckedCreateWithoutRolePolicyInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutRolePolicyInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutRolePolicyInput, RoleUncheckedUpdateWithoutRolePolicyInput>
  }

  export type RoleUpdateWithoutRolePolicyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserRoleUpdateManyWithoutRoleNestedInput
    RolePermissions?: RolePermissionsUpdateManyWithoutRoleNestedInput
    RoleMenu?: RoleMenuUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutRolePolicyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
    RolePermissions?: RolePermissionsUncheckedUpdateManyWithoutRoleNestedInput
    RoleMenu?: RoleMenuUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type PolicyUpsertWithoutRolePolicyInput = {
    update: XOR<PolicyUpdateWithoutRolePolicyInput, PolicyUncheckedUpdateWithoutRolePolicyInput>
    create: XOR<PolicyCreateWithoutRolePolicyInput, PolicyUncheckedCreateWithoutRolePolicyInput>
    where?: PolicyWhereInput
  }

  export type PolicyUpdateToOneWithWhereWithoutRolePolicyInput = {
    where?: PolicyWhereInput
    data: XOR<PolicyUpdateWithoutRolePolicyInput, PolicyUncheckedUpdateWithoutRolePolicyInput>
  }

  export type PolicyUpdateWithoutRolePolicyInput = {
    type?: IntFieldUpdateOperationsInput | number
    effect?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    fields?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    args?: NullableJsonNullValueInput | InputJsonValue
    encode?: StringFieldUpdateOperationsInput | string
    PermissionPolicy?: PermissionPolicyUpdateManyWithoutPolicyNestedInput
  }

  export type PolicyUncheckedUpdateWithoutRolePolicyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    effect?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    fields?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    args?: NullableJsonNullValueInput | InputJsonValue
    encode?: StringFieldUpdateOperationsInput | string
    PermissionPolicy?: PermissionPolicyUncheckedUpdateManyWithoutPolicyNestedInput
  }

  export type PermissionCreateWithoutPermissionPolicyInput = {
    name: string
    action: string
    description?: string | null
    RolePermissions?: RolePermissionsCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateWithoutPermissionPolicyInput = {
    id?: number
    name: string
    action: string
    description?: string | null
    RolePermissions?: RolePermissionsUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionCreateOrConnectWithoutPermissionPolicyInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutPermissionPolicyInput, PermissionUncheckedCreateWithoutPermissionPolicyInput>
  }

  export type PolicyCreateWithoutPermissionPolicyInput = {
    type: number
    effect: string
    action: string
    subject: string
    fields?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    args?: NullableJsonNullValueInput | InputJsonValue
    encode: string
    RolePolicy?: RolePolicyCreateNestedManyWithoutPolicyInput
  }

  export type PolicyUncheckedCreateWithoutPermissionPolicyInput = {
    id?: number
    type: number
    effect: string
    action: string
    subject: string
    fields?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    args?: NullableJsonNullValueInput | InputJsonValue
    encode: string
    RolePolicy?: RolePolicyUncheckedCreateNestedManyWithoutPolicyInput
  }

  export type PolicyCreateOrConnectWithoutPermissionPolicyInput = {
    where: PolicyWhereUniqueInput
    create: XOR<PolicyCreateWithoutPermissionPolicyInput, PolicyUncheckedCreateWithoutPermissionPolicyInput>
  }

  export type PermissionUpsertWithoutPermissionPolicyInput = {
    update: XOR<PermissionUpdateWithoutPermissionPolicyInput, PermissionUncheckedUpdateWithoutPermissionPolicyInput>
    create: XOR<PermissionCreateWithoutPermissionPolicyInput, PermissionUncheckedCreateWithoutPermissionPolicyInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutPermissionPolicyInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutPermissionPolicyInput, PermissionUncheckedUpdateWithoutPermissionPolicyInput>
  }

  export type PermissionUpdateWithoutPermissionPolicyInput = {
    name?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    RolePermissions?: RolePermissionsUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateWithoutPermissionPolicyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    RolePermissions?: RolePermissionsUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PolicyUpsertWithoutPermissionPolicyInput = {
    update: XOR<PolicyUpdateWithoutPermissionPolicyInput, PolicyUncheckedUpdateWithoutPermissionPolicyInput>
    create: XOR<PolicyCreateWithoutPermissionPolicyInput, PolicyUncheckedCreateWithoutPermissionPolicyInput>
    where?: PolicyWhereInput
  }

  export type PolicyUpdateToOneWithWhereWithoutPermissionPolicyInput = {
    where?: PolicyWhereInput
    data: XOR<PolicyUpdateWithoutPermissionPolicyInput, PolicyUncheckedUpdateWithoutPermissionPolicyInput>
  }

  export type PolicyUpdateWithoutPermissionPolicyInput = {
    type?: IntFieldUpdateOperationsInput | number
    effect?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    fields?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    args?: NullableJsonNullValueInput | InputJsonValue
    encode?: StringFieldUpdateOperationsInput | string
    RolePolicy?: RolePolicyUpdateManyWithoutPolicyNestedInput
  }

  export type PolicyUncheckedUpdateWithoutPermissionPolicyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    effect?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    fields?: NullableJsonNullValueInput | InputJsonValue
    conditions?: NullableJsonNullValueInput | InputJsonValue
    args?: NullableJsonNullValueInput | InputJsonValue
    encode?: StringFieldUpdateOperationsInput | string
    RolePolicy?: RolePolicyUncheckedUpdateManyWithoutPolicyNestedInput
  }

  export type MenuMetaCreateWithoutMenuInput = {
    title?: string | null
    layout?: string | null
    order?: number | null
    hidden?: boolean
    disabled?: boolean
    icon?: string | null
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuMetaUncheckedCreateWithoutMenuInput = {
    id?: number
    title?: string | null
    layout?: string | null
    order?: number | null
    hidden?: boolean
    disabled?: boolean
    icon?: string | null
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuMetaCreateOrConnectWithoutMenuInput = {
    where: MenuMetaWhereUniqueInput
    create: XOR<MenuMetaCreateWithoutMenuInput, MenuMetaUncheckedCreateWithoutMenuInput>
  }

  export type MenuCreateWithoutChildrenInput = {
    name: string
    path: string
    label: string
    component?: string | null
    redirect?: string | null
    fullPath?: string | null
    alias?: string | null
    status?: number
    metaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meta?: MenuMetaCreateNestedOneWithoutMenuInput
    parent?: MenuCreateNestedOneWithoutChildrenInput
    roleMenus?: RoleMenuCreateNestedManyWithoutMenuInput
  }

  export type MenuUncheckedCreateWithoutChildrenInput = {
    id?: number
    name: string
    path: string
    label: string
    component?: string | null
    redirect?: string | null
    fullPath?: string | null
    alias?: string | null
    status?: number
    parentId?: number | null
    metaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meta?: MenuMetaUncheckedCreateNestedOneWithoutMenuInput
    roleMenus?: RoleMenuUncheckedCreateNestedManyWithoutMenuInput
  }

  export type MenuCreateOrConnectWithoutChildrenInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutChildrenInput, MenuUncheckedCreateWithoutChildrenInput>
  }

  export type MenuCreateWithoutParentInput = {
    name: string
    path: string
    label: string
    component?: string | null
    redirect?: string | null
    fullPath?: string | null
    alias?: string | null
    status?: number
    metaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meta?: MenuMetaCreateNestedOneWithoutMenuInput
    children?: MenuCreateNestedManyWithoutParentInput
    roleMenus?: RoleMenuCreateNestedManyWithoutMenuInput
  }

  export type MenuUncheckedCreateWithoutParentInput = {
    id?: number
    name: string
    path: string
    label: string
    component?: string | null
    redirect?: string | null
    fullPath?: string | null
    alias?: string | null
    status?: number
    metaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meta?: MenuMetaUncheckedCreateNestedOneWithoutMenuInput
    children?: MenuUncheckedCreateNestedManyWithoutParentInput
    roleMenus?: RoleMenuUncheckedCreateNestedManyWithoutMenuInput
  }

  export type MenuCreateOrConnectWithoutParentInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutParentInput, MenuUncheckedCreateWithoutParentInput>
  }

  export type MenuCreateManyParentInputEnvelope = {
    data: MenuCreateManyParentInput | MenuCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type RoleMenuCreateWithoutMenuInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutRoleMenuInput
  }

  export type RoleMenuUncheckedCreateWithoutMenuInput = {
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleMenuCreateOrConnectWithoutMenuInput = {
    where: RoleMenuWhereUniqueInput
    create: XOR<RoleMenuCreateWithoutMenuInput, RoleMenuUncheckedCreateWithoutMenuInput>
  }

  export type RoleMenuCreateManyMenuInputEnvelope = {
    data: RoleMenuCreateManyMenuInput | RoleMenuCreateManyMenuInput[]
    skipDuplicates?: boolean
  }

  export type MenuMetaUpsertWithoutMenuInput = {
    update: XOR<MenuMetaUpdateWithoutMenuInput, MenuMetaUncheckedUpdateWithoutMenuInput>
    create: XOR<MenuMetaCreateWithoutMenuInput, MenuMetaUncheckedCreateWithoutMenuInput>
    where?: MenuMetaWhereInput
  }

  export type MenuMetaUpdateToOneWithWhereWithoutMenuInput = {
    where?: MenuMetaWhereInput
    data: XOR<MenuMetaUpdateWithoutMenuInput, MenuMetaUncheckedUpdateWithoutMenuInput>
  }

  export type MenuMetaUpdateWithoutMenuInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    layout?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuMetaUncheckedUpdateWithoutMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    layout?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    hidden?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuUpsertWithoutChildrenInput = {
    update: XOR<MenuUpdateWithoutChildrenInput, MenuUncheckedUpdateWithoutChildrenInput>
    create: XOR<MenuCreateWithoutChildrenInput, MenuUncheckedCreateWithoutChildrenInput>
    where?: MenuWhereInput
  }

  export type MenuUpdateToOneWithWhereWithoutChildrenInput = {
    where?: MenuWhereInput
    data: XOR<MenuUpdateWithoutChildrenInput, MenuUncheckedUpdateWithoutChildrenInput>
  }

  export type MenuUpdateWithoutChildrenInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    component?: NullableStringFieldUpdateOperationsInput | string | null
    redirect?: NullableStringFieldUpdateOperationsInput | string | null
    fullPath?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    metaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meta?: MenuMetaUpdateOneWithoutMenuNestedInput
    parent?: MenuUpdateOneWithoutChildrenNestedInput
    roleMenus?: RoleMenuUpdateManyWithoutMenuNestedInput
  }

  export type MenuUncheckedUpdateWithoutChildrenInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    component?: NullableStringFieldUpdateOperationsInput | string | null
    redirect?: NullableStringFieldUpdateOperationsInput | string | null
    fullPath?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    metaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meta?: MenuMetaUncheckedUpdateOneWithoutMenuNestedInput
    roleMenus?: RoleMenuUncheckedUpdateManyWithoutMenuNestedInput
  }

  export type MenuUpsertWithWhereUniqueWithoutParentInput = {
    where: MenuWhereUniqueInput
    update: XOR<MenuUpdateWithoutParentInput, MenuUncheckedUpdateWithoutParentInput>
    create: XOR<MenuCreateWithoutParentInput, MenuUncheckedCreateWithoutParentInput>
  }

  export type MenuUpdateWithWhereUniqueWithoutParentInput = {
    where: MenuWhereUniqueInput
    data: XOR<MenuUpdateWithoutParentInput, MenuUncheckedUpdateWithoutParentInput>
  }

  export type MenuUpdateManyWithWhereWithoutParentInput = {
    where: MenuScalarWhereInput
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyWithoutParentInput>
  }

  export type MenuScalarWhereInput = {
    AND?: MenuScalarWhereInput | MenuScalarWhereInput[]
    OR?: MenuScalarWhereInput[]
    NOT?: MenuScalarWhereInput | MenuScalarWhereInput[]
    id?: IntFilter<"Menu"> | number
    name?: StringFilter<"Menu"> | string
    path?: StringFilter<"Menu"> | string
    label?: StringFilter<"Menu"> | string
    component?: StringNullableFilter<"Menu"> | string | null
    redirect?: StringNullableFilter<"Menu"> | string | null
    fullPath?: StringNullableFilter<"Menu"> | string | null
    alias?: StringNullableFilter<"Menu"> | string | null
    status?: IntFilter<"Menu"> | number
    parentId?: IntNullableFilter<"Menu"> | number | null
    metaId?: IntNullableFilter<"Menu"> | number | null
    createdAt?: DateTimeFilter<"Menu"> | Date | string
    updatedAt?: DateTimeFilter<"Menu"> | Date | string
  }

  export type RoleMenuUpsertWithWhereUniqueWithoutMenuInput = {
    where: RoleMenuWhereUniqueInput
    update: XOR<RoleMenuUpdateWithoutMenuInput, RoleMenuUncheckedUpdateWithoutMenuInput>
    create: XOR<RoleMenuCreateWithoutMenuInput, RoleMenuUncheckedCreateWithoutMenuInput>
  }

  export type RoleMenuUpdateWithWhereUniqueWithoutMenuInput = {
    where: RoleMenuWhereUniqueInput
    data: XOR<RoleMenuUpdateWithoutMenuInput, RoleMenuUncheckedUpdateWithoutMenuInput>
  }

  export type RoleMenuUpdateManyWithWhereWithoutMenuInput = {
    where: RoleMenuScalarWhereInput
    data: XOR<RoleMenuUpdateManyMutationInput, RoleMenuUncheckedUpdateManyWithoutMenuInput>
  }

  export type MenuCreateWithoutMetaInput = {
    name: string
    path: string
    label: string
    component?: string | null
    redirect?: string | null
    fullPath?: string | null
    alias?: string | null
    status?: number
    metaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: MenuCreateNestedOneWithoutChildrenInput
    children?: MenuCreateNestedManyWithoutParentInput
    roleMenus?: RoleMenuCreateNestedManyWithoutMenuInput
  }

  export type MenuUncheckedCreateWithoutMetaInput = {
    id?: number
    name: string
    path: string
    label: string
    component?: string | null
    redirect?: string | null
    fullPath?: string | null
    alias?: string | null
    status?: number
    parentId?: number | null
    metaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: MenuUncheckedCreateNestedManyWithoutParentInput
    roleMenus?: RoleMenuUncheckedCreateNestedManyWithoutMenuInput
  }

  export type MenuCreateOrConnectWithoutMetaInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutMetaInput, MenuUncheckedCreateWithoutMetaInput>
  }

  export type MenuUpsertWithoutMetaInput = {
    update: XOR<MenuUpdateWithoutMetaInput, MenuUncheckedUpdateWithoutMetaInput>
    create: XOR<MenuCreateWithoutMetaInput, MenuUncheckedCreateWithoutMetaInput>
    where?: MenuWhereInput
  }

  export type MenuUpdateToOneWithWhereWithoutMetaInput = {
    where?: MenuWhereInput
    data: XOR<MenuUpdateWithoutMetaInput, MenuUncheckedUpdateWithoutMetaInput>
  }

  export type MenuUpdateWithoutMetaInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    component?: NullableStringFieldUpdateOperationsInput | string | null
    redirect?: NullableStringFieldUpdateOperationsInput | string | null
    fullPath?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    metaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: MenuUpdateOneWithoutChildrenNestedInput
    children?: MenuUpdateManyWithoutParentNestedInput
    roleMenus?: RoleMenuUpdateManyWithoutMenuNestedInput
  }

  export type MenuUncheckedUpdateWithoutMetaInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    component?: NullableStringFieldUpdateOperationsInput | string | null
    redirect?: NullableStringFieldUpdateOperationsInput | string | null
    fullPath?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    metaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: MenuUncheckedUpdateManyWithoutParentNestedInput
    roleMenus?: RoleMenuUncheckedUpdateManyWithoutMenuNestedInput
  }

  export type RoleCreateWithoutRoleMenuInput = {
    name: string
    description?: string | null
    users?: UserRoleCreateNestedManyWithoutRoleInput
    RolePermissions?: RolePermissionsCreateNestedManyWithoutRoleInput
    RolePolicy?: RolePolicyCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutRoleMenuInput = {
    id?: number
    name: string
    description?: string | null
    users?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
    RolePermissions?: RolePermissionsUncheckedCreateNestedManyWithoutRoleInput
    RolePolicy?: RolePolicyUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutRoleMenuInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutRoleMenuInput, RoleUncheckedCreateWithoutRoleMenuInput>
  }

  export type MenuCreateWithoutRoleMenusInput = {
    name: string
    path: string
    label: string
    component?: string | null
    redirect?: string | null
    fullPath?: string | null
    alias?: string | null
    status?: number
    metaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meta?: MenuMetaCreateNestedOneWithoutMenuInput
    parent?: MenuCreateNestedOneWithoutChildrenInput
    children?: MenuCreateNestedManyWithoutParentInput
  }

  export type MenuUncheckedCreateWithoutRoleMenusInput = {
    id?: number
    name: string
    path: string
    label: string
    component?: string | null
    redirect?: string | null
    fullPath?: string | null
    alias?: string | null
    status?: number
    parentId?: number | null
    metaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meta?: MenuMetaUncheckedCreateNestedOneWithoutMenuInput
    children?: MenuUncheckedCreateNestedManyWithoutParentInput
  }

  export type MenuCreateOrConnectWithoutRoleMenusInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutRoleMenusInput, MenuUncheckedCreateWithoutRoleMenusInput>
  }

  export type RoleUpsertWithoutRoleMenuInput = {
    update: XOR<RoleUpdateWithoutRoleMenuInput, RoleUncheckedUpdateWithoutRoleMenuInput>
    create: XOR<RoleCreateWithoutRoleMenuInput, RoleUncheckedCreateWithoutRoleMenuInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutRoleMenuInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutRoleMenuInput, RoleUncheckedUpdateWithoutRoleMenuInput>
  }

  export type RoleUpdateWithoutRoleMenuInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserRoleUpdateManyWithoutRoleNestedInput
    RolePermissions?: RolePermissionsUpdateManyWithoutRoleNestedInput
    RolePolicy?: RolePolicyUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutRoleMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
    RolePermissions?: RolePermissionsUncheckedUpdateManyWithoutRoleNestedInput
    RolePolicy?: RolePolicyUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type MenuUpsertWithoutRoleMenusInput = {
    update: XOR<MenuUpdateWithoutRoleMenusInput, MenuUncheckedUpdateWithoutRoleMenusInput>
    create: XOR<MenuCreateWithoutRoleMenusInput, MenuUncheckedCreateWithoutRoleMenusInput>
    where?: MenuWhereInput
  }

  export type MenuUpdateToOneWithWhereWithoutRoleMenusInput = {
    where?: MenuWhereInput
    data: XOR<MenuUpdateWithoutRoleMenusInput, MenuUncheckedUpdateWithoutRoleMenusInput>
  }

  export type MenuUpdateWithoutRoleMenusInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    component?: NullableStringFieldUpdateOperationsInput | string | null
    redirect?: NullableStringFieldUpdateOperationsInput | string | null
    fullPath?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    metaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meta?: MenuMetaUpdateOneWithoutMenuNestedInput
    parent?: MenuUpdateOneWithoutChildrenNestedInput
    children?: MenuUpdateManyWithoutParentNestedInput
  }

  export type MenuUncheckedUpdateWithoutRoleMenusInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    component?: NullableStringFieldUpdateOperationsInput | string | null
    redirect?: NullableStringFieldUpdateOperationsInput | string | null
    fullPath?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    metaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meta?: MenuMetaUncheckedUpdateOneWithoutMenuNestedInput
    children?: MenuUncheckedUpdateManyWithoutParentNestedInput
  }

  export type AttachmentAttributeCreateWithoutDictAttributeInput = {
    value: string
    desc?: string | null
    Attachment: AttachmentCreateNestedOneWithoutAttachmentAttributeInput
  }

  export type AttachmentAttributeUncheckedCreateWithoutDictAttributeInput = {
    attachmentId: number
    value: string
    desc?: string | null
  }

  export type AttachmentAttributeCreateOrConnectWithoutDictAttributeInput = {
    where: AttachmentAttributeWhereUniqueInput
    create: XOR<AttachmentAttributeCreateWithoutDictAttributeInput, AttachmentAttributeUncheckedCreateWithoutDictAttributeInput>
  }

  export type AttachmentAttributeCreateManyDictAttributeInputEnvelope = {
    data: AttachmentAttributeCreateManyDictAttributeInput | AttachmentAttributeCreateManyDictAttributeInput[]
    skipDuplicates?: boolean
  }

  export type AttachmentAttributeUpsertWithWhereUniqueWithoutDictAttributeInput = {
    where: AttachmentAttributeWhereUniqueInput
    update: XOR<AttachmentAttributeUpdateWithoutDictAttributeInput, AttachmentAttributeUncheckedUpdateWithoutDictAttributeInput>
    create: XOR<AttachmentAttributeCreateWithoutDictAttributeInput, AttachmentAttributeUncheckedCreateWithoutDictAttributeInput>
  }

  export type AttachmentAttributeUpdateWithWhereUniqueWithoutDictAttributeInput = {
    where: AttachmentAttributeWhereUniqueInput
    data: XOR<AttachmentAttributeUpdateWithoutDictAttributeInput, AttachmentAttributeUncheckedUpdateWithoutDictAttributeInput>
  }

  export type AttachmentAttributeUpdateManyWithWhereWithoutDictAttributeInput = {
    where: AttachmentAttributeScalarWhereInput
    data: XOR<AttachmentAttributeUpdateManyMutationInput, AttachmentAttributeUncheckedUpdateManyWithoutDictAttributeInput>
  }

  export type AttachmentAttributeScalarWhereInput = {
    AND?: AttachmentAttributeScalarWhereInput | AttachmentAttributeScalarWhereInput[]
    OR?: AttachmentAttributeScalarWhereInput[]
    NOT?: AttachmentAttributeScalarWhereInput | AttachmentAttributeScalarWhereInput[]
    attachmentId?: IntFilter<"AttachmentAttribute"> | number
    attributeId?: IntFilter<"AttachmentAttribute"> | number
    value?: StringFilter<"AttachmentAttribute"> | string
    desc?: StringNullableFilter<"AttachmentAttribute"> | string | null
  }

  export type AttachmentCreateWithoutAttachmentAttributeInput = {
    type: string
    location: string
    name?: string | null
    ossType?: string | null
    status?: number
    desc?: string | null
    createdAt?: Date | string | null
    User: UserCreateNestedOneWithoutAttachmentInput
    Course?: CourseCreateNestedManyWithoutCoverInput
    ContentAttachment?: ContentAttachmentCreateNestedManyWithoutAttachmentInput
  }

  export type AttachmentUncheckedCreateWithoutAttachmentAttributeInput = {
    id?: number
    type: string
    location: string
    name?: string | null
    ossType?: string | null
    userId: number
    status?: number
    desc?: string | null
    createdAt?: Date | string | null
    Course?: CourseUncheckedCreateNestedManyWithoutCoverInput
    ContentAttachment?: ContentAttachmentUncheckedCreateNestedManyWithoutAttachmentInput
  }

  export type AttachmentCreateOrConnectWithoutAttachmentAttributeInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutAttachmentAttributeInput, AttachmentUncheckedCreateWithoutAttachmentAttributeInput>
  }

  export type DictAttachmentAttributeCreateWithoutAttachmentAttributeInput = {
    type: string
    name: string
    desc?: string | null
  }

  export type DictAttachmentAttributeUncheckedCreateWithoutAttachmentAttributeInput = {
    id?: number
    type: string
    name: string
    desc?: string | null
  }

  export type DictAttachmentAttributeCreateOrConnectWithoutAttachmentAttributeInput = {
    where: DictAttachmentAttributeWhereUniqueInput
    create: XOR<DictAttachmentAttributeCreateWithoutAttachmentAttributeInput, DictAttachmentAttributeUncheckedCreateWithoutAttachmentAttributeInput>
  }

  export type AttachmentUpsertWithoutAttachmentAttributeInput = {
    update: XOR<AttachmentUpdateWithoutAttachmentAttributeInput, AttachmentUncheckedUpdateWithoutAttachmentAttributeInput>
    create: XOR<AttachmentCreateWithoutAttachmentAttributeInput, AttachmentUncheckedCreateWithoutAttachmentAttributeInput>
    where?: AttachmentWhereInput
  }

  export type AttachmentUpdateToOneWithWhereWithoutAttachmentAttributeInput = {
    where?: AttachmentWhereInput
    data: XOR<AttachmentUpdateWithoutAttachmentAttributeInput, AttachmentUncheckedUpdateWithoutAttachmentAttributeInput>
  }

  export type AttachmentUpdateWithoutAttachmentAttributeInput = {
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    ossType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneRequiredWithoutAttachmentNestedInput
    Course?: CourseUpdateManyWithoutCoverNestedInput
    ContentAttachment?: ContentAttachmentUpdateManyWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutAttachmentAttributeInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    ossType?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Course?: CourseUncheckedUpdateManyWithoutCoverNestedInput
    ContentAttachment?: ContentAttachmentUncheckedUpdateManyWithoutAttachmentNestedInput
  }

  export type DictAttachmentAttributeUpsertWithoutAttachmentAttributeInput = {
    update: XOR<DictAttachmentAttributeUpdateWithoutAttachmentAttributeInput, DictAttachmentAttributeUncheckedUpdateWithoutAttachmentAttributeInput>
    create: XOR<DictAttachmentAttributeCreateWithoutAttachmentAttributeInput, DictAttachmentAttributeUncheckedCreateWithoutAttachmentAttributeInput>
    where?: DictAttachmentAttributeWhereInput
  }

  export type DictAttachmentAttributeUpdateToOneWithWhereWithoutAttachmentAttributeInput = {
    where?: DictAttachmentAttributeWhereInput
    data: XOR<DictAttachmentAttributeUpdateWithoutAttachmentAttributeInput, DictAttachmentAttributeUncheckedUpdateWithoutAttachmentAttributeInput>
  }

  export type DictAttachmentAttributeUpdateWithoutAttachmentAttributeInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DictAttachmentAttributeUncheckedUpdateWithoutAttachmentAttributeInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutAttachmentInput = {
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    Course?: CourseCreateNestedManyWithoutAuthorInput
    CourseContent?: CourseContentCreateNestedManyWithoutAuthorInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    AuditRecord?: AuditRecordCreateNestedManyWithoutReviewerInput
    BalanceRecord?: BalanceRecordCreateNestedManyWithoutUserInput
    Note?: NoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAttachmentInput = {
    id?: number
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    Course?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    CourseContent?: CourseContentUncheckedCreateNestedManyWithoutAuthorInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    AuditRecord?: AuditRecordUncheckedCreateNestedManyWithoutReviewerInput
    BalanceRecord?: BalanceRecordUncheckedCreateNestedManyWithoutUserInput
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAttachmentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttachmentInput, UserUncheckedCreateWithoutAttachmentInput>
  }

  export type AttachmentAttributeCreateWithoutAttachmentInput = {
    value: string
    desc?: string | null
    DictAttribute: DictAttachmentAttributeCreateNestedOneWithoutAttachmentAttributeInput
  }

  export type AttachmentAttributeUncheckedCreateWithoutAttachmentInput = {
    attributeId: number
    value: string
    desc?: string | null
  }

  export type AttachmentAttributeCreateOrConnectWithoutAttachmentInput = {
    where: AttachmentAttributeWhereUniqueInput
    create: XOR<AttachmentAttributeCreateWithoutAttachmentInput, AttachmentAttributeUncheckedCreateWithoutAttachmentInput>
  }

  export type AttachmentAttributeCreateManyAttachmentInputEnvelope = {
    data: AttachmentAttributeCreateManyAttachmentInput | AttachmentAttributeCreateManyAttachmentInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutCoverInput = {
    title: string
    subTitle?: string | null
    desc?: string | null
    originPrice?: number | null
    price?: number | null
    status?: number
    counts?: number
    order?: number
    detail?: string | null
    type?: string | null
    Author: UserCreateNestedOneWithoutCourseInput
    Contents?: CourseContentCreateNestedManyWithoutCourseInput
    Tags?: CourseTagCreateNestedManyWithoutCourseInput
    CourseComment?: CourseCommentCreateNestedManyWithoutCourseInput
    Transaction?: TransactionCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCoverInput = {
    id?: number
    title: string
    subTitle?: string | null
    desc?: string | null
    authorId: number
    originPrice?: number | null
    price?: number | null
    status?: number
    counts?: number
    order?: number
    detail?: string | null
    type?: string | null
    Contents?: CourseContentUncheckedCreateNestedManyWithoutCourseInput
    Tags?: CourseTagUncheckedCreateNestedManyWithoutCourseInput
    CourseComment?: CourseCommentUncheckedCreateNestedManyWithoutCourseInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCoverInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCoverInput, CourseUncheckedCreateWithoutCoverInput>
  }

  export type CourseCreateManyCoverInputEnvelope = {
    data: CourseCreateManyCoverInput | CourseCreateManyCoverInput[]
    skipDuplicates?: boolean
  }

  export type ContentAttachmentCreateWithoutAttachmentInput = {
    Content: CourseContentCreateNestedOneWithoutAttachmentsInput
  }

  export type ContentAttachmentUncheckedCreateWithoutAttachmentInput = {
    contentId: number
  }

  export type ContentAttachmentCreateOrConnectWithoutAttachmentInput = {
    where: ContentAttachmentWhereUniqueInput
    create: XOR<ContentAttachmentCreateWithoutAttachmentInput, ContentAttachmentUncheckedCreateWithoutAttachmentInput>
  }

  export type ContentAttachmentCreateManyAttachmentInputEnvelope = {
    data: ContentAttachmentCreateManyAttachmentInput | ContentAttachmentCreateManyAttachmentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAttachmentInput = {
    update: XOR<UserUpdateWithoutAttachmentInput, UserUncheckedUpdateWithoutAttachmentInput>
    create: XOR<UserCreateWithoutAttachmentInput, UserUncheckedCreateWithoutAttachmentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttachmentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttachmentInput, UserUncheckedUpdateWithoutAttachmentInput>
  }

  export type UserUpdateWithoutAttachmentInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserRole?: UserRoleUpdateManyWithoutUserNestedInput
    Course?: CourseUpdateManyWithoutAuthorNestedInput
    CourseContent?: CourseContentUpdateManyWithoutAuthorNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    AuditRecord?: AuditRecordUpdateManyWithoutReviewerNestedInput
    BalanceRecord?: BalanceRecordUpdateManyWithoutUserNestedInput
    Note?: NoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAttachmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    Course?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    CourseContent?: CourseContentUncheckedUpdateManyWithoutAuthorNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    AuditRecord?: AuditRecordUncheckedUpdateManyWithoutReviewerNestedInput
    BalanceRecord?: BalanceRecordUncheckedUpdateManyWithoutUserNestedInput
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AttachmentAttributeUpsertWithWhereUniqueWithoutAttachmentInput = {
    where: AttachmentAttributeWhereUniqueInput
    update: XOR<AttachmentAttributeUpdateWithoutAttachmentInput, AttachmentAttributeUncheckedUpdateWithoutAttachmentInput>
    create: XOR<AttachmentAttributeCreateWithoutAttachmentInput, AttachmentAttributeUncheckedCreateWithoutAttachmentInput>
  }

  export type AttachmentAttributeUpdateWithWhereUniqueWithoutAttachmentInput = {
    where: AttachmentAttributeWhereUniqueInput
    data: XOR<AttachmentAttributeUpdateWithoutAttachmentInput, AttachmentAttributeUncheckedUpdateWithoutAttachmentInput>
  }

  export type AttachmentAttributeUpdateManyWithWhereWithoutAttachmentInput = {
    where: AttachmentAttributeScalarWhereInput
    data: XOR<AttachmentAttributeUpdateManyMutationInput, AttachmentAttributeUncheckedUpdateManyWithoutAttachmentInput>
  }

  export type CourseUpsertWithWhereUniqueWithoutCoverInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutCoverInput, CourseUncheckedUpdateWithoutCoverInput>
    create: XOR<CourseCreateWithoutCoverInput, CourseUncheckedCreateWithoutCoverInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutCoverInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutCoverInput, CourseUncheckedUpdateWithoutCoverInput>
  }

  export type CourseUpdateManyWithWhereWithoutCoverInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutCoverInput>
  }

  export type ContentAttachmentUpsertWithWhereUniqueWithoutAttachmentInput = {
    where: ContentAttachmentWhereUniqueInput
    update: XOR<ContentAttachmentUpdateWithoutAttachmentInput, ContentAttachmentUncheckedUpdateWithoutAttachmentInput>
    create: XOR<ContentAttachmentCreateWithoutAttachmentInput, ContentAttachmentUncheckedCreateWithoutAttachmentInput>
  }

  export type ContentAttachmentUpdateWithWhereUniqueWithoutAttachmentInput = {
    where: ContentAttachmentWhereUniqueInput
    data: XOR<ContentAttachmentUpdateWithoutAttachmentInput, ContentAttachmentUncheckedUpdateWithoutAttachmentInput>
  }

  export type ContentAttachmentUpdateManyWithWhereWithoutAttachmentInput = {
    where: ContentAttachmentScalarWhereInput
    data: XOR<ContentAttachmentUpdateManyMutationInput, ContentAttachmentUncheckedUpdateManyWithoutAttachmentInput>
  }

  export type ContentAttachmentScalarWhereInput = {
    AND?: ContentAttachmentScalarWhereInput | ContentAttachmentScalarWhereInput[]
    OR?: ContentAttachmentScalarWhereInput[]
    NOT?: ContentAttachmentScalarWhereInput | ContentAttachmentScalarWhereInput[]
    contentId?: IntFilter<"ContentAttachment"> | number
    attachmentId?: IntFilter<"ContentAttachment"> | number
  }

  export type AttachmentCreateWithoutCourseInput = {
    type: string
    location: string
    name?: string | null
    ossType?: string | null
    status?: number
    desc?: string | null
    createdAt?: Date | string | null
    User: UserCreateNestedOneWithoutAttachmentInput
    AttachmentAttribute?: AttachmentAttributeCreateNestedManyWithoutAttachmentInput
    ContentAttachment?: ContentAttachmentCreateNestedManyWithoutAttachmentInput
  }

  export type AttachmentUncheckedCreateWithoutCourseInput = {
    id?: number
    type: string
    location: string
    name?: string | null
    ossType?: string | null
    userId: number
    status?: number
    desc?: string | null
    createdAt?: Date | string | null
    AttachmentAttribute?: AttachmentAttributeUncheckedCreateNestedManyWithoutAttachmentInput
    ContentAttachment?: ContentAttachmentUncheckedCreateNestedManyWithoutAttachmentInput
  }

  export type AttachmentCreateOrConnectWithoutCourseInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutCourseInput, AttachmentUncheckedCreateWithoutCourseInput>
  }

  export type UserCreateWithoutCourseInput = {
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    Attachment?: AttachmentCreateNestedManyWithoutUserInput
    CourseContent?: CourseContentCreateNestedManyWithoutAuthorInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    AuditRecord?: AuditRecordCreateNestedManyWithoutReviewerInput
    BalanceRecord?: BalanceRecordCreateNestedManyWithoutUserInput
    Note?: NoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCourseInput = {
    id?: number
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    Attachment?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    CourseContent?: CourseContentUncheckedCreateNestedManyWithoutAuthorInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    AuditRecord?: AuditRecordUncheckedCreateNestedManyWithoutReviewerInput
    BalanceRecord?: BalanceRecordUncheckedCreateNestedManyWithoutUserInput
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCourseInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCourseInput, UserUncheckedCreateWithoutCourseInput>
  }

  export type CourseContentCreateWithoutCourseInput = {
    title: string
    type?: string | null
    order?: number
    pid?: number | null
    status?: number
    Author: UserCreateNestedOneWithoutCourseContentInput
    Attachments?: ContentAttachmentCreateNestedManyWithoutContentInput
    Tags?: ContentTagCreateNestedManyWithoutContentInput
    ContentComment?: ContentCommentCreateNestedManyWithoutContentInput
  }

  export type CourseContentUncheckedCreateWithoutCourseInput = {
    id?: number
    title: string
    type?: string | null
    order?: number
    pid?: number | null
    status?: number
    authorId: number
    Attachments?: ContentAttachmentUncheckedCreateNestedManyWithoutContentInput
    Tags?: ContentTagUncheckedCreateNestedManyWithoutContentInput
    ContentComment?: ContentCommentUncheckedCreateNestedManyWithoutContentInput
  }

  export type CourseContentCreateOrConnectWithoutCourseInput = {
    where: CourseContentWhereUniqueInput
    create: XOR<CourseContentCreateWithoutCourseInput, CourseContentUncheckedCreateWithoutCourseInput>
  }

  export type CourseContentCreateManyCourseInputEnvelope = {
    data: CourseContentCreateManyCourseInput | CourseContentCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseTagCreateWithoutCourseInput = {
    Tag: DictCourseTagCreateNestedOneWithoutCourseTagInput
  }

  export type CourseTagUncheckedCreateWithoutCourseInput = {
    tagId: number
  }

  export type CourseTagCreateOrConnectWithoutCourseInput = {
    where: CourseTagWhereUniqueInput
    create: XOR<CourseTagCreateWithoutCourseInput, CourseTagUncheckedCreateWithoutCourseInput>
  }

  export type CourseTagCreateManyCourseInputEnvelope = {
    data: CourseTagCreateManyCourseInput | CourseTagCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseCommentCreateWithoutCourseInput = {
    Comment: CommentCreateNestedOneWithoutCourseCommentInput
  }

  export type CourseCommentUncheckedCreateWithoutCourseInput = {
    commentId: number
  }

  export type CourseCommentCreateOrConnectWithoutCourseInput = {
    where: CourseCommentWhereUniqueInput
    create: XOR<CourseCommentCreateWithoutCourseInput, CourseCommentUncheckedCreateWithoutCourseInput>
  }

  export type CourseCommentCreateManyCourseInputEnvelope = {
    data: CourseCommentCreateManyCourseInput | CourseCommentCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutCourseInput = {
    amount: number
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    User: UserCreateNestedOneWithoutTransactionInput
    Platform: DictPlatformCreateNestedOneWithoutTransactionInput
    GroupTransaction?: GroupTransactionCreateNestedManyWithoutTransactionInput
    BalanceRecord?: BalanceRecordCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutCourseInput = {
    id?: number
    userId: number
    amount: number
    platformId: number
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    GroupTransaction?: GroupTransactionUncheckedCreateNestedManyWithoutTransactionInput
    BalanceRecord?: BalanceRecordUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutCourseInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCourseInput, TransactionUncheckedCreateWithoutCourseInput>
  }

  export type TransactionCreateManyCourseInputEnvelope = {
    data: TransactionCreateManyCourseInput | TransactionCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type AttachmentUpsertWithoutCourseInput = {
    update: XOR<AttachmentUpdateWithoutCourseInput, AttachmentUncheckedUpdateWithoutCourseInput>
    create: XOR<AttachmentCreateWithoutCourseInput, AttachmentUncheckedCreateWithoutCourseInput>
    where?: AttachmentWhereInput
  }

  export type AttachmentUpdateToOneWithWhereWithoutCourseInput = {
    where?: AttachmentWhereInput
    data: XOR<AttachmentUpdateWithoutCourseInput, AttachmentUncheckedUpdateWithoutCourseInput>
  }

  export type AttachmentUpdateWithoutCourseInput = {
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    ossType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneRequiredWithoutAttachmentNestedInput
    AttachmentAttribute?: AttachmentAttributeUpdateManyWithoutAttachmentNestedInput
    ContentAttachment?: ContentAttachmentUpdateManyWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    ossType?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttachmentAttribute?: AttachmentAttributeUncheckedUpdateManyWithoutAttachmentNestedInput
    ContentAttachment?: ContentAttachmentUncheckedUpdateManyWithoutAttachmentNestedInput
  }

  export type UserUpsertWithoutCourseInput = {
    update: XOR<UserUpdateWithoutCourseInput, UserUncheckedUpdateWithoutCourseInput>
    create: XOR<UserCreateWithoutCourseInput, UserUncheckedCreateWithoutCourseInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCourseInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCourseInput, UserUncheckedUpdateWithoutCourseInput>
  }

  export type UserUpdateWithoutCourseInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserRole?: UserRoleUpdateManyWithoutUserNestedInput
    Attachment?: AttachmentUpdateManyWithoutUserNestedInput
    CourseContent?: CourseContentUpdateManyWithoutAuthorNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    AuditRecord?: AuditRecordUpdateManyWithoutReviewerNestedInput
    BalanceRecord?: BalanceRecordUpdateManyWithoutUserNestedInput
    Note?: NoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    Attachment?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    CourseContent?: CourseContentUncheckedUpdateManyWithoutAuthorNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    AuditRecord?: AuditRecordUncheckedUpdateManyWithoutReviewerNestedInput
    BalanceRecord?: BalanceRecordUncheckedUpdateManyWithoutUserNestedInput
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseContentUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseContentWhereUniqueInput
    update: XOR<CourseContentUpdateWithoutCourseInput, CourseContentUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseContentCreateWithoutCourseInput, CourseContentUncheckedCreateWithoutCourseInput>
  }

  export type CourseContentUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseContentWhereUniqueInput
    data: XOR<CourseContentUpdateWithoutCourseInput, CourseContentUncheckedUpdateWithoutCourseInput>
  }

  export type CourseContentUpdateManyWithWhereWithoutCourseInput = {
    where: CourseContentScalarWhereInput
    data: XOR<CourseContentUpdateManyMutationInput, CourseContentUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseTagUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseTagWhereUniqueInput
    update: XOR<CourseTagUpdateWithoutCourseInput, CourseTagUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseTagCreateWithoutCourseInput, CourseTagUncheckedCreateWithoutCourseInput>
  }

  export type CourseTagUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseTagWhereUniqueInput
    data: XOR<CourseTagUpdateWithoutCourseInput, CourseTagUncheckedUpdateWithoutCourseInput>
  }

  export type CourseTagUpdateManyWithWhereWithoutCourseInput = {
    where: CourseTagScalarWhereInput
    data: XOR<CourseTagUpdateManyMutationInput, CourseTagUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseTagScalarWhereInput = {
    AND?: CourseTagScalarWhereInput | CourseTagScalarWhereInput[]
    OR?: CourseTagScalarWhereInput[]
    NOT?: CourseTagScalarWhereInput | CourseTagScalarWhereInput[]
    courseId?: IntFilter<"CourseTag"> | number
    tagId?: IntFilter<"CourseTag"> | number
  }

  export type CourseCommentUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseCommentWhereUniqueInput
    update: XOR<CourseCommentUpdateWithoutCourseInput, CourseCommentUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseCommentCreateWithoutCourseInput, CourseCommentUncheckedCreateWithoutCourseInput>
  }

  export type CourseCommentUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseCommentWhereUniqueInput
    data: XOR<CourseCommentUpdateWithoutCourseInput, CourseCommentUncheckedUpdateWithoutCourseInput>
  }

  export type CourseCommentUpdateManyWithWhereWithoutCourseInput = {
    where: CourseCommentScalarWhereInput
    data: XOR<CourseCommentUpdateManyMutationInput, CourseCommentUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseCommentScalarWhereInput = {
    AND?: CourseCommentScalarWhereInput | CourseCommentScalarWhereInput[]
    OR?: CourseCommentScalarWhereInput[]
    NOT?: CourseCommentScalarWhereInput | CourseCommentScalarWhereInput[]
    courseId?: IntFilter<"CourseComment"> | number
    commentId?: IntFilter<"CourseComment"> | number
  }

  export type TransactionUpsertWithWhereUniqueWithoutCourseInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCourseInput, TransactionUncheckedUpdateWithoutCourseInput>
    create: XOR<TransactionCreateWithoutCourseInput, TransactionUncheckedCreateWithoutCourseInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCourseInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCourseInput, TransactionUncheckedUpdateWithoutCourseInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCourseInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseCreateWithoutContentsInput = {
    title: string
    subTitle?: string | null
    desc?: string | null
    originPrice?: number | null
    price?: number | null
    status?: number
    counts?: number
    order?: number
    detail?: string | null
    type?: string | null
    Cover?: AttachmentCreateNestedOneWithoutCourseInput
    Author: UserCreateNestedOneWithoutCourseInput
    Tags?: CourseTagCreateNestedManyWithoutCourseInput
    CourseComment?: CourseCommentCreateNestedManyWithoutCourseInput
    Transaction?: TransactionCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutContentsInput = {
    id?: number
    title: string
    subTitle?: string | null
    desc?: string | null
    coverId?: number | null
    authorId: number
    originPrice?: number | null
    price?: number | null
    status?: number
    counts?: number
    order?: number
    detail?: string | null
    type?: string | null
    Tags?: CourseTagUncheckedCreateNestedManyWithoutCourseInput
    CourseComment?: CourseCommentUncheckedCreateNestedManyWithoutCourseInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutContentsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutContentsInput, CourseUncheckedCreateWithoutContentsInput>
  }

  export type UserCreateWithoutCourseContentInput = {
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    Attachment?: AttachmentCreateNestedManyWithoutUserInput
    Course?: CourseCreateNestedManyWithoutAuthorInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    AuditRecord?: AuditRecordCreateNestedManyWithoutReviewerInput
    BalanceRecord?: BalanceRecordCreateNestedManyWithoutUserInput
    Note?: NoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCourseContentInput = {
    id?: number
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    Attachment?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    Course?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    AuditRecord?: AuditRecordUncheckedCreateNestedManyWithoutReviewerInput
    BalanceRecord?: BalanceRecordUncheckedCreateNestedManyWithoutUserInput
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCourseContentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCourseContentInput, UserUncheckedCreateWithoutCourseContentInput>
  }

  export type ContentAttachmentCreateWithoutContentInput = {
    Attachment: AttachmentCreateNestedOneWithoutContentAttachmentInput
  }

  export type ContentAttachmentUncheckedCreateWithoutContentInput = {
    attachmentId: number
  }

  export type ContentAttachmentCreateOrConnectWithoutContentInput = {
    where: ContentAttachmentWhereUniqueInput
    create: XOR<ContentAttachmentCreateWithoutContentInput, ContentAttachmentUncheckedCreateWithoutContentInput>
  }

  export type ContentAttachmentCreateManyContentInputEnvelope = {
    data: ContentAttachmentCreateManyContentInput | ContentAttachmentCreateManyContentInput[]
    skipDuplicates?: boolean
  }

  export type ContentTagCreateWithoutContentInput = {
    Tag: DictCourseTagCreateNestedOneWithoutContentTagInput
  }

  export type ContentTagUncheckedCreateWithoutContentInput = {
    tagId: number
  }

  export type ContentTagCreateOrConnectWithoutContentInput = {
    where: ContentTagWhereUniqueInput
    create: XOR<ContentTagCreateWithoutContentInput, ContentTagUncheckedCreateWithoutContentInput>
  }

  export type ContentTagCreateManyContentInputEnvelope = {
    data: ContentTagCreateManyContentInput | ContentTagCreateManyContentInput[]
    skipDuplicates?: boolean
  }

  export type ContentCommentCreateWithoutContentInput = {
    Comment: CommentCreateNestedOneWithoutContentCommentInput
  }

  export type ContentCommentUncheckedCreateWithoutContentInput = {
    commentId: number
  }

  export type ContentCommentCreateOrConnectWithoutContentInput = {
    where: ContentCommentWhereUniqueInput
    create: XOR<ContentCommentCreateWithoutContentInput, ContentCommentUncheckedCreateWithoutContentInput>
  }

  export type ContentCommentCreateManyContentInputEnvelope = {
    data: ContentCommentCreateManyContentInput | ContentCommentCreateManyContentInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutContentsInput = {
    update: XOR<CourseUpdateWithoutContentsInput, CourseUncheckedUpdateWithoutContentsInput>
    create: XOR<CourseCreateWithoutContentsInput, CourseUncheckedCreateWithoutContentsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutContentsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutContentsInput, CourseUncheckedUpdateWithoutContentsInput>
  }

  export type CourseUpdateWithoutContentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    originPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    counts?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Cover?: AttachmentUpdateOneWithoutCourseNestedInput
    Author?: UserUpdateOneRequiredWithoutCourseNestedInput
    Tags?: CourseTagUpdateManyWithoutCourseNestedInput
    CourseComment?: CourseCommentUpdateManyWithoutCourseNestedInput
    Transaction?: TransactionUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutContentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    coverId?: NullableIntFieldUpdateOperationsInput | number | null
    authorId?: IntFieldUpdateOperationsInput | number
    originPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    counts?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Tags?: CourseTagUncheckedUpdateManyWithoutCourseNestedInput
    CourseComment?: CourseCommentUncheckedUpdateManyWithoutCourseNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserUpsertWithoutCourseContentInput = {
    update: XOR<UserUpdateWithoutCourseContentInput, UserUncheckedUpdateWithoutCourseContentInput>
    create: XOR<UserCreateWithoutCourseContentInput, UserUncheckedCreateWithoutCourseContentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCourseContentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCourseContentInput, UserUncheckedUpdateWithoutCourseContentInput>
  }

  export type UserUpdateWithoutCourseContentInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserRole?: UserRoleUpdateManyWithoutUserNestedInput
    Attachment?: AttachmentUpdateManyWithoutUserNestedInput
    Course?: CourseUpdateManyWithoutAuthorNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    AuditRecord?: AuditRecordUpdateManyWithoutReviewerNestedInput
    BalanceRecord?: BalanceRecordUpdateManyWithoutUserNestedInput
    Note?: NoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCourseContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    Attachment?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    Course?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    AuditRecord?: AuditRecordUncheckedUpdateManyWithoutReviewerNestedInput
    BalanceRecord?: BalanceRecordUncheckedUpdateManyWithoutUserNestedInput
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ContentAttachmentUpsertWithWhereUniqueWithoutContentInput = {
    where: ContentAttachmentWhereUniqueInput
    update: XOR<ContentAttachmentUpdateWithoutContentInput, ContentAttachmentUncheckedUpdateWithoutContentInput>
    create: XOR<ContentAttachmentCreateWithoutContentInput, ContentAttachmentUncheckedCreateWithoutContentInput>
  }

  export type ContentAttachmentUpdateWithWhereUniqueWithoutContentInput = {
    where: ContentAttachmentWhereUniqueInput
    data: XOR<ContentAttachmentUpdateWithoutContentInput, ContentAttachmentUncheckedUpdateWithoutContentInput>
  }

  export type ContentAttachmentUpdateManyWithWhereWithoutContentInput = {
    where: ContentAttachmentScalarWhereInput
    data: XOR<ContentAttachmentUpdateManyMutationInput, ContentAttachmentUncheckedUpdateManyWithoutContentInput>
  }

  export type ContentTagUpsertWithWhereUniqueWithoutContentInput = {
    where: ContentTagWhereUniqueInput
    update: XOR<ContentTagUpdateWithoutContentInput, ContentTagUncheckedUpdateWithoutContentInput>
    create: XOR<ContentTagCreateWithoutContentInput, ContentTagUncheckedCreateWithoutContentInput>
  }

  export type ContentTagUpdateWithWhereUniqueWithoutContentInput = {
    where: ContentTagWhereUniqueInput
    data: XOR<ContentTagUpdateWithoutContentInput, ContentTagUncheckedUpdateWithoutContentInput>
  }

  export type ContentTagUpdateManyWithWhereWithoutContentInput = {
    where: ContentTagScalarWhereInput
    data: XOR<ContentTagUpdateManyMutationInput, ContentTagUncheckedUpdateManyWithoutContentInput>
  }

  export type ContentTagScalarWhereInput = {
    AND?: ContentTagScalarWhereInput | ContentTagScalarWhereInput[]
    OR?: ContentTagScalarWhereInput[]
    NOT?: ContentTagScalarWhereInput | ContentTagScalarWhereInput[]
    contentId?: IntFilter<"ContentTag"> | number
    tagId?: IntFilter<"ContentTag"> | number
  }

  export type ContentCommentUpsertWithWhereUniqueWithoutContentInput = {
    where: ContentCommentWhereUniqueInput
    update: XOR<ContentCommentUpdateWithoutContentInput, ContentCommentUncheckedUpdateWithoutContentInput>
    create: XOR<ContentCommentCreateWithoutContentInput, ContentCommentUncheckedCreateWithoutContentInput>
  }

  export type ContentCommentUpdateWithWhereUniqueWithoutContentInput = {
    where: ContentCommentWhereUniqueInput
    data: XOR<ContentCommentUpdateWithoutContentInput, ContentCommentUncheckedUpdateWithoutContentInput>
  }

  export type ContentCommentUpdateManyWithWhereWithoutContentInput = {
    where: ContentCommentScalarWhereInput
    data: XOR<ContentCommentUpdateManyMutationInput, ContentCommentUncheckedUpdateManyWithoutContentInput>
  }

  export type ContentCommentScalarWhereInput = {
    AND?: ContentCommentScalarWhereInput | ContentCommentScalarWhereInput[]
    OR?: ContentCommentScalarWhereInput[]
    NOT?: ContentCommentScalarWhereInput | ContentCommentScalarWhereInput[]
    contentId?: IntFilter<"ContentComment"> | number
    commentId?: IntFilter<"ContentComment"> | number
  }

  export type CourseContentCreateWithoutAttachmentsInput = {
    title: string
    type?: string | null
    order?: number
    pid?: number | null
    status?: number
    Course: CourseCreateNestedOneWithoutContentsInput
    Author: UserCreateNestedOneWithoutCourseContentInput
    Tags?: ContentTagCreateNestedManyWithoutContentInput
    ContentComment?: ContentCommentCreateNestedManyWithoutContentInput
  }

  export type CourseContentUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    courseId: number
    title: string
    type?: string | null
    order?: number
    pid?: number | null
    status?: number
    authorId: number
    Tags?: ContentTagUncheckedCreateNestedManyWithoutContentInput
    ContentComment?: ContentCommentUncheckedCreateNestedManyWithoutContentInput
  }

  export type CourseContentCreateOrConnectWithoutAttachmentsInput = {
    where: CourseContentWhereUniqueInput
    create: XOR<CourseContentCreateWithoutAttachmentsInput, CourseContentUncheckedCreateWithoutAttachmentsInput>
  }

  export type AttachmentCreateWithoutContentAttachmentInput = {
    type: string
    location: string
    name?: string | null
    ossType?: string | null
    status?: number
    desc?: string | null
    createdAt?: Date | string | null
    User: UserCreateNestedOneWithoutAttachmentInput
    AttachmentAttribute?: AttachmentAttributeCreateNestedManyWithoutAttachmentInput
    Course?: CourseCreateNestedManyWithoutCoverInput
  }

  export type AttachmentUncheckedCreateWithoutContentAttachmentInput = {
    id?: number
    type: string
    location: string
    name?: string | null
    ossType?: string | null
    userId: number
    status?: number
    desc?: string | null
    createdAt?: Date | string | null
    AttachmentAttribute?: AttachmentAttributeUncheckedCreateNestedManyWithoutAttachmentInput
    Course?: CourseUncheckedCreateNestedManyWithoutCoverInput
  }

  export type AttachmentCreateOrConnectWithoutContentAttachmentInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutContentAttachmentInput, AttachmentUncheckedCreateWithoutContentAttachmentInput>
  }

  export type CourseContentUpsertWithoutAttachmentsInput = {
    update: XOR<CourseContentUpdateWithoutAttachmentsInput, CourseContentUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<CourseContentCreateWithoutAttachmentsInput, CourseContentUncheckedCreateWithoutAttachmentsInput>
    where?: CourseContentWhereInput
  }

  export type CourseContentUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: CourseContentWhereInput
    data: XOR<CourseContentUpdateWithoutAttachmentsInput, CourseContentUncheckedUpdateWithoutAttachmentsInput>
  }

  export type CourseContentUpdateWithoutAttachmentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    Course?: CourseUpdateOneRequiredWithoutContentsNestedInput
    Author?: UserUpdateOneRequiredWithoutCourseContentNestedInput
    Tags?: ContentTagUpdateManyWithoutContentNestedInput
    ContentComment?: ContentCommentUpdateManyWithoutContentNestedInput
  }

  export type CourseContentUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    Tags?: ContentTagUncheckedUpdateManyWithoutContentNestedInput
    ContentComment?: ContentCommentUncheckedUpdateManyWithoutContentNestedInput
  }

  export type AttachmentUpsertWithoutContentAttachmentInput = {
    update: XOR<AttachmentUpdateWithoutContentAttachmentInput, AttachmentUncheckedUpdateWithoutContentAttachmentInput>
    create: XOR<AttachmentCreateWithoutContentAttachmentInput, AttachmentUncheckedCreateWithoutContentAttachmentInput>
    where?: AttachmentWhereInput
  }

  export type AttachmentUpdateToOneWithWhereWithoutContentAttachmentInput = {
    where?: AttachmentWhereInput
    data: XOR<AttachmentUpdateWithoutContentAttachmentInput, AttachmentUncheckedUpdateWithoutContentAttachmentInput>
  }

  export type AttachmentUpdateWithoutContentAttachmentInput = {
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    ossType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneRequiredWithoutAttachmentNestedInput
    AttachmentAttribute?: AttachmentAttributeUpdateManyWithoutAttachmentNestedInput
    Course?: CourseUpdateManyWithoutCoverNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutContentAttachmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    ossType?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttachmentAttribute?: AttachmentAttributeUncheckedUpdateManyWithoutAttachmentNestedInput
    Course?: CourseUncheckedUpdateManyWithoutCoverNestedInput
  }

  export type DictCourseTypeCreateWithoutCourseTagsInput = {
    name: string
    order?: number
    status?: number
  }

  export type DictCourseTypeUncheckedCreateWithoutCourseTagsInput = {
    id?: number
    name: string
    order?: number
    status?: number
  }

  export type DictCourseTypeCreateOrConnectWithoutCourseTagsInput = {
    where: DictCourseTypeWhereUniqueInput
    create: XOR<DictCourseTypeCreateWithoutCourseTagsInput, DictCourseTypeUncheckedCreateWithoutCourseTagsInput>
  }

  export type CourseTagCreateWithoutTagInput = {
    Course: CourseCreateNestedOneWithoutTagsInput
  }

  export type CourseTagUncheckedCreateWithoutTagInput = {
    courseId: number
  }

  export type CourseTagCreateOrConnectWithoutTagInput = {
    where: CourseTagWhereUniqueInput
    create: XOR<CourseTagCreateWithoutTagInput, CourseTagUncheckedCreateWithoutTagInput>
  }

  export type CourseTagCreateManyTagInputEnvelope = {
    data: CourseTagCreateManyTagInput | CourseTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type ContentTagCreateWithoutTagInput = {
    Content: CourseContentCreateNestedOneWithoutTagsInput
  }

  export type ContentTagUncheckedCreateWithoutTagInput = {
    contentId: number
  }

  export type ContentTagCreateOrConnectWithoutTagInput = {
    where: ContentTagWhereUniqueInput
    create: XOR<ContentTagCreateWithoutTagInput, ContentTagUncheckedCreateWithoutTagInput>
  }

  export type ContentTagCreateManyTagInputEnvelope = {
    data: ContentTagCreateManyTagInput | ContentTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type DictCourseTypeUpsertWithoutCourseTagsInput = {
    update: XOR<DictCourseTypeUpdateWithoutCourseTagsInput, DictCourseTypeUncheckedUpdateWithoutCourseTagsInput>
    create: XOR<DictCourseTypeCreateWithoutCourseTagsInput, DictCourseTypeUncheckedCreateWithoutCourseTagsInput>
    where?: DictCourseTypeWhereInput
  }

  export type DictCourseTypeUpdateToOneWithWhereWithoutCourseTagsInput = {
    where?: DictCourseTypeWhereInput
    data: XOR<DictCourseTypeUpdateWithoutCourseTagsInput, DictCourseTypeUncheckedUpdateWithoutCourseTagsInput>
  }

  export type DictCourseTypeUpdateWithoutCourseTagsInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
  }

  export type DictCourseTypeUncheckedUpdateWithoutCourseTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
  }

  export type CourseTagUpsertWithWhereUniqueWithoutTagInput = {
    where: CourseTagWhereUniqueInput
    update: XOR<CourseTagUpdateWithoutTagInput, CourseTagUncheckedUpdateWithoutTagInput>
    create: XOR<CourseTagCreateWithoutTagInput, CourseTagUncheckedCreateWithoutTagInput>
  }

  export type CourseTagUpdateWithWhereUniqueWithoutTagInput = {
    where: CourseTagWhereUniqueInput
    data: XOR<CourseTagUpdateWithoutTagInput, CourseTagUncheckedUpdateWithoutTagInput>
  }

  export type CourseTagUpdateManyWithWhereWithoutTagInput = {
    where: CourseTagScalarWhereInput
    data: XOR<CourseTagUpdateManyMutationInput, CourseTagUncheckedUpdateManyWithoutTagInput>
  }

  export type ContentTagUpsertWithWhereUniqueWithoutTagInput = {
    where: ContentTagWhereUniqueInput
    update: XOR<ContentTagUpdateWithoutTagInput, ContentTagUncheckedUpdateWithoutTagInput>
    create: XOR<ContentTagCreateWithoutTagInput, ContentTagUncheckedCreateWithoutTagInput>
  }

  export type ContentTagUpdateWithWhereUniqueWithoutTagInput = {
    where: ContentTagWhereUniqueInput
    data: XOR<ContentTagUpdateWithoutTagInput, ContentTagUncheckedUpdateWithoutTagInput>
  }

  export type ContentTagUpdateManyWithWhereWithoutTagInput = {
    where: ContentTagScalarWhereInput
    data: XOR<ContentTagUpdateManyMutationInput, ContentTagUncheckedUpdateManyWithoutTagInput>
  }

  export type DictCourseTagCreateWithoutCourseTypeInput = {
    name: string
    order?: number
    status?: number
    CourseTag?: CourseTagCreateNestedManyWithoutTagInput
    ContentTag?: ContentTagCreateNestedManyWithoutTagInput
  }

  export type DictCourseTagUncheckedCreateWithoutCourseTypeInput = {
    id?: number
    name: string
    order?: number
    status?: number
    CourseTag?: CourseTagUncheckedCreateNestedManyWithoutTagInput
    ContentTag?: ContentTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type DictCourseTagCreateOrConnectWithoutCourseTypeInput = {
    where: DictCourseTagWhereUniqueInput
    create: XOR<DictCourseTagCreateWithoutCourseTypeInput, DictCourseTagUncheckedCreateWithoutCourseTypeInput>
  }

  export type DictCourseTagCreateManyCourseTypeInputEnvelope = {
    data: DictCourseTagCreateManyCourseTypeInput | DictCourseTagCreateManyCourseTypeInput[]
    skipDuplicates?: boolean
  }

  export type DictCourseTagUpsertWithWhereUniqueWithoutCourseTypeInput = {
    where: DictCourseTagWhereUniqueInput
    update: XOR<DictCourseTagUpdateWithoutCourseTypeInput, DictCourseTagUncheckedUpdateWithoutCourseTypeInput>
    create: XOR<DictCourseTagCreateWithoutCourseTypeInput, DictCourseTagUncheckedCreateWithoutCourseTypeInput>
  }

  export type DictCourseTagUpdateWithWhereUniqueWithoutCourseTypeInput = {
    where: DictCourseTagWhereUniqueInput
    data: XOR<DictCourseTagUpdateWithoutCourseTypeInput, DictCourseTagUncheckedUpdateWithoutCourseTypeInput>
  }

  export type DictCourseTagUpdateManyWithWhereWithoutCourseTypeInput = {
    where: DictCourseTagScalarWhereInput
    data: XOR<DictCourseTagUpdateManyMutationInput, DictCourseTagUncheckedUpdateManyWithoutCourseTypeInput>
  }

  export type DictCourseTagScalarWhereInput = {
    AND?: DictCourseTagScalarWhereInput | DictCourseTagScalarWhereInput[]
    OR?: DictCourseTagScalarWhereInput[]
    NOT?: DictCourseTagScalarWhereInput | DictCourseTagScalarWhereInput[]
    id?: IntFilter<"DictCourseTag"> | number
    name?: StringFilter<"DictCourseTag"> | string
    typeId?: IntNullableFilter<"DictCourseTag"> | number | null
    order?: IntFilter<"DictCourseTag"> | number
    status?: IntFilter<"DictCourseTag"> | number
  }

  export type CourseCreateWithoutTagsInput = {
    title: string
    subTitle?: string | null
    desc?: string | null
    originPrice?: number | null
    price?: number | null
    status?: number
    counts?: number
    order?: number
    detail?: string | null
    type?: string | null
    Cover?: AttachmentCreateNestedOneWithoutCourseInput
    Author: UserCreateNestedOneWithoutCourseInput
    Contents?: CourseContentCreateNestedManyWithoutCourseInput
    CourseComment?: CourseCommentCreateNestedManyWithoutCourseInput
    Transaction?: TransactionCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutTagsInput = {
    id?: number
    title: string
    subTitle?: string | null
    desc?: string | null
    coverId?: number | null
    authorId: number
    originPrice?: number | null
    price?: number | null
    status?: number
    counts?: number
    order?: number
    detail?: string | null
    type?: string | null
    Contents?: CourseContentUncheckedCreateNestedManyWithoutCourseInput
    CourseComment?: CourseCommentUncheckedCreateNestedManyWithoutCourseInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutTagsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutTagsInput, CourseUncheckedCreateWithoutTagsInput>
  }

  export type DictCourseTagCreateWithoutCourseTagInput = {
    name: string
    order?: number
    status?: number
    CourseType?: DictCourseTypeCreateNestedOneWithoutCourseTagsInput
    ContentTag?: ContentTagCreateNestedManyWithoutTagInput
  }

  export type DictCourseTagUncheckedCreateWithoutCourseTagInput = {
    id?: number
    name: string
    typeId?: number | null
    order?: number
    status?: number
    ContentTag?: ContentTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type DictCourseTagCreateOrConnectWithoutCourseTagInput = {
    where: DictCourseTagWhereUniqueInput
    create: XOR<DictCourseTagCreateWithoutCourseTagInput, DictCourseTagUncheckedCreateWithoutCourseTagInput>
  }

  export type CourseUpsertWithoutTagsInput = {
    update: XOR<CourseUpdateWithoutTagsInput, CourseUncheckedUpdateWithoutTagsInput>
    create: XOR<CourseCreateWithoutTagsInput, CourseUncheckedCreateWithoutTagsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutTagsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutTagsInput, CourseUncheckedUpdateWithoutTagsInput>
  }

  export type CourseUpdateWithoutTagsInput = {
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    originPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    counts?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Cover?: AttachmentUpdateOneWithoutCourseNestedInput
    Author?: UserUpdateOneRequiredWithoutCourseNestedInput
    Contents?: CourseContentUpdateManyWithoutCourseNestedInput
    CourseComment?: CourseCommentUpdateManyWithoutCourseNestedInput
    Transaction?: TransactionUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    coverId?: NullableIntFieldUpdateOperationsInput | number | null
    authorId?: IntFieldUpdateOperationsInput | number
    originPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    counts?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Contents?: CourseContentUncheckedUpdateManyWithoutCourseNestedInput
    CourseComment?: CourseCommentUncheckedUpdateManyWithoutCourseNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type DictCourseTagUpsertWithoutCourseTagInput = {
    update: XOR<DictCourseTagUpdateWithoutCourseTagInput, DictCourseTagUncheckedUpdateWithoutCourseTagInput>
    create: XOR<DictCourseTagCreateWithoutCourseTagInput, DictCourseTagUncheckedCreateWithoutCourseTagInput>
    where?: DictCourseTagWhereInput
  }

  export type DictCourseTagUpdateToOneWithWhereWithoutCourseTagInput = {
    where?: DictCourseTagWhereInput
    data: XOR<DictCourseTagUpdateWithoutCourseTagInput, DictCourseTagUncheckedUpdateWithoutCourseTagInput>
  }

  export type DictCourseTagUpdateWithoutCourseTagInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    CourseType?: DictCourseTypeUpdateOneWithoutCourseTagsNestedInput
    ContentTag?: ContentTagUpdateManyWithoutTagNestedInput
  }

  export type DictCourseTagUncheckedUpdateWithoutCourseTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    ContentTag?: ContentTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type CourseContentCreateWithoutTagsInput = {
    title: string
    type?: string | null
    order?: number
    pid?: number | null
    status?: number
    Course: CourseCreateNestedOneWithoutContentsInput
    Author: UserCreateNestedOneWithoutCourseContentInput
    Attachments?: ContentAttachmentCreateNestedManyWithoutContentInput
    ContentComment?: ContentCommentCreateNestedManyWithoutContentInput
  }

  export type CourseContentUncheckedCreateWithoutTagsInput = {
    id?: number
    courseId: number
    title: string
    type?: string | null
    order?: number
    pid?: number | null
    status?: number
    authorId: number
    Attachments?: ContentAttachmentUncheckedCreateNestedManyWithoutContentInput
    ContentComment?: ContentCommentUncheckedCreateNestedManyWithoutContentInput
  }

  export type CourseContentCreateOrConnectWithoutTagsInput = {
    where: CourseContentWhereUniqueInput
    create: XOR<CourseContentCreateWithoutTagsInput, CourseContentUncheckedCreateWithoutTagsInput>
  }

  export type DictCourseTagCreateWithoutContentTagInput = {
    name: string
    order?: number
    status?: number
    CourseType?: DictCourseTypeCreateNestedOneWithoutCourseTagsInput
    CourseTag?: CourseTagCreateNestedManyWithoutTagInput
  }

  export type DictCourseTagUncheckedCreateWithoutContentTagInput = {
    id?: number
    name: string
    typeId?: number | null
    order?: number
    status?: number
    CourseTag?: CourseTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type DictCourseTagCreateOrConnectWithoutContentTagInput = {
    where: DictCourseTagWhereUniqueInput
    create: XOR<DictCourseTagCreateWithoutContentTagInput, DictCourseTagUncheckedCreateWithoutContentTagInput>
  }

  export type CourseContentUpsertWithoutTagsInput = {
    update: XOR<CourseContentUpdateWithoutTagsInput, CourseContentUncheckedUpdateWithoutTagsInput>
    create: XOR<CourseContentCreateWithoutTagsInput, CourseContentUncheckedCreateWithoutTagsInput>
    where?: CourseContentWhereInput
  }

  export type CourseContentUpdateToOneWithWhereWithoutTagsInput = {
    where?: CourseContentWhereInput
    data: XOR<CourseContentUpdateWithoutTagsInput, CourseContentUncheckedUpdateWithoutTagsInput>
  }

  export type CourseContentUpdateWithoutTagsInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    Course?: CourseUpdateOneRequiredWithoutContentsNestedInput
    Author?: UserUpdateOneRequiredWithoutCourseContentNestedInput
    Attachments?: ContentAttachmentUpdateManyWithoutContentNestedInput
    ContentComment?: ContentCommentUpdateManyWithoutContentNestedInput
  }

  export type CourseContentUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    Attachments?: ContentAttachmentUncheckedUpdateManyWithoutContentNestedInput
    ContentComment?: ContentCommentUncheckedUpdateManyWithoutContentNestedInput
  }

  export type DictCourseTagUpsertWithoutContentTagInput = {
    update: XOR<DictCourseTagUpdateWithoutContentTagInput, DictCourseTagUncheckedUpdateWithoutContentTagInput>
    create: XOR<DictCourseTagCreateWithoutContentTagInput, DictCourseTagUncheckedCreateWithoutContentTagInput>
    where?: DictCourseTagWhereInput
  }

  export type DictCourseTagUpdateToOneWithWhereWithoutContentTagInput = {
    where?: DictCourseTagWhereInput
    data: XOR<DictCourseTagUpdateWithoutContentTagInput, DictCourseTagUncheckedUpdateWithoutContentTagInput>
  }

  export type DictCourseTagUpdateWithoutContentTagInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    CourseType?: DictCourseTypeUpdateOneWithoutCourseTagsNestedInput
    CourseTag?: CourseTagUpdateManyWithoutTagNestedInput
  }

  export type DictCourseTagUncheckedUpdateWithoutContentTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    typeId?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    CourseTag?: CourseTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type UserCreateWithoutCommentInput = {
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    Attachment?: AttachmentCreateNestedManyWithoutUserInput
    Course?: CourseCreateNestedManyWithoutAuthorInput
    CourseContent?: CourseContentCreateNestedManyWithoutAuthorInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    AuditRecord?: AuditRecordCreateNestedManyWithoutReviewerInput
    BalanceRecord?: BalanceRecordCreateNestedManyWithoutUserInput
    Note?: NoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentInput = {
    id?: number
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    Attachment?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    Course?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    CourseContent?: CourseContentUncheckedCreateNestedManyWithoutAuthorInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    AuditRecord?: AuditRecordUncheckedCreateNestedManyWithoutReviewerInput
    BalanceRecord?: BalanceRecordUncheckedCreateNestedManyWithoutUserInput
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
  }

  export type CommentCreateWithoutChildrenInput = {
    created?: Date | string
    hands?: bigint | number
    status?: number
    isBest?: number
    User: UserCreateNestedOneWithoutCommentInput
    parent?: CommentCreateNestedOneWithoutChildrenInput
    CourseComment?: CourseCommentCreateNestedManyWithoutCommentInput
    ContentComment?: ContentCommentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutChildrenInput = {
    id?: number
    pid?: number | null
    userId: number
    created?: Date | string
    hands?: bigint | number
    status?: number
    isBest?: number
    CourseComment?: CourseCommentUncheckedCreateNestedManyWithoutCommentInput
    ContentComment?: ContentCommentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutChildrenInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutChildrenInput, CommentUncheckedCreateWithoutChildrenInput>
  }

  export type CommentCreateWithoutParentInput = {
    created?: Date | string
    hands?: bigint | number
    status?: number
    isBest?: number
    User: UserCreateNestedOneWithoutCommentInput
    children?: CommentCreateNestedManyWithoutParentInput
    CourseComment?: CourseCommentCreateNestedManyWithoutCommentInput
    ContentComment?: ContentCommentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutParentInput = {
    id?: number
    userId: number
    created?: Date | string
    hands?: bigint | number
    status?: number
    isBest?: number
    children?: CommentUncheckedCreateNestedManyWithoutParentInput
    CourseComment?: CourseCommentUncheckedCreateNestedManyWithoutCommentInput
    ContentComment?: ContentCommentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutParentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentCreateManyParentInputEnvelope = {
    data: CommentCreateManyParentInput | CommentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type CourseCommentCreateWithoutCommentInput = {
    Course: CourseCreateNestedOneWithoutCourseCommentInput
  }

  export type CourseCommentUncheckedCreateWithoutCommentInput = {
    courseId: number
  }

  export type CourseCommentCreateOrConnectWithoutCommentInput = {
    where: CourseCommentWhereUniqueInput
    create: XOR<CourseCommentCreateWithoutCommentInput, CourseCommentUncheckedCreateWithoutCommentInput>
  }

  export type CourseCommentCreateManyCommentInputEnvelope = {
    data: CourseCommentCreateManyCommentInput | CourseCommentCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type ContentCommentCreateWithoutCommentInput = {
    Content: CourseContentCreateNestedOneWithoutContentCommentInput
  }

  export type ContentCommentUncheckedCreateWithoutCommentInput = {
    contentId: number
  }

  export type ContentCommentCreateOrConnectWithoutCommentInput = {
    where: ContentCommentWhereUniqueInput
    create: XOR<ContentCommentCreateWithoutCommentInput, ContentCommentUncheckedCreateWithoutCommentInput>
  }

  export type ContentCommentCreateManyCommentInputEnvelope = {
    data: ContentCommentCreateManyCommentInput | ContentCommentCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCommentInput = {
    update: XOR<UserUpdateWithoutCommentInput, UserUncheckedUpdateWithoutCommentInput>
    create: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentInput, UserUncheckedUpdateWithoutCommentInput>
  }

  export type UserUpdateWithoutCommentInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserRole?: UserRoleUpdateManyWithoutUserNestedInput
    Attachment?: AttachmentUpdateManyWithoutUserNestedInput
    Course?: CourseUpdateManyWithoutAuthorNestedInput
    CourseContent?: CourseContentUpdateManyWithoutAuthorNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    AuditRecord?: AuditRecordUpdateManyWithoutReviewerNestedInput
    BalanceRecord?: BalanceRecordUpdateManyWithoutUserNestedInput
    Note?: NoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    Attachment?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    Course?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    CourseContent?: CourseContentUncheckedUpdateManyWithoutAuthorNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    AuditRecord?: AuditRecordUncheckedUpdateManyWithoutReviewerNestedInput
    BalanceRecord?: BalanceRecordUncheckedUpdateManyWithoutUserNestedInput
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentUpsertWithoutChildrenInput = {
    update: XOR<CommentUpdateWithoutChildrenInput, CommentUncheckedUpdateWithoutChildrenInput>
    create: XOR<CommentCreateWithoutChildrenInput, CommentUncheckedCreateWithoutChildrenInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutChildrenInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutChildrenInput, CommentUncheckedUpdateWithoutChildrenInput>
  }

  export type CommentUpdateWithoutChildrenInput = {
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    hands?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: IntFieldUpdateOperationsInput | number
    isBest?: IntFieldUpdateOperationsInput | number
    User?: UserUpdateOneRequiredWithoutCommentNestedInput
    parent?: CommentUpdateOneWithoutChildrenNestedInput
    CourseComment?: CourseCommentUpdateManyWithoutCommentNestedInput
    ContentComment?: ContentCommentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutChildrenInput = {
    id?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    hands?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: IntFieldUpdateOperationsInput | number
    isBest?: IntFieldUpdateOperationsInput | number
    CourseComment?: CourseCommentUncheckedUpdateManyWithoutCommentNestedInput
    ContentComment?: ContentCommentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
  }

  export type CommentUpdateManyWithWhereWithoutParentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutParentInput>
  }

  export type CourseCommentUpsertWithWhereUniqueWithoutCommentInput = {
    where: CourseCommentWhereUniqueInput
    update: XOR<CourseCommentUpdateWithoutCommentInput, CourseCommentUncheckedUpdateWithoutCommentInput>
    create: XOR<CourseCommentCreateWithoutCommentInput, CourseCommentUncheckedCreateWithoutCommentInput>
  }

  export type CourseCommentUpdateWithWhereUniqueWithoutCommentInput = {
    where: CourseCommentWhereUniqueInput
    data: XOR<CourseCommentUpdateWithoutCommentInput, CourseCommentUncheckedUpdateWithoutCommentInput>
  }

  export type CourseCommentUpdateManyWithWhereWithoutCommentInput = {
    where: CourseCommentScalarWhereInput
    data: XOR<CourseCommentUpdateManyMutationInput, CourseCommentUncheckedUpdateManyWithoutCommentInput>
  }

  export type ContentCommentUpsertWithWhereUniqueWithoutCommentInput = {
    where: ContentCommentWhereUniqueInput
    update: XOR<ContentCommentUpdateWithoutCommentInput, ContentCommentUncheckedUpdateWithoutCommentInput>
    create: XOR<ContentCommentCreateWithoutCommentInput, ContentCommentUncheckedCreateWithoutCommentInput>
  }

  export type ContentCommentUpdateWithWhereUniqueWithoutCommentInput = {
    where: ContentCommentWhereUniqueInput
    data: XOR<ContentCommentUpdateWithoutCommentInput, ContentCommentUncheckedUpdateWithoutCommentInput>
  }

  export type ContentCommentUpdateManyWithWhereWithoutCommentInput = {
    where: ContentCommentScalarWhereInput
    data: XOR<ContentCommentUpdateManyMutationInput, ContentCommentUncheckedUpdateManyWithoutCommentInput>
  }

  export type CourseCreateWithoutCourseCommentInput = {
    title: string
    subTitle?: string | null
    desc?: string | null
    originPrice?: number | null
    price?: number | null
    status?: number
    counts?: number
    order?: number
    detail?: string | null
    type?: string | null
    Cover?: AttachmentCreateNestedOneWithoutCourseInput
    Author: UserCreateNestedOneWithoutCourseInput
    Contents?: CourseContentCreateNestedManyWithoutCourseInput
    Tags?: CourseTagCreateNestedManyWithoutCourseInput
    Transaction?: TransactionCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCourseCommentInput = {
    id?: number
    title: string
    subTitle?: string | null
    desc?: string | null
    coverId?: number | null
    authorId: number
    originPrice?: number | null
    price?: number | null
    status?: number
    counts?: number
    order?: number
    detail?: string | null
    type?: string | null
    Contents?: CourseContentUncheckedCreateNestedManyWithoutCourseInput
    Tags?: CourseTagUncheckedCreateNestedManyWithoutCourseInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCourseCommentInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCourseCommentInput, CourseUncheckedCreateWithoutCourseCommentInput>
  }

  export type CommentCreateWithoutCourseCommentInput = {
    created?: Date | string
    hands?: bigint | number
    status?: number
    isBest?: number
    User: UserCreateNestedOneWithoutCommentInput
    parent?: CommentCreateNestedOneWithoutChildrenInput
    children?: CommentCreateNestedManyWithoutParentInput
    ContentComment?: ContentCommentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutCourseCommentInput = {
    id?: number
    pid?: number | null
    userId: number
    created?: Date | string
    hands?: bigint | number
    status?: number
    isBest?: number
    children?: CommentUncheckedCreateNestedManyWithoutParentInput
    ContentComment?: ContentCommentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutCourseCommentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutCourseCommentInput, CommentUncheckedCreateWithoutCourseCommentInput>
  }

  export type CourseUpsertWithoutCourseCommentInput = {
    update: XOR<CourseUpdateWithoutCourseCommentInput, CourseUncheckedUpdateWithoutCourseCommentInput>
    create: XOR<CourseCreateWithoutCourseCommentInput, CourseUncheckedCreateWithoutCourseCommentInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutCourseCommentInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutCourseCommentInput, CourseUncheckedUpdateWithoutCourseCommentInput>
  }

  export type CourseUpdateWithoutCourseCommentInput = {
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    originPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    counts?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Cover?: AttachmentUpdateOneWithoutCourseNestedInput
    Author?: UserUpdateOneRequiredWithoutCourseNestedInput
    Contents?: CourseContentUpdateManyWithoutCourseNestedInput
    Tags?: CourseTagUpdateManyWithoutCourseNestedInput
    Transaction?: TransactionUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCourseCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    coverId?: NullableIntFieldUpdateOperationsInput | number | null
    authorId?: IntFieldUpdateOperationsInput | number
    originPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    counts?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Contents?: CourseContentUncheckedUpdateManyWithoutCourseNestedInput
    Tags?: CourseTagUncheckedUpdateManyWithoutCourseNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CommentUpsertWithoutCourseCommentInput = {
    update: XOR<CommentUpdateWithoutCourseCommentInput, CommentUncheckedUpdateWithoutCourseCommentInput>
    create: XOR<CommentCreateWithoutCourseCommentInput, CommentUncheckedCreateWithoutCourseCommentInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutCourseCommentInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutCourseCommentInput, CommentUncheckedUpdateWithoutCourseCommentInput>
  }

  export type CommentUpdateWithoutCourseCommentInput = {
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    hands?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: IntFieldUpdateOperationsInput | number
    isBest?: IntFieldUpdateOperationsInput | number
    User?: UserUpdateOneRequiredWithoutCommentNestedInput
    parent?: CommentUpdateOneWithoutChildrenNestedInput
    children?: CommentUpdateManyWithoutParentNestedInput
    ContentComment?: ContentCommentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutCourseCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    hands?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: IntFieldUpdateOperationsInput | number
    isBest?: IntFieldUpdateOperationsInput | number
    children?: CommentUncheckedUpdateManyWithoutParentNestedInput
    ContentComment?: ContentCommentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CourseContentCreateWithoutContentCommentInput = {
    title: string
    type?: string | null
    order?: number
    pid?: number | null
    status?: number
    Course: CourseCreateNestedOneWithoutContentsInput
    Author: UserCreateNestedOneWithoutCourseContentInput
    Attachments?: ContentAttachmentCreateNestedManyWithoutContentInput
    Tags?: ContentTagCreateNestedManyWithoutContentInput
  }

  export type CourseContentUncheckedCreateWithoutContentCommentInput = {
    id?: number
    courseId: number
    title: string
    type?: string | null
    order?: number
    pid?: number | null
    status?: number
    authorId: number
    Attachments?: ContentAttachmentUncheckedCreateNestedManyWithoutContentInput
    Tags?: ContentTagUncheckedCreateNestedManyWithoutContentInput
  }

  export type CourseContentCreateOrConnectWithoutContentCommentInput = {
    where: CourseContentWhereUniqueInput
    create: XOR<CourseContentCreateWithoutContentCommentInput, CourseContentUncheckedCreateWithoutContentCommentInput>
  }

  export type CommentCreateWithoutContentCommentInput = {
    created?: Date | string
    hands?: bigint | number
    status?: number
    isBest?: number
    User: UserCreateNestedOneWithoutCommentInput
    parent?: CommentCreateNestedOneWithoutChildrenInput
    children?: CommentCreateNestedManyWithoutParentInput
    CourseComment?: CourseCommentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutContentCommentInput = {
    id?: number
    pid?: number | null
    userId: number
    created?: Date | string
    hands?: bigint | number
    status?: number
    isBest?: number
    children?: CommentUncheckedCreateNestedManyWithoutParentInput
    CourseComment?: CourseCommentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutContentCommentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutContentCommentInput, CommentUncheckedCreateWithoutContentCommentInput>
  }

  export type CourseContentUpsertWithoutContentCommentInput = {
    update: XOR<CourseContentUpdateWithoutContentCommentInput, CourseContentUncheckedUpdateWithoutContentCommentInput>
    create: XOR<CourseContentCreateWithoutContentCommentInput, CourseContentUncheckedCreateWithoutContentCommentInput>
    where?: CourseContentWhereInput
  }

  export type CourseContentUpdateToOneWithWhereWithoutContentCommentInput = {
    where?: CourseContentWhereInput
    data: XOR<CourseContentUpdateWithoutContentCommentInput, CourseContentUncheckedUpdateWithoutContentCommentInput>
  }

  export type CourseContentUpdateWithoutContentCommentInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    Course?: CourseUpdateOneRequiredWithoutContentsNestedInput
    Author?: UserUpdateOneRequiredWithoutCourseContentNestedInput
    Attachments?: ContentAttachmentUpdateManyWithoutContentNestedInput
    Tags?: ContentTagUpdateManyWithoutContentNestedInput
  }

  export type CourseContentUncheckedUpdateWithoutContentCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    Attachments?: ContentAttachmentUncheckedUpdateManyWithoutContentNestedInput
    Tags?: ContentTagUncheckedUpdateManyWithoutContentNestedInput
  }

  export type CommentUpsertWithoutContentCommentInput = {
    update: XOR<CommentUpdateWithoutContentCommentInput, CommentUncheckedUpdateWithoutContentCommentInput>
    create: XOR<CommentCreateWithoutContentCommentInput, CommentUncheckedCreateWithoutContentCommentInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutContentCommentInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutContentCommentInput, CommentUncheckedUpdateWithoutContentCommentInput>
  }

  export type CommentUpdateWithoutContentCommentInput = {
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    hands?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: IntFieldUpdateOperationsInput | number
    isBest?: IntFieldUpdateOperationsInput | number
    User?: UserUpdateOneRequiredWithoutCommentNestedInput
    parent?: CommentUpdateOneWithoutChildrenNestedInput
    children?: CommentUpdateManyWithoutParentNestedInput
    CourseComment?: CourseCommentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutContentCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    hands?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: IntFieldUpdateOperationsInput | number
    isBest?: IntFieldUpdateOperationsInput | number
    children?: CommentUncheckedUpdateManyWithoutParentNestedInput
    CourseComment?: CourseCommentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type UserCreateWithoutNoteInput = {
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    Attachment?: AttachmentCreateNestedManyWithoutUserInput
    Course?: CourseCreateNestedManyWithoutAuthorInput
    CourseContent?: CourseContentCreateNestedManyWithoutAuthorInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    AuditRecord?: AuditRecordCreateNestedManyWithoutReviewerInput
    BalanceRecord?: BalanceRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNoteInput = {
    id?: number
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    Attachment?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    Course?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    CourseContent?: CourseContentUncheckedCreateNestedManyWithoutAuthorInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    AuditRecord?: AuditRecordUncheckedCreateNestedManyWithoutReviewerInput
    BalanceRecord?: BalanceRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNoteInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNoteInput, UserUncheckedCreateWithoutNoteInput>
  }

  export type UserUpsertWithoutNoteInput = {
    update: XOR<UserUpdateWithoutNoteInput, UserUncheckedUpdateWithoutNoteInput>
    create: XOR<UserCreateWithoutNoteInput, UserUncheckedCreateWithoutNoteInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNoteInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNoteInput, UserUncheckedUpdateWithoutNoteInput>
  }

  export type UserUpdateWithoutNoteInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserRole?: UserRoleUpdateManyWithoutUserNestedInput
    Attachment?: AttachmentUpdateManyWithoutUserNestedInput
    Course?: CourseUpdateManyWithoutAuthorNestedInput
    CourseContent?: CourseContentUpdateManyWithoutAuthorNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    AuditRecord?: AuditRecordUpdateManyWithoutReviewerNestedInput
    BalanceRecord?: BalanceRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    Attachment?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    Course?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    CourseContent?: CourseContentUncheckedUpdateManyWithoutAuthorNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    AuditRecord?: AuditRecordUncheckedUpdateManyWithoutReviewerNestedInput
    BalanceRecord?: BalanceRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TransactionCreateWithoutPlatformInput = {
    amount: number
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Course: CourseCreateNestedOneWithoutTransactionInput
    User: UserCreateNestedOneWithoutTransactionInput
    GroupTransaction?: GroupTransactionCreateNestedManyWithoutTransactionInput
    BalanceRecord?: BalanceRecordCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutPlatformInput = {
    id?: number
    courseId: number
    userId: number
    amount: number
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    GroupTransaction?: GroupTransactionUncheckedCreateNestedManyWithoutTransactionInput
    BalanceRecord?: BalanceRecordUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutPlatformInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutPlatformInput, TransactionUncheckedCreateWithoutPlatformInput>
  }

  export type TransactionCreateManyPlatformInputEnvelope = {
    data: TransactionCreateManyPlatformInput | TransactionCreateManyPlatformInput[]
    skipDuplicates?: boolean
  }

  export type TransactionUpsertWithWhereUniqueWithoutPlatformInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutPlatformInput, TransactionUncheckedUpdateWithoutPlatformInput>
    create: XOR<TransactionCreateWithoutPlatformInput, TransactionUncheckedCreateWithoutPlatformInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutPlatformInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutPlatformInput, TransactionUncheckedUpdateWithoutPlatformInput>
  }

  export type TransactionUpdateManyWithWhereWithoutPlatformInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutPlatformInput>
  }

  export type CourseCreateWithoutTransactionInput = {
    title: string
    subTitle?: string | null
    desc?: string | null
    originPrice?: number | null
    price?: number | null
    status?: number
    counts?: number
    order?: number
    detail?: string | null
    type?: string | null
    Cover?: AttachmentCreateNestedOneWithoutCourseInput
    Author: UserCreateNestedOneWithoutCourseInput
    Contents?: CourseContentCreateNestedManyWithoutCourseInput
    Tags?: CourseTagCreateNestedManyWithoutCourseInput
    CourseComment?: CourseCommentCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutTransactionInput = {
    id?: number
    title: string
    subTitle?: string | null
    desc?: string | null
    coverId?: number | null
    authorId: number
    originPrice?: number | null
    price?: number | null
    status?: number
    counts?: number
    order?: number
    detail?: string | null
    type?: string | null
    Contents?: CourseContentUncheckedCreateNestedManyWithoutCourseInput
    Tags?: CourseTagUncheckedCreateNestedManyWithoutCourseInput
    CourseComment?: CourseCommentUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutTransactionInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutTransactionInput, CourseUncheckedCreateWithoutTransactionInput>
  }

  export type UserCreateWithoutTransactionInput = {
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    Attachment?: AttachmentCreateNestedManyWithoutUserInput
    Course?: CourseCreateNestedManyWithoutAuthorInput
    CourseContent?: CourseContentCreateNestedManyWithoutAuthorInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    AuditRecord?: AuditRecordCreateNestedManyWithoutReviewerInput
    BalanceRecord?: BalanceRecordCreateNestedManyWithoutUserInput
    Note?: NoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionInput = {
    id?: number
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    Attachment?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    Course?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    CourseContent?: CourseContentUncheckedCreateNestedManyWithoutAuthorInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    AuditRecord?: AuditRecordUncheckedCreateNestedManyWithoutReviewerInput
    BalanceRecord?: BalanceRecordUncheckedCreateNestedManyWithoutUserInput
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
  }

  export type DictPlatformCreateWithoutTransactionInput = {
    name: string
    url?: string | null
  }

  export type DictPlatformUncheckedCreateWithoutTransactionInput = {
    id?: number
    name: string
    url?: string | null
  }

  export type DictPlatformCreateOrConnectWithoutTransactionInput = {
    where: DictPlatformWhereUniqueInput
    create: XOR<DictPlatformCreateWithoutTransactionInput, DictPlatformUncheckedCreateWithoutTransactionInput>
  }

  export type GroupTransactionCreateWithoutTransactionInput = {
    groupId: string
  }

  export type GroupTransactionUncheckedCreateWithoutTransactionInput = {
    id?: number
    groupId: string
  }

  export type GroupTransactionCreateOrConnectWithoutTransactionInput = {
    where: GroupTransactionWhereUniqueInput
    create: XOR<GroupTransactionCreateWithoutTransactionInput, GroupTransactionUncheckedCreateWithoutTransactionInput>
  }

  export type GroupTransactionCreateManyTransactionInputEnvelope = {
    data: GroupTransactionCreateManyTransactionInput | GroupTransactionCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type BalanceRecordCreateWithoutTransactionInput = {
    amount: number
    type?: number
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutBalanceRecordInput
  }

  export type BalanceRecordUncheckedCreateWithoutTransactionInput = {
    id?: number
    userId: number
    amount: number
    type?: number
    createdAt?: Date | string
  }

  export type BalanceRecordCreateOrConnectWithoutTransactionInput = {
    where: BalanceRecordWhereUniqueInput
    create: XOR<BalanceRecordCreateWithoutTransactionInput, BalanceRecordUncheckedCreateWithoutTransactionInput>
  }

  export type BalanceRecordCreateManyTransactionInputEnvelope = {
    data: BalanceRecordCreateManyTransactionInput | BalanceRecordCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutTransactionInput = {
    update: XOR<CourseUpdateWithoutTransactionInput, CourseUncheckedUpdateWithoutTransactionInput>
    create: XOR<CourseCreateWithoutTransactionInput, CourseUncheckedCreateWithoutTransactionInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutTransactionInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutTransactionInput, CourseUncheckedUpdateWithoutTransactionInput>
  }

  export type CourseUpdateWithoutTransactionInput = {
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    originPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    counts?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Cover?: AttachmentUpdateOneWithoutCourseNestedInput
    Author?: UserUpdateOneRequiredWithoutCourseNestedInput
    Contents?: CourseContentUpdateManyWithoutCourseNestedInput
    Tags?: CourseTagUpdateManyWithoutCourseNestedInput
    CourseComment?: CourseCommentUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    coverId?: NullableIntFieldUpdateOperationsInput | number | null
    authorId?: IntFieldUpdateOperationsInput | number
    originPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    counts?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Contents?: CourseContentUncheckedUpdateManyWithoutCourseNestedInput
    Tags?: CourseTagUncheckedUpdateManyWithoutCourseNestedInput
    CourseComment?: CourseCommentUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserUpsertWithoutTransactionInput = {
    update: XOR<UserUpdateWithoutTransactionInput, UserUncheckedUpdateWithoutTransactionInput>
    create: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionInput, UserUncheckedUpdateWithoutTransactionInput>
  }

  export type UserUpdateWithoutTransactionInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserRole?: UserRoleUpdateManyWithoutUserNestedInput
    Attachment?: AttachmentUpdateManyWithoutUserNestedInput
    Course?: CourseUpdateManyWithoutAuthorNestedInput
    CourseContent?: CourseContentUpdateManyWithoutAuthorNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    AuditRecord?: AuditRecordUpdateManyWithoutReviewerNestedInput
    BalanceRecord?: BalanceRecordUpdateManyWithoutUserNestedInput
    Note?: NoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    Attachment?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    Course?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    CourseContent?: CourseContentUncheckedUpdateManyWithoutAuthorNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    AuditRecord?: AuditRecordUncheckedUpdateManyWithoutReviewerNestedInput
    BalanceRecord?: BalanceRecordUncheckedUpdateManyWithoutUserNestedInput
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DictPlatformUpsertWithoutTransactionInput = {
    update: XOR<DictPlatformUpdateWithoutTransactionInput, DictPlatformUncheckedUpdateWithoutTransactionInput>
    create: XOR<DictPlatformCreateWithoutTransactionInput, DictPlatformUncheckedCreateWithoutTransactionInput>
    where?: DictPlatformWhereInput
  }

  export type DictPlatformUpdateToOneWithWhereWithoutTransactionInput = {
    where?: DictPlatformWhereInput
    data: XOR<DictPlatformUpdateWithoutTransactionInput, DictPlatformUncheckedUpdateWithoutTransactionInput>
  }

  export type DictPlatformUpdateWithoutTransactionInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DictPlatformUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GroupTransactionUpsertWithWhereUniqueWithoutTransactionInput = {
    where: GroupTransactionWhereUniqueInput
    update: XOR<GroupTransactionUpdateWithoutTransactionInput, GroupTransactionUncheckedUpdateWithoutTransactionInput>
    create: XOR<GroupTransactionCreateWithoutTransactionInput, GroupTransactionUncheckedCreateWithoutTransactionInput>
  }

  export type GroupTransactionUpdateWithWhereUniqueWithoutTransactionInput = {
    where: GroupTransactionWhereUniqueInput
    data: XOR<GroupTransactionUpdateWithoutTransactionInput, GroupTransactionUncheckedUpdateWithoutTransactionInput>
  }

  export type GroupTransactionUpdateManyWithWhereWithoutTransactionInput = {
    where: GroupTransactionScalarWhereInput
    data: XOR<GroupTransactionUpdateManyMutationInput, GroupTransactionUncheckedUpdateManyWithoutTransactionInput>
  }

  export type GroupTransactionScalarWhereInput = {
    AND?: GroupTransactionScalarWhereInput | GroupTransactionScalarWhereInput[]
    OR?: GroupTransactionScalarWhereInput[]
    NOT?: GroupTransactionScalarWhereInput | GroupTransactionScalarWhereInput[]
    id?: IntFilter<"GroupTransaction"> | number
    groupId?: StringFilter<"GroupTransaction"> | string
    transactionId?: IntFilter<"GroupTransaction"> | number
  }

  export type BalanceRecordUpsertWithWhereUniqueWithoutTransactionInput = {
    where: BalanceRecordWhereUniqueInput
    update: XOR<BalanceRecordUpdateWithoutTransactionInput, BalanceRecordUncheckedUpdateWithoutTransactionInput>
    create: XOR<BalanceRecordCreateWithoutTransactionInput, BalanceRecordUncheckedCreateWithoutTransactionInput>
  }

  export type BalanceRecordUpdateWithWhereUniqueWithoutTransactionInput = {
    where: BalanceRecordWhereUniqueInput
    data: XOR<BalanceRecordUpdateWithoutTransactionInput, BalanceRecordUncheckedUpdateWithoutTransactionInput>
  }

  export type BalanceRecordUpdateManyWithWhereWithoutTransactionInput = {
    where: BalanceRecordScalarWhereInput
    data: XOR<BalanceRecordUpdateManyMutationInput, BalanceRecordUncheckedUpdateManyWithoutTransactionInput>
  }

  export type TransactionCreateWithoutGroupTransactionInput = {
    amount: number
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Course: CourseCreateNestedOneWithoutTransactionInput
    User: UserCreateNestedOneWithoutTransactionInput
    Platform: DictPlatformCreateNestedOneWithoutTransactionInput
    BalanceRecord?: BalanceRecordCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutGroupTransactionInput = {
    id?: number
    courseId: number
    userId: number
    amount: number
    platformId: number
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    BalanceRecord?: BalanceRecordUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutGroupTransactionInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutGroupTransactionInput, TransactionUncheckedCreateWithoutGroupTransactionInput>
  }

  export type TransactionUpsertWithoutGroupTransactionInput = {
    update: XOR<TransactionUpdateWithoutGroupTransactionInput, TransactionUncheckedUpdateWithoutGroupTransactionInput>
    create: XOR<TransactionCreateWithoutGroupTransactionInput, TransactionUncheckedCreateWithoutGroupTransactionInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutGroupTransactionInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutGroupTransactionInput, TransactionUncheckedUpdateWithoutGroupTransactionInput>
  }

  export type TransactionUpdateWithoutGroupTransactionInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Course?: CourseUpdateOneRequiredWithoutTransactionNestedInput
    User?: UserUpdateOneRequiredWithoutTransactionNestedInput
    Platform?: DictPlatformUpdateOneRequiredWithoutTransactionNestedInput
    BalanceRecord?: BalanceRecordUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutGroupTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    platformId?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    BalanceRecord?: BalanceRecordUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type AuditStageCreateWithoutFlowInput = {
    name: string
    level: number
    parent?: AuditStageCreateNestedOneWithoutChildrenInput
    children?: AuditStageCreateNestedManyWithoutParentInput
    AuditRecord?: AuditRecordCreateNestedManyWithoutStageInput
  }

  export type AuditStageUncheckedCreateWithoutFlowInput = {
    id?: number
    name: string
    level: number
    pid?: number | null
    children?: AuditStageUncheckedCreateNestedManyWithoutParentInput
    AuditRecord?: AuditRecordUncheckedCreateNestedManyWithoutStageInput
  }

  export type AuditStageCreateOrConnectWithoutFlowInput = {
    where: AuditStageWhereUniqueInput
    create: XOR<AuditStageCreateWithoutFlowInput, AuditStageUncheckedCreateWithoutFlowInput>
  }

  export type AuditStageCreateManyFlowInputEnvelope = {
    data: AuditStageCreateManyFlowInput | AuditStageCreateManyFlowInput[]
    skipDuplicates?: boolean
  }

  export type AuditStageUpsertWithWhereUniqueWithoutFlowInput = {
    where: AuditStageWhereUniqueInput
    update: XOR<AuditStageUpdateWithoutFlowInput, AuditStageUncheckedUpdateWithoutFlowInput>
    create: XOR<AuditStageCreateWithoutFlowInput, AuditStageUncheckedCreateWithoutFlowInput>
  }

  export type AuditStageUpdateWithWhereUniqueWithoutFlowInput = {
    where: AuditStageWhereUniqueInput
    data: XOR<AuditStageUpdateWithoutFlowInput, AuditStageUncheckedUpdateWithoutFlowInput>
  }

  export type AuditStageUpdateManyWithWhereWithoutFlowInput = {
    where: AuditStageScalarWhereInput
    data: XOR<AuditStageUpdateManyMutationInput, AuditStageUncheckedUpdateManyWithoutFlowInput>
  }

  export type AuditStageScalarWhereInput = {
    AND?: AuditStageScalarWhereInput | AuditStageScalarWhereInput[]
    OR?: AuditStageScalarWhereInput[]
    NOT?: AuditStageScalarWhereInput | AuditStageScalarWhereInput[]
    id?: IntFilter<"AuditStage"> | number
    flowId?: IntFilter<"AuditStage"> | number
    name?: StringFilter<"AuditStage"> | string
    level?: IntFilter<"AuditStage"> | number
    pid?: IntNullableFilter<"AuditStage"> | number | null
  }

  export type AuditFlowCreateWithoutAuditStageInput = {
    name: string
    description?: string | null
  }

  export type AuditFlowUncheckedCreateWithoutAuditStageInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type AuditFlowCreateOrConnectWithoutAuditStageInput = {
    where: AuditFlowWhereUniqueInput
    create: XOR<AuditFlowCreateWithoutAuditStageInput, AuditFlowUncheckedCreateWithoutAuditStageInput>
  }

  export type AuditStageCreateWithoutChildrenInput = {
    name: string
    level: number
    Flow: AuditFlowCreateNestedOneWithoutAuditStageInput
    parent?: AuditStageCreateNestedOneWithoutChildrenInput
    AuditRecord?: AuditRecordCreateNestedManyWithoutStageInput
  }

  export type AuditStageUncheckedCreateWithoutChildrenInput = {
    id?: number
    flowId: number
    name: string
    level: number
    pid?: number | null
    AuditRecord?: AuditRecordUncheckedCreateNestedManyWithoutStageInput
  }

  export type AuditStageCreateOrConnectWithoutChildrenInput = {
    where: AuditStageWhereUniqueInput
    create: XOR<AuditStageCreateWithoutChildrenInput, AuditStageUncheckedCreateWithoutChildrenInput>
  }

  export type AuditStageCreateWithoutParentInput = {
    name: string
    level: number
    Flow: AuditFlowCreateNestedOneWithoutAuditStageInput
    children?: AuditStageCreateNestedManyWithoutParentInput
    AuditRecord?: AuditRecordCreateNestedManyWithoutStageInput
  }

  export type AuditStageUncheckedCreateWithoutParentInput = {
    id?: number
    flowId: number
    name: string
    level: number
    children?: AuditStageUncheckedCreateNestedManyWithoutParentInput
    AuditRecord?: AuditRecordUncheckedCreateNestedManyWithoutStageInput
  }

  export type AuditStageCreateOrConnectWithoutParentInput = {
    where: AuditStageWhereUniqueInput
    create: XOR<AuditStageCreateWithoutParentInput, AuditStageUncheckedCreateWithoutParentInput>
  }

  export type AuditStageCreateManyParentInputEnvelope = {
    data: AuditStageCreateManyParentInput | AuditStageCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type AuditRecordCreateWithoutStageInput = {
    entityId: number
    entityType: string
    status?: string | null
    createdAt?: Date | string
    notes?: string | null
    Reviewer: UserCreateNestedOneWithoutAuditRecordInput
  }

  export type AuditRecordUncheckedCreateWithoutStageInput = {
    id?: number
    entityId: number
    entityType: string
    status?: string | null
    reviewerId: number
    createdAt?: Date | string
    notes?: string | null
  }

  export type AuditRecordCreateOrConnectWithoutStageInput = {
    where: AuditRecordWhereUniqueInput
    create: XOR<AuditRecordCreateWithoutStageInput, AuditRecordUncheckedCreateWithoutStageInput>
  }

  export type AuditRecordCreateManyStageInputEnvelope = {
    data: AuditRecordCreateManyStageInput | AuditRecordCreateManyStageInput[]
    skipDuplicates?: boolean
  }

  export type AuditFlowUpsertWithoutAuditStageInput = {
    update: XOR<AuditFlowUpdateWithoutAuditStageInput, AuditFlowUncheckedUpdateWithoutAuditStageInput>
    create: XOR<AuditFlowCreateWithoutAuditStageInput, AuditFlowUncheckedCreateWithoutAuditStageInput>
    where?: AuditFlowWhereInput
  }

  export type AuditFlowUpdateToOneWithWhereWithoutAuditStageInput = {
    where?: AuditFlowWhereInput
    data: XOR<AuditFlowUpdateWithoutAuditStageInput, AuditFlowUncheckedUpdateWithoutAuditStageInput>
  }

  export type AuditFlowUpdateWithoutAuditStageInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditFlowUncheckedUpdateWithoutAuditStageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditStageUpsertWithoutChildrenInput = {
    update: XOR<AuditStageUpdateWithoutChildrenInput, AuditStageUncheckedUpdateWithoutChildrenInput>
    create: XOR<AuditStageCreateWithoutChildrenInput, AuditStageUncheckedCreateWithoutChildrenInput>
    where?: AuditStageWhereInput
  }

  export type AuditStageUpdateToOneWithWhereWithoutChildrenInput = {
    where?: AuditStageWhereInput
    data: XOR<AuditStageUpdateWithoutChildrenInput, AuditStageUncheckedUpdateWithoutChildrenInput>
  }

  export type AuditStageUpdateWithoutChildrenInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    Flow?: AuditFlowUpdateOneRequiredWithoutAuditStageNestedInput
    parent?: AuditStageUpdateOneWithoutChildrenNestedInput
    AuditRecord?: AuditRecordUpdateManyWithoutStageNestedInput
  }

  export type AuditStageUncheckedUpdateWithoutChildrenInput = {
    id?: IntFieldUpdateOperationsInput | number
    flowId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    AuditRecord?: AuditRecordUncheckedUpdateManyWithoutStageNestedInput
  }

  export type AuditStageUpsertWithWhereUniqueWithoutParentInput = {
    where: AuditStageWhereUniqueInput
    update: XOR<AuditStageUpdateWithoutParentInput, AuditStageUncheckedUpdateWithoutParentInput>
    create: XOR<AuditStageCreateWithoutParentInput, AuditStageUncheckedCreateWithoutParentInput>
  }

  export type AuditStageUpdateWithWhereUniqueWithoutParentInput = {
    where: AuditStageWhereUniqueInput
    data: XOR<AuditStageUpdateWithoutParentInput, AuditStageUncheckedUpdateWithoutParentInput>
  }

  export type AuditStageUpdateManyWithWhereWithoutParentInput = {
    where: AuditStageScalarWhereInput
    data: XOR<AuditStageUpdateManyMutationInput, AuditStageUncheckedUpdateManyWithoutParentInput>
  }

  export type AuditRecordUpsertWithWhereUniqueWithoutStageInput = {
    where: AuditRecordWhereUniqueInput
    update: XOR<AuditRecordUpdateWithoutStageInput, AuditRecordUncheckedUpdateWithoutStageInput>
    create: XOR<AuditRecordCreateWithoutStageInput, AuditRecordUncheckedCreateWithoutStageInput>
  }

  export type AuditRecordUpdateWithWhereUniqueWithoutStageInput = {
    where: AuditRecordWhereUniqueInput
    data: XOR<AuditRecordUpdateWithoutStageInput, AuditRecordUncheckedUpdateWithoutStageInput>
  }

  export type AuditRecordUpdateManyWithWhereWithoutStageInput = {
    where: AuditRecordScalarWhereInput
    data: XOR<AuditRecordUpdateManyMutationInput, AuditRecordUncheckedUpdateManyWithoutStageInput>
  }

  export type AuditStageCreateWithoutAuditRecordInput = {
    name: string
    level: number
    Flow: AuditFlowCreateNestedOneWithoutAuditStageInput
    parent?: AuditStageCreateNestedOneWithoutChildrenInput
    children?: AuditStageCreateNestedManyWithoutParentInput
  }

  export type AuditStageUncheckedCreateWithoutAuditRecordInput = {
    id?: number
    flowId: number
    name: string
    level: number
    pid?: number | null
    children?: AuditStageUncheckedCreateNestedManyWithoutParentInput
  }

  export type AuditStageCreateOrConnectWithoutAuditRecordInput = {
    where: AuditStageWhereUniqueInput
    create: XOR<AuditStageCreateWithoutAuditRecordInput, AuditStageUncheckedCreateWithoutAuditRecordInput>
  }

  export type UserCreateWithoutAuditRecordInput = {
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    Attachment?: AttachmentCreateNestedManyWithoutUserInput
    Course?: CourseCreateNestedManyWithoutAuthorInput
    CourseContent?: CourseContentCreateNestedManyWithoutAuthorInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    BalanceRecord?: BalanceRecordCreateNestedManyWithoutUserInput
    Note?: NoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditRecordInput = {
    id?: number
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    Attachment?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    Course?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    CourseContent?: CourseContentUncheckedCreateNestedManyWithoutAuthorInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    BalanceRecord?: BalanceRecordUncheckedCreateNestedManyWithoutUserInput
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditRecordInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditRecordInput, UserUncheckedCreateWithoutAuditRecordInput>
  }

  export type AuditStageUpsertWithoutAuditRecordInput = {
    update: XOR<AuditStageUpdateWithoutAuditRecordInput, AuditStageUncheckedUpdateWithoutAuditRecordInput>
    create: XOR<AuditStageCreateWithoutAuditRecordInput, AuditStageUncheckedCreateWithoutAuditRecordInput>
    where?: AuditStageWhereInput
  }

  export type AuditStageUpdateToOneWithWhereWithoutAuditRecordInput = {
    where?: AuditStageWhereInput
    data: XOR<AuditStageUpdateWithoutAuditRecordInput, AuditStageUncheckedUpdateWithoutAuditRecordInput>
  }

  export type AuditStageUpdateWithoutAuditRecordInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    Flow?: AuditFlowUpdateOneRequiredWithoutAuditStageNestedInput
    parent?: AuditStageUpdateOneWithoutChildrenNestedInput
    children?: AuditStageUpdateManyWithoutParentNestedInput
  }

  export type AuditStageUncheckedUpdateWithoutAuditRecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    flowId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    children?: AuditStageUncheckedUpdateManyWithoutParentNestedInput
  }

  export type UserUpsertWithoutAuditRecordInput = {
    update: XOR<UserUpdateWithoutAuditRecordInput, UserUncheckedUpdateWithoutAuditRecordInput>
    create: XOR<UserCreateWithoutAuditRecordInput, UserUncheckedCreateWithoutAuditRecordInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditRecordInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditRecordInput, UserUncheckedUpdateWithoutAuditRecordInput>
  }

  export type UserUpdateWithoutAuditRecordInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserRole?: UserRoleUpdateManyWithoutUserNestedInput
    Attachment?: AttachmentUpdateManyWithoutUserNestedInput
    Course?: CourseUpdateManyWithoutAuthorNestedInput
    CourseContent?: CourseContentUpdateManyWithoutAuthorNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    BalanceRecord?: BalanceRecordUpdateManyWithoutUserNestedInput
    Note?: NoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditRecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    Attachment?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    Course?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    CourseContent?: CourseContentUncheckedUpdateManyWithoutAuthorNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    BalanceRecord?: BalanceRecordUncheckedUpdateManyWithoutUserNestedInput
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CouponCreateWithoutCouponTypeInput = {
    productId?: number | null
    threshold?: number | null
    discount: number
    validUntil: Date | string
    universal?: boolean
  }

  export type CouponUncheckedCreateWithoutCouponTypeInput = {
    id?: number
    productId?: number | null
    threshold?: number | null
    discount: number
    validUntil: Date | string
    universal?: boolean
  }

  export type CouponCreateOrConnectWithoutCouponTypeInput = {
    where: CouponWhereUniqueInput
    create: XOR<CouponCreateWithoutCouponTypeInput, CouponUncheckedCreateWithoutCouponTypeInput>
  }

  export type CouponCreateManyCouponTypeInputEnvelope = {
    data: CouponCreateManyCouponTypeInput | CouponCreateManyCouponTypeInput[]
    skipDuplicates?: boolean
  }

  export type CouponUpsertWithWhereUniqueWithoutCouponTypeInput = {
    where: CouponWhereUniqueInput
    update: XOR<CouponUpdateWithoutCouponTypeInput, CouponUncheckedUpdateWithoutCouponTypeInput>
    create: XOR<CouponCreateWithoutCouponTypeInput, CouponUncheckedCreateWithoutCouponTypeInput>
  }

  export type CouponUpdateWithWhereUniqueWithoutCouponTypeInput = {
    where: CouponWhereUniqueInput
    data: XOR<CouponUpdateWithoutCouponTypeInput, CouponUncheckedUpdateWithoutCouponTypeInput>
  }

  export type CouponUpdateManyWithWhereWithoutCouponTypeInput = {
    where: CouponScalarWhereInput
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyWithoutCouponTypeInput>
  }

  export type CouponScalarWhereInput = {
    AND?: CouponScalarWhereInput | CouponScalarWhereInput[]
    OR?: CouponScalarWhereInput[]
    NOT?: CouponScalarWhereInput | CouponScalarWhereInput[]
    id?: IntFilter<"Coupon"> | number
    productId?: IntNullableFilter<"Coupon"> | number | null
    typeId?: IntFilter<"Coupon"> | number
    threshold?: FloatNullableFilter<"Coupon"> | number | null
    discount?: FloatFilter<"Coupon"> | number
    validUntil?: DateTimeFilter<"Coupon"> | Date | string
    universal?: BoolFilter<"Coupon"> | boolean
  }

  export type DictCouponTypeCreateWithoutCouponInput = {
    name: string
    desc?: string | null
  }

  export type DictCouponTypeUncheckedCreateWithoutCouponInput = {
    id?: number
    name: string
    desc?: string | null
  }

  export type DictCouponTypeCreateOrConnectWithoutCouponInput = {
    where: DictCouponTypeWhereUniqueInput
    create: XOR<DictCouponTypeCreateWithoutCouponInput, DictCouponTypeUncheckedCreateWithoutCouponInput>
  }

  export type DictCouponTypeUpsertWithoutCouponInput = {
    update: XOR<DictCouponTypeUpdateWithoutCouponInput, DictCouponTypeUncheckedUpdateWithoutCouponInput>
    create: XOR<DictCouponTypeCreateWithoutCouponInput, DictCouponTypeUncheckedCreateWithoutCouponInput>
    where?: DictCouponTypeWhereInput
  }

  export type DictCouponTypeUpdateToOneWithWhereWithoutCouponInput = {
    where?: DictCouponTypeWhereInput
    data: XOR<DictCouponTypeUpdateWithoutCouponInput, DictCouponTypeUncheckedUpdateWithoutCouponInput>
  }

  export type DictCouponTypeUpdateWithoutCouponInput = {
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DictCouponTypeUncheckedUpdateWithoutCouponInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutBalanceRecordInput = {
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    Attachment?: AttachmentCreateNestedManyWithoutUserInput
    Course?: CourseCreateNestedManyWithoutAuthorInput
    CourseContent?: CourseContentCreateNestedManyWithoutAuthorInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    AuditRecord?: AuditRecordCreateNestedManyWithoutReviewerInput
    Note?: NoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBalanceRecordInput = {
    id?: number
    username: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    Attachment?: AttachmentUncheckedCreateNestedManyWithoutUserInput
    Course?: CourseUncheckedCreateNestedManyWithoutAuthorInput
    CourseContent?: CourseContentUncheckedCreateNestedManyWithoutAuthorInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    AuditRecord?: AuditRecordUncheckedCreateNestedManyWithoutReviewerInput
    Note?: NoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBalanceRecordInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBalanceRecordInput, UserUncheckedCreateWithoutBalanceRecordInput>
  }

  export type TransactionCreateWithoutBalanceRecordInput = {
    amount: number
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Course: CourseCreateNestedOneWithoutTransactionInput
    User: UserCreateNestedOneWithoutTransactionInput
    Platform: DictPlatformCreateNestedOneWithoutTransactionInput
    GroupTransaction?: GroupTransactionCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutBalanceRecordInput = {
    id?: number
    courseId: number
    userId: number
    amount: number
    platformId: number
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    GroupTransaction?: GroupTransactionUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutBalanceRecordInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutBalanceRecordInput, TransactionUncheckedCreateWithoutBalanceRecordInput>
  }

  export type UserUpsertWithoutBalanceRecordInput = {
    update: XOR<UserUpdateWithoutBalanceRecordInput, UserUncheckedUpdateWithoutBalanceRecordInput>
    create: XOR<UserCreateWithoutBalanceRecordInput, UserUncheckedCreateWithoutBalanceRecordInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBalanceRecordInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBalanceRecordInput, UserUncheckedUpdateWithoutBalanceRecordInput>
  }

  export type UserUpdateWithoutBalanceRecordInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserRole?: UserRoleUpdateManyWithoutUserNestedInput
    Attachment?: AttachmentUpdateManyWithoutUserNestedInput
    Course?: CourseUpdateManyWithoutAuthorNestedInput
    CourseContent?: CourseContentUpdateManyWithoutAuthorNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    AuditRecord?: AuditRecordUpdateManyWithoutReviewerNestedInput
    Note?: NoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBalanceRecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    Attachment?: AttachmentUncheckedUpdateManyWithoutUserNestedInput
    Course?: CourseUncheckedUpdateManyWithoutAuthorNestedInput
    CourseContent?: CourseContentUncheckedUpdateManyWithoutAuthorNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    AuditRecord?: AuditRecordUncheckedUpdateManyWithoutReviewerNestedInput
    Note?: NoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TransactionUpsertWithoutBalanceRecordInput = {
    update: XOR<TransactionUpdateWithoutBalanceRecordInput, TransactionUncheckedUpdateWithoutBalanceRecordInput>
    create: XOR<TransactionCreateWithoutBalanceRecordInput, TransactionUncheckedCreateWithoutBalanceRecordInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutBalanceRecordInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutBalanceRecordInput, TransactionUncheckedUpdateWithoutBalanceRecordInput>
  }

  export type TransactionUpdateWithoutBalanceRecordInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Course?: CourseUpdateOneRequiredWithoutTransactionNestedInput
    User?: UserUpdateOneRequiredWithoutTransactionNestedInput
    Platform?: DictPlatformUpdateOneRequiredWithoutTransactionNestedInput
    GroupTransaction?: GroupTransactionUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutBalanceRecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    platformId?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GroupTransaction?: GroupTransactionUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type UserRoleCreateManyUserInput = {
    roleId: number
  }

  export type AttachmentCreateManyUserInput = {
    id?: number
    type: string
    location: string
    name?: string | null
    ossType?: string | null
    status?: number
    desc?: string | null
    createdAt?: Date | string | null
  }

  export type CourseCreateManyAuthorInput = {
    id?: number
    title: string
    subTitle?: string | null
    desc?: string | null
    coverId?: number | null
    originPrice?: number | null
    price?: number | null
    status?: number
    counts?: number
    order?: number
    detail?: string | null
    type?: string | null
  }

  export type CourseContentCreateManyAuthorInput = {
    id?: number
    courseId: number
    title: string
    type?: string | null
    order?: number
    pid?: number | null
    status?: number
  }

  export type CommentCreateManyUserInput = {
    id?: number
    pid?: number | null
    created?: Date | string
    hands?: bigint | number
    status?: number
    isBest?: number
  }

  export type TransactionCreateManyUserInput = {
    id?: number
    courseId: number
    amount: number
    platformId: number
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type AuditRecordCreateManyReviewerInput = {
    id?: number
    entityId: number
    entityType: string
    stageId: number
    status?: string | null
    createdAt?: Date | string
    notes?: string | null
  }

  export type BalanceRecordCreateManyUserInput = {
    id?: number
    transactionId?: number | null
    amount: number
    type?: number
    createdAt?: Date | string
  }

  export type NoteCreateManyUserInput = {
    id?: number
    content: string
    createAt?: Date | string
    updateAt?: Date | string | null
    status?: number | null
  }

  export type UserRoleUpdateWithoutUserInput = {
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type AttachmentUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    ossType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttachmentAttribute?: AttachmentAttributeUpdateManyWithoutAttachmentNestedInput
    Course?: CourseUpdateManyWithoutCoverNestedInput
    ContentAttachment?: ContentAttachmentUpdateManyWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    ossType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AttachmentAttribute?: AttachmentAttributeUncheckedUpdateManyWithoutAttachmentNestedInput
    Course?: CourseUncheckedUpdateManyWithoutCoverNestedInput
    ContentAttachment?: ContentAttachmentUncheckedUpdateManyWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    ossType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourseUpdateWithoutAuthorInput = {
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    originPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    counts?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Cover?: AttachmentUpdateOneWithoutCourseNestedInput
    Contents?: CourseContentUpdateManyWithoutCourseNestedInput
    Tags?: CourseTagUpdateManyWithoutCourseNestedInput
    CourseComment?: CourseCommentUpdateManyWithoutCourseNestedInput
    Transaction?: TransactionUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    coverId?: NullableIntFieldUpdateOperationsInput | number | null
    originPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    counts?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Contents?: CourseContentUncheckedUpdateManyWithoutCourseNestedInput
    Tags?: CourseTagUncheckedUpdateManyWithoutCourseNestedInput
    CourseComment?: CourseCommentUncheckedUpdateManyWithoutCourseNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    coverId?: NullableIntFieldUpdateOperationsInput | number | null
    originPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    counts?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseContentUpdateWithoutAuthorInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    Course?: CourseUpdateOneRequiredWithoutContentsNestedInput
    Attachments?: ContentAttachmentUpdateManyWithoutContentNestedInput
    Tags?: ContentTagUpdateManyWithoutContentNestedInput
    ContentComment?: ContentCommentUpdateManyWithoutContentNestedInput
  }

  export type CourseContentUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    Attachments?: ContentAttachmentUncheckedUpdateManyWithoutContentNestedInput
    Tags?: ContentTagUncheckedUpdateManyWithoutContentNestedInput
    ContentComment?: ContentCommentUncheckedUpdateManyWithoutContentNestedInput
  }

  export type CourseContentUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
  }

  export type CommentUpdateWithoutUserInput = {
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    hands?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: IntFieldUpdateOperationsInput | number
    isBest?: IntFieldUpdateOperationsInput | number
    parent?: CommentUpdateOneWithoutChildrenNestedInput
    children?: CommentUpdateManyWithoutParentNestedInput
    CourseComment?: CourseCommentUpdateManyWithoutCommentNestedInput
    ContentComment?: ContentCommentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    hands?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: IntFieldUpdateOperationsInput | number
    isBest?: IntFieldUpdateOperationsInput | number
    children?: CommentUncheckedUpdateManyWithoutParentNestedInput
    CourseComment?: CourseCommentUncheckedUpdateManyWithoutCommentNestedInput
    ContentComment?: ContentCommentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    hands?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: IntFieldUpdateOperationsInput | number
    isBest?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionUpdateWithoutUserInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Course?: CourseUpdateOneRequiredWithoutTransactionNestedInput
    Platform?: DictPlatformUpdateOneRequiredWithoutTransactionNestedInput
    GroupTransaction?: GroupTransactionUpdateManyWithoutTransactionNestedInput
    BalanceRecord?: BalanceRecordUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    platformId?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GroupTransaction?: GroupTransactionUncheckedUpdateManyWithoutTransactionNestedInput
    BalanceRecord?: BalanceRecordUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    platformId?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditRecordUpdateWithoutReviewerInput = {
    entityId?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    Stage?: AuditStageUpdateOneRequiredWithoutAuditRecordNestedInput
  }

  export type AuditRecordUncheckedUpdateWithoutReviewerInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityId?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    stageId?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditRecordUncheckedUpdateManyWithoutReviewerInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityId?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    stageId?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BalanceRecordUpdateWithoutUserInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Transaction?: TransactionUpdateOneWithoutBalanceRecordNestedInput
  }

  export type BalanceRecordUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceRecordUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NoteUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NoteUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserRoleCreateManyRoleInput = {
    userId: number
  }

  export type RolePermissionsCreateManyRoleInput = {
    permissionId: number
  }

  export type RolePolicyCreateManyRoleInput = {
    policyId: number
  }

  export type RoleMenuCreateManyRoleInput = {
    menuId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRoleUpdateWithoutRoleInput = {
    user?: UserUpdateOneRequiredWithoutUserRoleNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type RolePermissionsUpdateWithoutRoleInput = {
    permission?: PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionsUncheckedUpdateWithoutRoleInput = {
    permissionId?: IntFieldUpdateOperationsInput | number
  }

  export type RolePermissionsUncheckedUpdateManyWithoutRoleInput = {
    permissionId?: IntFieldUpdateOperationsInput | number
  }

  export type RolePolicyUpdateWithoutRoleInput = {
    policy?: PolicyUpdateOneRequiredWithoutRolePolicyNestedInput
  }

  export type RolePolicyUncheckedUpdateWithoutRoleInput = {
    policyId?: IntFieldUpdateOperationsInput | number
  }

  export type RolePolicyUncheckedUpdateManyWithoutRoleInput = {
    policyId?: IntFieldUpdateOperationsInput | number
  }

  export type RoleMenuUpdateWithoutRoleInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: MenuUpdateOneRequiredWithoutRoleMenusNestedInput
  }

  export type RoleMenuUncheckedUpdateWithoutRoleInput = {
    menuId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleMenuUncheckedUpdateManyWithoutRoleInput = {
    menuId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionsCreateManyPermissionInput = {
    roleId: number
  }

  export type PermissionPolicyCreateManyPermissionInput = {
    policyId: number
  }

  export type RolePermissionsUpdateWithoutPermissionInput = {
    role?: RoleUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionsUncheckedUpdateWithoutPermissionInput = {
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type RolePermissionsUncheckedUpdateManyWithoutPermissionInput = {
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type PermissionPolicyUpdateWithoutPermissionInput = {
    policy?: PolicyUpdateOneRequiredWithoutPermissionPolicyNestedInput
  }

  export type PermissionPolicyUncheckedUpdateWithoutPermissionInput = {
    policyId?: IntFieldUpdateOperationsInput | number
  }

  export type PermissionPolicyUncheckedUpdateManyWithoutPermissionInput = {
    policyId?: IntFieldUpdateOperationsInput | number
  }

  export type RolePolicyCreateManyPolicyInput = {
    roleId: number
  }

  export type PermissionPolicyCreateManyPolicyInput = {
    permissionId: number
  }

  export type RolePolicyUpdateWithoutPolicyInput = {
    role?: RoleUpdateOneRequiredWithoutRolePolicyNestedInput
  }

  export type RolePolicyUncheckedUpdateWithoutPolicyInput = {
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type RolePolicyUncheckedUpdateManyWithoutPolicyInput = {
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type PermissionPolicyUpdateWithoutPolicyInput = {
    permission?: PermissionUpdateOneRequiredWithoutPermissionPolicyNestedInput
  }

  export type PermissionPolicyUncheckedUpdateWithoutPolicyInput = {
    permissionId?: IntFieldUpdateOperationsInput | number
  }

  export type PermissionPolicyUncheckedUpdateManyWithoutPolicyInput = {
    permissionId?: IntFieldUpdateOperationsInput | number
  }

  export type MenuCreateManyParentInput = {
    id?: number
    name: string
    path: string
    label: string
    component?: string | null
    redirect?: string | null
    fullPath?: string | null
    alias?: string | null
    status?: number
    metaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleMenuCreateManyMenuInput = {
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuUpdateWithoutParentInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    component?: NullableStringFieldUpdateOperationsInput | string | null
    redirect?: NullableStringFieldUpdateOperationsInput | string | null
    fullPath?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    metaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meta?: MenuMetaUpdateOneWithoutMenuNestedInput
    children?: MenuUpdateManyWithoutParentNestedInput
    roleMenus?: RoleMenuUpdateManyWithoutMenuNestedInput
  }

  export type MenuUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    component?: NullableStringFieldUpdateOperationsInput | string | null
    redirect?: NullableStringFieldUpdateOperationsInput | string | null
    fullPath?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    metaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meta?: MenuMetaUncheckedUpdateOneWithoutMenuNestedInput
    children?: MenuUncheckedUpdateManyWithoutParentNestedInput
    roleMenus?: RoleMenuUncheckedUpdateManyWithoutMenuNestedInput
  }

  export type MenuUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    component?: NullableStringFieldUpdateOperationsInput | string | null
    redirect?: NullableStringFieldUpdateOperationsInput | string | null
    fullPath?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    metaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleMenuUpdateWithoutMenuInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutRoleMenuNestedInput
  }

  export type RoleMenuUncheckedUpdateWithoutMenuInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleMenuUncheckedUpdateManyWithoutMenuInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentAttributeCreateManyDictAttributeInput = {
    attachmentId: number
    value: string
    desc?: string | null
  }

  export type AttachmentAttributeUpdateWithoutDictAttributeInput = {
    value?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    Attachment?: AttachmentUpdateOneRequiredWithoutAttachmentAttributeNestedInput
  }

  export type AttachmentAttributeUncheckedUpdateWithoutDictAttributeInput = {
    attachmentId?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttachmentAttributeUncheckedUpdateManyWithoutDictAttributeInput = {
    attachmentId?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttachmentAttributeCreateManyAttachmentInput = {
    attributeId: number
    value: string
    desc?: string | null
  }

  export type CourseCreateManyCoverInput = {
    id?: number
    title: string
    subTitle?: string | null
    desc?: string | null
    authorId: number
    originPrice?: number | null
    price?: number | null
    status?: number
    counts?: number
    order?: number
    detail?: string | null
    type?: string | null
  }

  export type ContentAttachmentCreateManyAttachmentInput = {
    contentId: number
  }

  export type AttachmentAttributeUpdateWithoutAttachmentInput = {
    value?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    DictAttribute?: DictAttachmentAttributeUpdateOneRequiredWithoutAttachmentAttributeNestedInput
  }

  export type AttachmentAttributeUncheckedUpdateWithoutAttachmentInput = {
    attributeId?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttachmentAttributeUncheckedUpdateManyWithoutAttachmentInput = {
    attributeId?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseUpdateWithoutCoverInput = {
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    originPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    counts?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Author?: UserUpdateOneRequiredWithoutCourseNestedInput
    Contents?: CourseContentUpdateManyWithoutCourseNestedInput
    Tags?: CourseTagUpdateManyWithoutCourseNestedInput
    CourseComment?: CourseCommentUpdateManyWithoutCourseNestedInput
    Transaction?: TransactionUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCoverInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: IntFieldUpdateOperationsInput | number
    originPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    counts?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    Contents?: CourseContentUncheckedUpdateManyWithoutCourseNestedInput
    Tags?: CourseTagUncheckedUpdateManyWithoutCourseNestedInput
    CourseComment?: CourseCommentUncheckedUpdateManyWithoutCourseNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutCoverInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subTitle?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: IntFieldUpdateOperationsInput | number
    originPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    counts?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContentAttachmentUpdateWithoutAttachmentInput = {
    Content?: CourseContentUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type ContentAttachmentUncheckedUpdateWithoutAttachmentInput = {
    contentId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentAttachmentUncheckedUpdateManyWithoutAttachmentInput = {
    contentId?: IntFieldUpdateOperationsInput | number
  }

  export type CourseContentCreateManyCourseInput = {
    id?: number
    title: string
    type?: string | null
    order?: number
    pid?: number | null
    status?: number
    authorId: number
  }

  export type CourseTagCreateManyCourseInput = {
    tagId: number
  }

  export type CourseCommentCreateManyCourseInput = {
    commentId: number
  }

  export type TransactionCreateManyCourseInput = {
    id?: number
    userId: number
    amount: number
    platformId: number
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type CourseContentUpdateWithoutCourseInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    Author?: UserUpdateOneRequiredWithoutCourseContentNestedInput
    Attachments?: ContentAttachmentUpdateManyWithoutContentNestedInput
    Tags?: ContentTagUpdateManyWithoutContentNestedInput
    ContentComment?: ContentCommentUpdateManyWithoutContentNestedInput
  }

  export type CourseContentUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    Attachments?: ContentAttachmentUncheckedUpdateManyWithoutContentNestedInput
    Tags?: ContentTagUncheckedUpdateManyWithoutContentNestedInput
    ContentComment?: ContentCommentUncheckedUpdateManyWithoutContentNestedInput
  }

  export type CourseContentUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
  }

  export type CourseTagUpdateWithoutCourseInput = {
    Tag?: DictCourseTagUpdateOneRequiredWithoutCourseTagNestedInput
  }

  export type CourseTagUncheckedUpdateWithoutCourseInput = {
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type CourseTagUncheckedUpdateManyWithoutCourseInput = {
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type CourseCommentUpdateWithoutCourseInput = {
    Comment?: CommentUpdateOneRequiredWithoutCourseCommentNestedInput
  }

  export type CourseCommentUncheckedUpdateWithoutCourseInput = {
    commentId?: IntFieldUpdateOperationsInput | number
  }

  export type CourseCommentUncheckedUpdateManyWithoutCourseInput = {
    commentId?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionUpdateWithoutCourseInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneRequiredWithoutTransactionNestedInput
    Platform?: DictPlatformUpdateOneRequiredWithoutTransactionNestedInput
    GroupTransaction?: GroupTransactionUpdateManyWithoutTransactionNestedInput
    BalanceRecord?: BalanceRecordUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    platformId?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GroupTransaction?: GroupTransactionUncheckedUpdateManyWithoutTransactionNestedInput
    BalanceRecord?: BalanceRecordUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    platformId?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentAttachmentCreateManyContentInput = {
    attachmentId: number
  }

  export type ContentTagCreateManyContentInput = {
    tagId: number
  }

  export type ContentCommentCreateManyContentInput = {
    commentId: number
  }

  export type ContentAttachmentUpdateWithoutContentInput = {
    Attachment?: AttachmentUpdateOneRequiredWithoutContentAttachmentNestedInput
  }

  export type ContentAttachmentUncheckedUpdateWithoutContentInput = {
    attachmentId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentAttachmentUncheckedUpdateManyWithoutContentInput = {
    attachmentId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentTagUpdateWithoutContentInput = {
    Tag?: DictCourseTagUpdateOneRequiredWithoutContentTagNestedInput
  }

  export type ContentTagUncheckedUpdateWithoutContentInput = {
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentTagUncheckedUpdateManyWithoutContentInput = {
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentCommentUpdateWithoutContentInput = {
    Comment?: CommentUpdateOneRequiredWithoutContentCommentNestedInput
  }

  export type ContentCommentUncheckedUpdateWithoutContentInput = {
    commentId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentCommentUncheckedUpdateManyWithoutContentInput = {
    commentId?: IntFieldUpdateOperationsInput | number
  }

  export type CourseTagCreateManyTagInput = {
    courseId: number
  }

  export type ContentTagCreateManyTagInput = {
    contentId: number
  }

  export type CourseTagUpdateWithoutTagInput = {
    Course?: CourseUpdateOneRequiredWithoutTagsNestedInput
  }

  export type CourseTagUncheckedUpdateWithoutTagInput = {
    courseId?: IntFieldUpdateOperationsInput | number
  }

  export type CourseTagUncheckedUpdateManyWithoutTagInput = {
    courseId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentTagUpdateWithoutTagInput = {
    Content?: CourseContentUpdateOneRequiredWithoutTagsNestedInput
  }

  export type ContentTagUncheckedUpdateWithoutTagInput = {
    contentId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentTagUncheckedUpdateManyWithoutTagInput = {
    contentId?: IntFieldUpdateOperationsInput | number
  }

  export type DictCourseTagCreateManyCourseTypeInput = {
    id?: number
    name: string
    order?: number
    status?: number
  }

  export type DictCourseTagUpdateWithoutCourseTypeInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    CourseTag?: CourseTagUpdateManyWithoutTagNestedInput
    ContentTag?: ContentTagUpdateManyWithoutTagNestedInput
  }

  export type DictCourseTagUncheckedUpdateWithoutCourseTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    CourseTag?: CourseTagUncheckedUpdateManyWithoutTagNestedInput
    ContentTag?: ContentTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type DictCourseTagUncheckedUpdateManyWithoutCourseTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
  }

  export type CommentCreateManyParentInput = {
    id?: number
    userId: number
    created?: Date | string
    hands?: bigint | number
    status?: number
    isBest?: number
  }

  export type CourseCommentCreateManyCommentInput = {
    courseId: number
  }

  export type ContentCommentCreateManyCommentInput = {
    contentId: number
  }

  export type CommentUpdateWithoutParentInput = {
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    hands?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: IntFieldUpdateOperationsInput | number
    isBest?: IntFieldUpdateOperationsInput | number
    User?: UserUpdateOneRequiredWithoutCommentNestedInput
    children?: CommentUpdateManyWithoutParentNestedInput
    CourseComment?: CourseCommentUpdateManyWithoutCommentNestedInput
    ContentComment?: ContentCommentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    hands?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: IntFieldUpdateOperationsInput | number
    isBest?: IntFieldUpdateOperationsInput | number
    children?: CommentUncheckedUpdateManyWithoutParentNestedInput
    CourseComment?: CourseCommentUncheckedUpdateManyWithoutCommentNestedInput
    ContentComment?: ContentCommentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    hands?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: IntFieldUpdateOperationsInput | number
    isBest?: IntFieldUpdateOperationsInput | number
  }

  export type CourseCommentUpdateWithoutCommentInput = {
    Course?: CourseUpdateOneRequiredWithoutCourseCommentNestedInput
  }

  export type CourseCommentUncheckedUpdateWithoutCommentInput = {
    courseId?: IntFieldUpdateOperationsInput | number
  }

  export type CourseCommentUncheckedUpdateManyWithoutCommentInput = {
    courseId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentCommentUpdateWithoutCommentInput = {
    Content?: CourseContentUpdateOneRequiredWithoutContentCommentNestedInput
  }

  export type ContentCommentUncheckedUpdateWithoutCommentInput = {
    contentId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentCommentUncheckedUpdateManyWithoutCommentInput = {
    contentId?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionCreateManyPlatformInput = {
    id?: number
    courseId: number
    userId: number
    amount: number
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type TransactionUpdateWithoutPlatformInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Course?: CourseUpdateOneRequiredWithoutTransactionNestedInput
    User?: UserUpdateOneRequiredWithoutTransactionNestedInput
    GroupTransaction?: GroupTransactionUpdateManyWithoutTransactionNestedInput
    BalanceRecord?: BalanceRecordUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutPlatformInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GroupTransaction?: GroupTransactionUncheckedUpdateManyWithoutTransactionNestedInput
    BalanceRecord?: BalanceRecordUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutPlatformInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupTransactionCreateManyTransactionInput = {
    id?: number
    groupId: string
  }

  export type BalanceRecordCreateManyTransactionInput = {
    id?: number
    userId: number
    amount: number
    type?: number
    createdAt?: Date | string
  }

  export type GroupTransactionUpdateWithoutTransactionInput = {
    groupId?: StringFieldUpdateOperationsInput | string
  }

  export type GroupTransactionUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: StringFieldUpdateOperationsInput | string
  }

  export type GroupTransactionUncheckedUpdateManyWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: StringFieldUpdateOperationsInput | string
  }

  export type BalanceRecordUpdateWithoutTransactionInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutBalanceRecordNestedInput
  }

  export type BalanceRecordUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceRecordUncheckedUpdateManyWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditStageCreateManyFlowInput = {
    id?: number
    name: string
    level: number
    pid?: number | null
  }

  export type AuditStageUpdateWithoutFlowInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    parent?: AuditStageUpdateOneWithoutChildrenNestedInput
    children?: AuditStageUpdateManyWithoutParentNestedInput
    AuditRecord?: AuditRecordUpdateManyWithoutStageNestedInput
  }

  export type AuditStageUncheckedUpdateWithoutFlowInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
    children?: AuditStageUncheckedUpdateManyWithoutParentNestedInput
    AuditRecord?: AuditRecordUncheckedUpdateManyWithoutStageNestedInput
  }

  export type AuditStageUncheckedUpdateManyWithoutFlowInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    pid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AuditStageCreateManyParentInput = {
    id?: number
    flowId: number
    name: string
    level: number
  }

  export type AuditRecordCreateManyStageInput = {
    id?: number
    entityId: number
    entityType: string
    status?: string | null
    reviewerId: number
    createdAt?: Date | string
    notes?: string | null
  }

  export type AuditStageUpdateWithoutParentInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    Flow?: AuditFlowUpdateOneRequiredWithoutAuditStageNestedInput
    children?: AuditStageUpdateManyWithoutParentNestedInput
    AuditRecord?: AuditRecordUpdateManyWithoutStageNestedInput
  }

  export type AuditStageUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    flowId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    children?: AuditStageUncheckedUpdateManyWithoutParentNestedInput
    AuditRecord?: AuditRecordUncheckedUpdateManyWithoutStageNestedInput
  }

  export type AuditStageUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    flowId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type AuditRecordUpdateWithoutStageInput = {
    entityId?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    Reviewer?: UserUpdateOneRequiredWithoutAuditRecordNestedInput
  }

  export type AuditRecordUncheckedUpdateWithoutStageInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityId?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditRecordUncheckedUpdateManyWithoutStageInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityId?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CouponCreateManyCouponTypeInput = {
    id?: number
    productId?: number | null
    threshold?: number | null
    discount: number
    validUntil: Date | string
    universal?: boolean
  }

  export type CouponUpdateWithoutCouponTypeInput = {
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: FloatFieldUpdateOperationsInput | number
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    universal?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CouponUncheckedUpdateWithoutCouponTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: FloatFieldUpdateOperationsInput | number
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    universal?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CouponUncheckedUpdateManyWithoutCouponTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: FloatFieldUpdateOperationsInput | number
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    universal?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleCountOutputTypeDefaultArgs instead
     */
    export type RoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionCountOutputTypeDefaultArgs instead
     */
    export type PermissionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PolicyCountOutputTypeDefaultArgs instead
     */
    export type PolicyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PolicyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MenuCountOutputTypeDefaultArgs instead
     */
    export type MenuCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MenuCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DictAttachmentAttributeCountOutputTypeDefaultArgs instead
     */
    export type DictAttachmentAttributeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DictAttachmentAttributeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AttachmentCountOutputTypeDefaultArgs instead
     */
    export type AttachmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AttachmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseCountOutputTypeDefaultArgs instead
     */
    export type CourseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseContentCountOutputTypeDefaultArgs instead
     */
    export type CourseContentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseContentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DictCourseTagCountOutputTypeDefaultArgs instead
     */
    export type DictCourseTagCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DictCourseTagCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DictCourseTypeCountOutputTypeDefaultArgs instead
     */
    export type DictCourseTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DictCourseTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentCountOutputTypeDefaultArgs instead
     */
    export type CommentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DictPlatformCountOutputTypeDefaultArgs instead
     */
    export type DictPlatformCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DictPlatformCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionCountOutputTypeDefaultArgs instead
     */
    export type TransactionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditFlowCountOutputTypeDefaultArgs instead
     */
    export type AuditFlowCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditFlowCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditStageCountOutputTypeDefaultArgs instead
     */
    export type AuditStageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditStageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DictCouponTypeCountOutputTypeDefaultArgs instead
     */
    export type DictCouponTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DictCouponTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleDefaultArgs instead
     */
    export type RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserRoleDefaultArgs instead
     */
    export type UserRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserRoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionDefaultArgs instead
     */
    export type PermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolePermissionsDefaultArgs instead
     */
    export type RolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolePermissionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PolicyDefaultArgs instead
     */
    export type PolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PolicyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolePolicyDefaultArgs instead
     */
    export type RolePolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolePolicyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionPolicyDefaultArgs instead
     */
    export type PermissionPolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionPolicyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MenuDefaultArgs instead
     */
    export type MenuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MenuDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MenuMetaDefaultArgs instead
     */
    export type MenuMetaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MenuMetaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleMenuDefaultArgs instead
     */
    export type RoleMenuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleMenuDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DictAttachmentAttributeDefaultArgs instead
     */
    export type DictAttachmentAttributeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DictAttachmentAttributeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AttachmentAttributeDefaultArgs instead
     */
    export type AttachmentAttributeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AttachmentAttributeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AttachmentDefaultArgs instead
     */
    export type AttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AttachmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseDefaultArgs instead
     */
    export type CourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseContentDefaultArgs instead
     */
    export type CourseContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseContentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContentAttachmentDefaultArgs instead
     */
    export type ContentAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContentAttachmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DictCourseTagDefaultArgs instead
     */
    export type DictCourseTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DictCourseTagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DictCourseTypeDefaultArgs instead
     */
    export type DictCourseTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DictCourseTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseTagDefaultArgs instead
     */
    export type CourseTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseTagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContentTagDefaultArgs instead
     */
    export type ContentTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContentTagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseCommentDefaultArgs instead
     */
    export type CourseCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseCommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContentCommentDefaultArgs instead
     */
    export type ContentCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContentCommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NoteDefaultArgs instead
     */
    export type NoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DictPlatformDefaultArgs instead
     */
    export type DictPlatformArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DictPlatformDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionDefaultArgs instead
     */
    export type TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupTransactionDefaultArgs instead
     */
    export type GroupTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditFlowDefaultArgs instead
     */
    export type AuditFlowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditFlowDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditStageDefaultArgs instead
     */
    export type AuditStageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditStageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditRecordDefaultArgs instead
     */
    export type AuditRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DictCouponTypeDefaultArgs instead
     */
    export type DictCouponTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DictCouponTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CouponDefaultArgs instead
     */
    export type CouponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CouponDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BalanceRecordDefaultArgs instead
     */
    export type BalanceRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BalanceRecordDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}